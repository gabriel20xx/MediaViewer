<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>MediaViewer</title>
    <link rel="stylesheet" href="/styles.css" />
    <script>
      // Minimal global error logging so a runtime exception doesn't silently become a blank page.
      // Console-only (no UI changes).
      (() => {
        try {
          if (window.__mvGlobalErrorLoggingInstalled) return;
          window.__mvGlobalErrorLoggingInstalled = true;

          window.addEventListener('error', (ev) => {
            try {
              const msg = ev && ev.message ? ev.message : String(ev);
              const file = ev && ev.filename ? ev.filename : '';
              const line = ev && typeof ev.lineno === 'number' ? ev.lineno : '';
              const col = ev && typeof ev.colno === 'number' ? ev.colno : '';
              console.error('[mv webui] window error:', msg, file, line, col, ev && ev.error ? ev.error : '');
            } catch {}
          });

          window.addEventListener('unhandledrejection', (ev) => {
            try {
              console.error('[mv webui] unhandled rejection:', ev && ev.reason ? ev.reason : ev);
            } catch {}
          });
        } catch {}
      })();

      const state = {
        q: '',
        page: 1,
        pageSize: 12,
        total: 0,
        items: [],
        funFilter: 'all', // all | with | without
        vrFilter: 'all', // all | vr | nonvr
        gridMin: 180,
        sort: 'newest',
        lengthBucket: '', // '' | veryShort | short | medium | long | veryLong
        speedBucket: '', // '' | verySlow | slow | medium | fast | veryFast
        resolutionBucket: '', // '' | veryLow | low | medium | high | veryHigh
        // Scheduled play is opt-in; leaving it enabled by default breaks normal click-to-play
        // because the delayed play isn't considered a user gesture in many browsers.
        scheduledPlaySpec: '',
        durationsSec: {},
        thumbCache: {},
        _durToken: 0,
        _metaToken: 0,
        view: 'grid', // grid | player | vr
        current: null,
        clientId: null,
        ws: null,
        wsConnected: false,
        wsSessionId: 'default',
        clients: [],
        _applyingRemoteUntil: 0,
        _lastSentAt: 0,
        lastRemoteSync: null,
        lastRemoteAt: 0,
        remoteProjectedTimeMs: 0,
        remoteProjectedAtMs: 0,
        remoteServerClockOffsetMs: null,
        _scheduledPlayAtLocalMs: 0,
        _scheduledPlayTimerId: 0,
        _suppressLocalVideoEventsUntil: 0,
        _pendingSeekSync: null,
        thumbVer: 0,
      };

      function suppressLocalVideoEventsUntil(untilMs) {
        const t = Number(untilMs) || 0;
        if (!Number.isFinite(t) || t <= 0) return;
        state._suppressLocalVideoEventsUntil = Math.max(Number(state._suppressLocalVideoEventsUntil) || 0, t);
      }

      function isLocalVideoEventSuppressed() {
        return Date.now() < (Number(state._suppressLocalVideoEventsUntil) || 0);
      }

      function getFirstDesktopClientId() {
        try {
          const clients = Array.isArray(state.clients) ? state.clients : [];
          const d = clients.find(c => c && typeof c.clientId === 'string' && c.clientId.startsWith('desktop-'));
          return d ? d.clientId : null;
        } catch {
          return null;
        }
      }

      function isClientIdConnected(clientId) {
        const id = String(clientId || '').trim();
        if (!id) return false;
        try {
          const clients = Array.isArray(state.clients) ? state.clients : [];
          return clients.some((c) => c && String(c.clientId || '') === id);
        } catch {
          return false;
        }
      }

      function waitForVideoReadyAt(v, targetTimeSeconds, timeoutMs = 6000) {
        if (!(v instanceof HTMLVideoElement)) return Promise.resolve(false);
        const target = Number(targetTimeSeconds) || 0;
        const start = Date.now();
        return new Promise((resolve) => {
          let done = false;
          const finish = (ok) => {
            if (done) return;
            done = true;
            cleanup();
            resolve(Boolean(ok));
          };
          const check = () => {
            if (done) return;
            const now = Date.now();
            if (now - start > timeoutMs) return finish(false);
            const ct = Number.isFinite(v.currentTime) ? v.currentTime : NaN;
            const near = Number.isFinite(ct) ? Math.abs(ct - target) < 0.25 : false;
            const ready = (v.readyState || 0) >= 3; // HAVE_FUTURE_DATA
            if (!v.seeking && near && ready) return finish(true);
          };
          const onEvt = () => check();
          const timer = window.setInterval(check, 100);
          function cleanup() {
            try { window.clearInterval(timer); } catch {}
            try { v.removeEventListener('seeked', onEvt); } catch {}
            try { v.removeEventListener('canplay', onEvt); } catch {}
            try { v.removeEventListener('loadeddata', onEvt); } catch {}
            try { v.removeEventListener('stalled', onEvt); } catch {}
          }
          v.addEventListener('seeked', onEvt);
          v.addEventListener('canplay', onEvt);
          v.addEventListener('loadeddata', onEvt);
          v.addEventListener('stalled', onEvt);
          check();
        });
      }

      async function startSeekSyncAsLeader(v, mediaId, timeMs) {
        if (!(v instanceof HTMLVideoElement)) return;
        if (!mediaId) return;

        const peerId = getFirstDesktopClientId();
        if (!peerId) return;

        const seekMs = Math.max(0, Math.round(Number(timeMs) || 0));
        const token = `${state.clientId}:${Date.now()}:${Math.random().toString(16).slice(2)}`;

        state._pendingSeekSync = { token, peerId, mediaId: String(mediaId), timeMs: seekMs, selfReady: false, peerReady: false };
        suppressLocalVideoEventsUntil(Date.now() + 7000);

        try { v.pause(); } catch {}
        try { v.currentTime = seekMs / 1000; } catch {}

        sendSyncUpdate({
          mediaId: String(mediaId),
          timeMs: seekMs,
          paused: true,
          fps: 30,
          frame: Math.max(0, Math.floor((seekMs / 1000) * 30)),
          seekToken: token,
          seekPhase: 'request',
          seekWantPlay: true,
          seekTargetClientId: peerId,
        }, true, peerId);

        const okSelf = await waitForVideoReadyAt(v, seekMs / 1000, 6000);
        if (state._pendingSeekSync && state._pendingSeekSync.token === token) {
          state._pendingSeekSync.selfReady = okSelf;
        }

        const startWait = Date.now();
        while (state._pendingSeekSync && state._pendingSeekSync.token === token) {
          const p = state._pendingSeekSync;
          if (p.selfReady && p.peerReady) break;
          if (Date.now() - startWait > 6500) break;
          await new Promise(r => setTimeout(r, 60));
        }

        const p = state._pendingSeekSync;
        if (!p || p.token !== token) return;

        const playAtLocalMs = Date.now() + 650;
        const offset = (typeof state.remoteServerClockOffsetMs === 'number' && Number.isFinite(state.remoteServerClockOffsetMs))
          ? state.remoteServerClockOffsetMs
          : 0;
        const playAtServerMs = playAtLocalMs - offset;
        const playAtIso = new Date(playAtServerMs).toISOString();

        sendSyncUpdate({
          mediaId: p.mediaId,
          timeMs: p.timeMs,
          paused: false,
          fps: 30,
          frame: Math.max(0, Math.floor((p.timeMs / 1000) * 30)),
          playAt: playAtIso,
          seekToken: token,
          seekPhase: 'commit',
          seekTargetClientId: p.peerId,
        }, true, p.peerId);

        try { v.pause(); } catch {}
        try { v.currentTime = p.timeMs / 1000; } catch {}
        scheduleLocalPlayAt(v, playAtLocalMs);

        state._pendingSeekSync = null;
      }

      function el(id) { return document.getElementById(id); }

      async function apiJson(url, opts) {
        const res = await fetch(url, opts);
        if (!res.ok) throw new Error(await res.text());
        return res.json();
      }

      function sendClientStatus() {
        try {
          if (!state.wsConnected || !state.ws || state.ws.readyState !== 1) return;
          if (!state.clientId) return;
          state.ws.send(JSON.stringify({
            type: 'client:status',
            clientId: state.clientId,
            sessionId: state.wsSessionId,
            uiView: state.view,
            mediaId: state.current?.id ?? null,
          }));
        } catch {
          // ignore
        }
      }

      function setView(view, current = null) {
        state.view = view;
        state.current = current;
        sendClientStatus();
        render();
      }

      function ensureClientId() {
        if (state.clientId) return state.clientId;
        const key = 'mvClientId';
        const existing = window.localStorage.getItem(key);
        if (existing) {
          state.clientId = existing;
          return existing;
        }
        const id = 'web-' + Math.random().toString(16).slice(2);
        window.localStorage.setItem(key, id);
        state.clientId = id;
        return id;
      }

      function loadPrefs() {
        try {
          const saved = window.localStorage.getItem('mvPrefs');
          if (saved) {
            const prefs = JSON.parse(saved);
            if (typeof prefs.pageSize === 'number' && Number.isFinite(prefs.pageSize) && prefs.pageSize > 0) {
              state.pageSize = Math.max(1, Math.round(prefs.pageSize));
            }
            if (typeof prefs.gridMin === 'number' && prefs.gridMin >= 120 && prefs.gridMin <= 360) {
              state.gridMin = prefs.gridMin;
            }
            if (typeof prefs.sort === 'string') state.sort = prefs.sort;

            const isBucket = (v) => typeof v === 'string' && v.length > 0;

            // New bucketed filter UX.
            if (isBucket(prefs.lengthBucket)) state.lengthBucket = prefs.lengthBucket;
            if (isBucket(prefs.speedBucket)) state.speedBucket = prefs.speedBucket;
            if (isBucket(prefs.resolutionBucket)) state.resolutionBucket = prefs.resolutionBucket;

            // Migrate legacy min/max filters into bucket selections (best-effort).
            if (!state.lengthBucket) {
              const min = (typeof prefs.lenMinSec === 'number' && Number.isFinite(prefs.lenMinSec)) ? prefs.lenMinSec : 0;
              const max = (typeof prefs.lenMaxSec === 'number' && Number.isFinite(prefs.lenMaxSec)) ? prefs.lenMaxSec : 0;
              const guessFromMin = (m) => {
                if (m >= 1800) return 'veryLong';
                if (m >= 900) return 'long';
                if (m >= 300) return 'medium';
                if (m >= 120) return 'short';
                return 'veryShort';
              };
              const guessFromMax = (m) => {
                if (m <= 120) return 'veryShort';
                if (m <= 300) return 'short';
                if (m <= 900) return 'medium';
                if (m <= 1800) return 'long';
                return 'veryLong';
              };
              if (min > 0 && max > 0) {
                if (min >= 0 && max <= 120) state.lengthBucket = 'veryShort';
                else if (min >= 120 && max <= 300) state.lengthBucket = 'short';
                else if (min >= 300 && max <= 900) state.lengthBucket = 'medium';
                else if (min >= 900 && max <= 1800) state.lengthBucket = 'long';
                else if (min >= 1800) state.lengthBucket = 'veryLong';
              } else if (min > 0) {
                state.lengthBucket = guessFromMin(min);
              } else if (max > 0) {
                state.lengthBucket = guessFromMax(max);
              }
            }

            if (!state.speedBucket) {
              const min = (typeof prefs.speedMin === 'number' && Number.isFinite(prefs.speedMin)) ? prefs.speedMin : null;
              const max = (typeof prefs.speedMax === 'number' && Number.isFinite(prefs.speedMax)) ? prefs.speedMax : null;
              const guessFromMin = (m) => {
                if (m >= 10) return 'veryFast';
                if (m >= 5) return 'fast';
                if (m >= 2) return 'medium';
                if (m >= 1) return 'slow';
                return 'verySlow';
              };
              const guessFromMax = (m) => {
                if (m <= 1) return 'verySlow';
                if (m <= 2) return 'slow';
                if (m <= 5) return 'medium';
                if (m <= 10) return 'fast';
                return 'veryFast';
              };
              if (typeof min === 'number' && typeof max === 'number') {
                if (min >= 0 && max <= 1) state.speedBucket = 'verySlow';
                else if (min >= 1 && max <= 2) state.speedBucket = 'slow';
                else if (min >= 2 && max <= 5) state.speedBucket = 'medium';
                else if (min >= 5 && max <= 10) state.speedBucket = 'fast';
                else if (min >= 10) state.speedBucket = 'veryFast';
              } else if (typeof min === 'number') {
                state.speedBucket = guessFromMin(min);
              } else if (typeof max === 'number') {
                state.speedBucket = guessFromMax(max);
              }
            }

            if (!state.resolutionBucket) {
              const h = (typeof prefs.minHeight === 'number' && Number.isFinite(prefs.minHeight)) ? prefs.minHeight : 0;
              if (h >= 2160) state.resolutionBucket = 'veryHigh';
              else if (h >= 1440) state.resolutionBucket = 'high';
              else if (h >= 1080) state.resolutionBucket = 'medium';
              else if (h >= 720) state.resolutionBucket = 'low';
              else if (h >= 480) state.resolutionBucket = 'veryLow';
            }

            if (typeof prefs.scheduledPlaySpec === 'string') {
              const s = String(prefs.scheduledPlaySpec || '').trim();
              // Migrate legacy default that caused click-to-play to immediately pause.
              state.scheduledPlaySpec = s === '0.4' ? '' : s;
            }
          }
        } catch {
          // ignore parse errors
        }
      }

      function savePrefs() {
        try {
          window.localStorage.setItem('mvPrefs', JSON.stringify({
            pageSize: state.pageSize,
            gridMin: state.gridMin,
            sort: state.sort,
            lengthBucket: state.lengthBucket,
            speedBucket: state.speedBucket,
            resolutionBucket: state.resolutionBucket,
            scheduledPlaySpec: String(state.scheduledPlaySpec || '').trim(),
          }));
        } catch {
          // ignore storage errors
        }
      }

      function lengthBucketToRangeSec(bucket) {
        switch (String(bucket || '')) {
          case 'veryShort': return { min: 0, max: 120 };
          case 'short': return { min: 120, max: 300 };
          case 'medium': return { min: 300, max: 900 };
          case 'long': return { min: 900, max: 1800 };
          case 'veryLong': return { min: 1800, max: null };
          default: return { min: null, max: null };
        }
      }

      function speedBucketToRange(bucket) {
        switch (String(bucket || '')) {
          case 'verySlow': return { min: 0, max: 1 };
          case 'slow': return { min: 1, max: 2 };
          case 'medium': return { min: 2, max: 5 };
          case 'fast': return { min: 5, max: 10 };
          case 'veryFast': return { min: 10, max: null };
          default: return { min: null, max: null };
        }
      }

      function resolutionBucketToMinDims(bucket) {
        // Use minHeight/minWidth as a proxy for resolution buckets.
        switch (String(bucket || '')) {
          case 'veryLow': return { minHeight: 480, minWidth: 854 };
          case 'low': return { minHeight: 720, minWidth: 1280 };
          case 'medium': return { minHeight: 1080, minWidth: 1920 };
          case 'high': return { minHeight: 1440, minWidth: 2560 };
          case 'veryHigh': return { minHeight: 2160, minWidth: 3840 };
          default: return { minHeight: null, minWidth: null };
        }
      }

      function wsUrlFromHttp(base) {
        const u = new URL(base);
        u.protocol = u.protocol === 'https:' ? 'wss:' : 'ws:';
        u.pathname = '/ws';
        u.search = '';
        u.hash = '';
        return u.toString();
      }

      function connectWs() {
        ensureClientId();
        if (state.ws && (state.ws.readyState === 0 || state.ws.readyState === 1)) return;

        const wsUrl = wsUrlFromHttp(window.location.origin);
        const ws = new WebSocket(wsUrl);
        state.ws = ws;

        ws.addEventListener('open', () => {
          state.wsConnected = true;
          ws.send(JSON.stringify({ type: 'sync:hello', clientId: state.clientId, sessionId: state.wsSessionId }));
          // Let other clients know whether we're currently in grid/player/vr.
          sendClientStatus();
          updateSyncStatus();
        });

        ws.addEventListener('close', () => {
          state.wsConnected = false;
          updateSyncStatus();
          window.setTimeout(() => connectWs(), 1000);
        });

        ws.addEventListener('message', (evt) => {
          let msg;
          try { msg = JSON.parse(String(evt.data)); } catch { return; }
          if (!msg || msg.type !== 'sync:state' || !msg.state) return;
          if (msg.clients && Array.isArray(msg.clients)) {
            state.clients = msg.clients;
          }
          applyRemoteSyncState(msg.state);
        });
      }

      function sendSyncUpdate(update, force, toClientId = null) {
        if (!state.wsConnected || !state.ws || state.ws.readyState !== 1) return;
        if (!force && Date.now() < state._applyingRemoteUntil) return;
        const now = Date.now();
        if (!force && now - state._lastSentAt < 200) return;
        state._lastSentAt = now;

        const payload = {
          type: 'sync:update',
          sessionId: state.wsSessionId,
          clientId: state.clientId,
          ...update,
        };
        const target = typeof toClientId === 'string' ? toClientId.trim() : '';
        if (target) payload.toClientId = target;
        state.ws.send(JSON.stringify(payload));
      }

      function scheduleLocalPlayAt(v, playAtLocalMs) {
        if (!(v instanceof HTMLVideoElement)) return;
        const when = Number(playAtLocalMs) || 0;
        if (!Number.isFinite(when) || when <= 0) return;
        if (Math.abs((Number(state._scheduledPlayAtLocalMs) || 0) - when) < 10) return;

        // Replace any prior scheduled play.
        if (state._scheduledPlayTimerId) {
          try { window.clearTimeout(state._scheduledPlayTimerId); } catch {}
          state._scheduledPlayTimerId = 0;
        }

        state._scheduledPlayAtLocalMs = when;
        const delayMs = Math.max(0, Math.round(when - Date.now()));
        state._applyingRemoteUntil = Math.max(state._applyingRemoteUntil, when + 1000);

        // Prevent programmatic pause/play from emitting local forced sync events.
        suppressLocalVideoEventsUntil(when + 1200);

        try { v.pause(); } catch {}
        state._scheduledPlayTimerId = window.setTimeout(() => {
          if (Number(state._scheduledPlayAtLocalMs) !== when) return;
          try { v.play(); } catch {}
        }, delayMs);
      }

      function cancelScheduledPlay() {
        if (state._scheduledPlayTimerId) {
          try { window.clearTimeout(state._scheduledPlayTimerId); } catch {}
          state._scheduledPlayTimerId = 0;
        }
        state._scheduledPlayAtLocalMs = 0;
      }

      function parseScheduledPlaySpec(spec, clockOffsetMs) {
        const s = String(spec ?? '').trim();
        if (!s) return null;
        if (s.toLowerCase() === 'off' || s.toLowerCase() === 'none' || s === '0') return null;

        const offset = Number(clockOffsetMs) || 0;

        // Relative seconds (e.g. "0.4" or "5")
        if (/^\+?\d+(?:\.\d+)?$/.test(s)) {
          const sec = Number(s);
          if (!Number.isFinite(sec) || sec <= 0) return null;
          const playAtLocalMs = Date.now() + Math.round(sec * 1000);
          const playAtServerMs = playAtLocalMs - offset;
          return { playAt: new Date(playAtServerMs).toISOString(), playAtLocalMs };
        }

        // Fixed local time-of-day (HH:MM[:SS])
        const m = /^(\d{1,2}):(\d{2})(?::(\d{2}))?$/.exec(s);
        if (m) {
          const hh = Math.max(0, Math.min(23, Number(m[1])));
          const mm = Math.max(0, Math.min(59, Number(m[2])));
          const ss = Math.max(0, Math.min(59, Number(m[3] ?? 0)));
          const now = new Date();
          const target = new Date(now);
          target.setHours(hh, mm, ss, 0);
          if (target.getTime() <= now.getTime() + 50) target.setDate(target.getDate() + 1);
          const playAtLocalMs = target.getTime();
          const playAtServerMs = playAtLocalMs - offset;
          return { playAt: new Date(playAtServerMs).toISOString(), playAtLocalMs };
        }

        // Fixed absolute date/time (ISO or anything Date.parse accepts)
        const parsed = Date.parse(s);
        if (!Number.isNaN(parsed)) {
          const playAtLocalMs = parsed;
          if (!Number.isFinite(playAtLocalMs) || playAtLocalMs <= Date.now() + 50) return null;
          const playAtServerMs = playAtLocalMs - offset;
          return { playAt: new Date(playAtServerMs).toISOString(), playAtLocalMs };
        }

        return null;
      }

      async function getItemInfo(id) {
        const found = state.items.find((x) => x.id === id);
        if (found) return found;
        try {
          const info = await apiJson(`/api/media/${id}/fileinfo`);
          return {
            id: info.id,
            filename: info.filename,
            relPath: info.relPath,
            mediaType: info.mediaType,
            hasFunscript: info.hasFunscript,
            isVr: info.isVr,
            title: info.title,
            durationMs: info.durationMs,
            width: info.width,
            height: info.height,
            funscriptActionCount: info.funscriptActionCount,
            funscriptAvgSpeed: info.funscriptAvgSpeed,
          };
        } catch {
          return { id, filename: '', relPath: '', mediaType: 'video', hasFunscript: false, isVr: false };
        }
      }

      async function applyRemoteSyncState(remote) {
        if (!remote) return;
        if (remote.fromClientId && remote.fromClientId === state.clientId) return;

        // If the origin client isn't currently connected, treat the message as stale.
        // This prevents old session state from overriding a local click-to-open.
        // NOTE: VR integrations (HereSphere/DeoVR) are not WS clients, so allow `vr:*` sources.
        if (remote.fromClientId && !String(remote.fromClientId).startsWith('vr:') && !isClientIdConnected(remote.fromClientId)) return;

        // Seek-sync: leader receives peer ready ACKs.
        if (remote.seekToken && String(remote.seekPhase) === 'ready') {
          const pending = state._pendingSeekSync;
          if (pending && pending.token === remote.seekToken && String(remote.fromClientId || '') === String(pending.peerId || '')) {
            pending.peerReady = true;
          }
          return;
        }

        const prevRemote = state.lastRemoteSync;
        state.lastRemoteSync = remote;
        state.lastRemoteAt = Date.now();
        updateSyncStatus();

        // Do not auto-navigate away from the grid when opening the WebUI,
        // unless an explicit open request is sent (e.g., from Desktop Sync ON).
        if (state.view === 'grid' && !remote.openInUi) return;

        if (!remote.mediaId) return;

        const id = String(remote.mediaId);
        const item = await getItemInfo(id);

        // If different media, follow it (only while already in a player view).
        if (state.current?.id !== id) {
          state._applyingRemoteUntil = Date.now() + 800;
          if (item?.isVr) {
            // For integrated WebVR support.
            setView('vr', { id, item });
          } else {
            setView('player', { id, item });
          }
          // Wait a tick for DOM.
          await new Promise((r) => setTimeout(r, 0));
        }

        const v = document.getElementById('v') || document.getElementById('vvr');
        if (!(v instanceof HTMLVideoElement)) return;

        // Seek-sync: respond to seek requests by pausing, seeking, buffering, then ACK ready.
        if (remote.seekToken && String(remote.seekPhase) === 'request') {
          const target = String(remote.seekTargetClientId || '');
          if (target && target !== state.clientId) return;

          const seekMs = Math.max(0, Math.round(Number(remote.timeMs) || 0));
          suppressLocalVideoEventsUntil(Date.now() + 7000);
          try { v.pause(); } catch {}
          try { v.currentTime = seekMs / 1000; } catch {}
          await waitForVideoReadyAt(v, seekMs / 1000, 6000);

          sendSyncUpdate({
            mediaId: String(remote.mediaId || ''),
            timeMs: seekMs,
            paused: true,
            fps: 30,
            frame: Math.max(0, Math.floor((seekMs / 1000) * 30)),
            seekToken: String(remote.seekToken),
            seekPhase: 'ready',
            seekWantPlay: Boolean(remote.seekWantPlay),
            seekTargetClientId: String(remote.fromClientId || ''),
          }, true, String(remote.fromClientId || '') || null);
          return;
        }

        // If the user is actively scrubbing/seeking locally, don't fight their interaction.
        if (v.seeking) return;

        const now = Date.now();
        state._applyingRemoteUntil = now + 800;

        const prevTimeMs = prevRemote ? Math.max(0, Number(prevRemote.timeMs) || 0) : 0;

        const remoteTimeMs = Math.max(0, Math.round(Number(remote.timeMs) || 0));
        let updatedAtMs = null;
        if (remote.updatedAt) {
          const parsed = Date.parse(String(remote.updatedAt));
          if (!Number.isNaN(parsed)) updatedAtMs = parsed;
        }

        if (updatedAtMs !== null) {
          const observedOffset = now - updatedAtMs;
          if (typeof state.remoteServerClockOffsetMs !== 'number' || !Number.isFinite(state.remoteServerClockOffsetMs)) {
            state.remoteServerClockOffsetMs = observedOffset;
          } else {
            state.remoteServerClockOffsetMs = state.remoteServerClockOffsetMs * 0.9 + observedOffset * 0.1;
          }
        }

        const clockOffset = typeof state.remoteServerClockOffsetMs === 'number' && Number.isFinite(state.remoteServerClockOffsetMs)
          ? state.remoteServerClockOffsetMs
          : 0;
        const baselineRemoteNow = updatedAtMs !== null ? updatedAtMs + clockOffset : now;
        const paused = Boolean(remote.paused);

        let playAtLocalMs = null;
        if (!paused && remote.playAt) {
          const t = Date.parse(String(remote.playAt));
          if (!Number.isNaN(t)) playAtLocalMs = t + clockOffset;
        }

        const treatAsPaused = (playAtLocalMs != null && playAtLocalMs > now + 10) ? true : paused;
        const driftMs = treatAsPaused ? 0 : Math.max(0, now - baselineRemoteNow);
        const projectedTimeMs = remoteTimeMs + driftMs;

        state.remoteProjectedTimeMs = projectedTimeMs;
        state.remoteProjectedAtMs = now;

        const targetTime = projectedTimeMs / 1000;
        const currentTime = Number.isFinite(v.currentTime) ? v.currentTime : NaN;
        const remoteJumpedBack = remoteTimeMs < prevTimeMs - 100;
        const remoteJumpedForward = remoteTimeMs - prevTimeMs > 2000;
        const remoteJumped = remoteJumpedBack || remoteJumpedForward;
        if (!Number.isFinite(currentTime) || remoteJumped || Math.abs(currentTime - targetTime) > 0.75) {
          // Avoid echoing a remote-applied seek back as a forced local update.
          suppressLocalVideoEventsUntil(Date.now() + 1200);
          try { v.currentTime = targetTime; } catch {}
        }

        if (treatAsPaused) {
          // Avoid echoing a remote-applied pause back.
          suppressLocalVideoEventsUntil(Date.now() + 1200);
          try { v.pause(); } catch {}
          if (playAtLocalMs != null && playAtLocalMs > now + 10) {
            // Ensure exact start position at playAt.
            const startTimeSeconds = (remoteTimeMs + Math.max(0, playAtLocalMs - baselineRemoteNow)) / 1000;
            suppressLocalVideoEventsUntil(Date.now() + 1200);
            try { v.currentTime = startTimeSeconds; } catch {}
            scheduleLocalPlayAt(v, playAtLocalMs);
          } else {
            cancelScheduledPlay();
          }
        } else {
          cancelScheduledPlay();
          // Avoid echoing a remote-applied play back.
          suppressLocalVideoEventsUntil(Date.now() + 1200);
          try { await v.play(); } catch {}
        }
      }

      function formatPageLabel() {
        const maxPage = Math.max(1, Math.ceil(state.total / state.pageSize));
        return `Page ${state.page} / ${maxPage} (${state.total} items)`;
      }
      function generatePageButtons() {
        const maxPage = Math.max(1, Math.ceil(state.total / state.pageSize));
        const current = state.page;
        const buttons = [];
        
        // Calculate which page numbers to show (up to 5)
        let startPage = Math.max(1, current - 2);
        let endPage = Math.min(maxPage, startPage + 4);
        
        // Adjust if we're near the end
        if (endPage - startPage < 4) {
          startPage = Math.max(1, endPage - 4);
        }
        
        for (let i = startPage; i <= endPage; i++) {
          const active = i === current ? ' active' : '';
          buttons.push(`<button class="btn page-btn${active}" data-page="${i}">${i}</button>`);
        }
        
        return buttons.join('');
      }
      function thumbKey(id) {
        return `mvThumb:${id}`;
      }

      function getThumbDataUrl(id) {
        if (state.thumbCache[id]) return state.thumbCache[id];
        try {
          const v = window.sessionStorage.getItem(thumbKey(id));
          if (v) {
            state.thumbCache[id] = v;
            return v;
          }
        } catch {}
        return null;
      }

      function setThumbDataUrl(id, dataUrl) {
        state.thumbCache[id] = dataUrl;
        try {
          window.sessionStorage.setItem(thumbKey(id), dataUrl);
        } catch {}
      }

      async function loadList() {
        const params = new URLSearchParams();
        params.set('q', state.q);
        params.set('page', String(state.page));
        params.set('pageSize', String(state.pageSize));
        params.set('mediaType', 'video');
        if (state.funFilter === 'with') params.set('hasFunscript', '1');
        if (state.funFilter === 'without') params.set('hasFunscript', '0');
        if (state.vrFilter === 'vr') params.set('isVr', '1');
        if (state.vrFilter === 'nonvr') params.set('isVr', '0');

        const lenRange = lengthBucketToRangeSec(state.lengthBucket);
        if (typeof lenRange.min === 'number' && Number.isFinite(lenRange.min) && lenRange.min > 0) {
          params.set('minDurationSec', String(lenRange.min));
        }
        if (typeof lenRange.max === 'number' && Number.isFinite(lenRange.max) && lenRange.max > 0) {
          params.set('maxDurationSec', String(lenRange.max));
        }

        const speedRange = speedBucketToRange(state.speedBucket);
        if (typeof speedRange.min === 'number' && Number.isFinite(speedRange.min)) params.set('minSpeed', String(speedRange.min));
        if (typeof speedRange.max === 'number' && Number.isFinite(speedRange.max)) params.set('maxSpeed', String(speedRange.max));

        const dims = resolutionBucketToMinDims(state.resolutionBucket);
        if (typeof dims.minHeight === 'number' && Number.isFinite(dims.minHeight) && dims.minHeight > 0) params.set('minHeight', String(dims.minHeight));
        if (typeof dims.minWidth === 'number' && Number.isFinite(dims.minWidth) && dims.minWidth > 0) params.set('minWidth', String(dims.minWidth));

        const sort = String(state.sort || 'newest');
        const setSort = (sortBy, sortDir) => {
          params.set('sortBy', sortBy);
          params.set('sortDir', sortDir);
        };
        switch (sort) {
          case 'oldest': setSort('modified', 'asc'); break;
          case 'titleAsc': setSort('title', 'asc'); break;
          case 'titleDesc': setSort('title', 'desc'); break;
          case 'lenAsc': setSort('duration', 'asc'); break;
          case 'lenDesc': setSort('duration', 'desc'); break;
          case 'speedAsc': setSort('speed', 'asc'); break;
          case 'speedDesc': setSort('speed', 'desc'); break;
          case 'resAsc': setSort('resolution', 'asc'); break;
          case 'resDesc': setSort('resolution', 'desc'); break;
          case 'newest':
          default:
            setSort('modified', 'desc');
            break;
        }

        const data = await apiJson(`/api/media?${params.toString()}`);
        state.total = data.total;
        state.items = data.items;
      }

      async function doSearch(value) {
        state.q = value;
        state.page = 1;
        await loadList();
        render();
      }

      function formatDuration(seconds) {
        if (!Number.isFinite(seconds) || seconds <= 0) return '--:--';
        const total = Math.round(seconds);
        const h = Math.floor(total / 3600);
        const m = Math.floor((total % 3600) / 60);
        const s = total % 60;
        if (h > 0) return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        return `${m}:${String(s).padStart(2, '0')}`;
      }

      function formatBytes(bytes) {
        const b = Number(bytes);
        if (!Number.isFinite(b) || b < 0) return '--';
        const units = ['B', 'KB', 'MB', 'GB', 'TB'];
        let n = b;
        let u = 0;
        while (n >= 1024 && u < units.length - 1) {
          n /= 1024;
          u++;
        }
        const digits = u === 0 ? 0 : (n >= 10 ? 1 : 2);
        return `${n.toFixed(digits)} ${units[u]}`;
      }

      function formatDateTime(ms) {
        const t = Number(ms);
        if (!Number.isFinite(t) || t <= 0) return '--';
        try {
          return new Date(t).toLocaleString();
        } catch {
          return '--';
        }
      }

      function formatFunscriptStats(actionCount, avgSpeed) {
        const cnt = Number(actionCount);
        const sp = Number(avgSpeed);
        if (!Number.isFinite(cnt) || cnt <= 0) return 'None';
        if (Number.isFinite(sp) && sp >= 0) {
          const spTxt = sp.toFixed(sp >= 10 ? 0 : 1);
          return `${Math.round(cnt)} actions · ${spTxt}%/s`;
        }
        return `${Math.round(cnt)} actions`;
      }

      function computeFunscriptStatsFromActions(actions) {
        if (!Array.isArray(actions) || actions.length === 0) return null;
        let totalAbsDeltaPos = 0;
        let totalDtMs = 0;
        for (let i = 1; i < actions.length; i++) {
          const a0 = actions[i - 1];
          const a1 = actions[i];
          const t0 = Number(a0?.at);
          const t1 = Number(a1?.at);
          const p0 = Number(a0?.pos);
          const p1 = Number(a1?.pos);
          if (!Number.isFinite(t0) || !Number.isFinite(t1) || !Number.isFinite(p0) || !Number.isFinite(p1)) continue;
          const dt = t1 - t0;
          if (!(dt > 0)) continue;
          totalDtMs += dt;
          totalAbsDeltaPos += Math.abs(p1 - p0);
        }
        const avgSpeed = totalDtMs > 0 ? (totalAbsDeltaPos / totalDtMs) * 1000 : 0;
        return { actionCount: actions.length, avgSpeed };
      }

      function updateSyncStatus() {
        const elSync = document.getElementById('syncStatus');
        if (!elSync) return;

        const parts = [];
        parts.push(state.wsConnected ? 'Sync: connected' : 'Sync: disconnected');
        parts.push(`session: ${state.wsSessionId || 'default'}`);

        if (state.lastRemoteSync && state.lastRemoteAt) {
          const ageMs = Math.max(0, Date.now() - state.lastRemoteAt);
          const from = state.lastRemoteSync.fromClientId ? `from ${state.lastRemoteSync.fromClientId}` : 'from remote';
          const paused = Boolean(state.lastRemoteSync.paused);
          const at = formatDuration((Number(state.lastRemoteSync.timeMs) || 0) / 1000);
          parts.push(`${from} · ${paused ? 'paused' : 'playing'} · ${at} · ${Math.round(ageMs / 1000)}s ago`);
        }

        elSync.textContent = parts.join(' · ');
      }

      function getDurationSec(id) {
        const fromCache = state.durationsSec[id];
        if (Number.isFinite(fromCache)) return fromCache;
        const it = state.items.find((x) => x.id === id);
        const ms = it && typeof it.durationMs === 'number' && Number.isFinite(it.durationMs) ? it.durationMs : null;
        return ms && ms > 0 ? ms / 1000 : null;
      }

      function getGridItems() {
        return [...state.items];
      }

      function card(item) {
        const tagF = item.hasFunscript
          ? `<span class="tag tag--good">funscript</span>`
          : `<span class="tag tag--bad">no funscript</span>`;
        const tagT = `<span class="tag">${item.mediaType}</span>`;
        const tagVr = item.isVr
          ? `<span class="tag tag--vr">vr</span>`
          : '';

        const durationTag = item.mediaType === 'video'
          ? `<span class="tag mvLen" data-id="${item.id}">${formatDuration(getDurationSec(item.id) ?? NaN)}</span>`
          : '';

        const resTag = item.mediaType === 'video'
          ? (() => {
              const w = Number(item.width);
              const h = Number(item.height);
              if (Number.isFinite(w) && Number.isFinite(h) && w > 0 && h > 0) {
                return `<span class="tag mvRes" data-id="${escapeHtml(item.id)}">${Math.round(w)}x${Math.round(h)}</span>`;
              }
              return `<span class="tag mvRes" data-id="${escapeHtml(item.id)}">?x?</span>`;
            })()
          : '';

        const fsSpeedTag = item.hasFunscript
          ? (() => {
              const sp = Number(item.funscriptAvgSpeed);
              if (!Number.isFinite(sp) || sp < 0) return `<span class="tag mvFsSpeed" data-id="${escapeHtml(item.id)}">?%/s</span>`;
              return `<span class="tag mvFsSpeed" data-id="${escapeHtml(item.id)}">${sp.toFixed(sp >= 10 ? 0 : 1)}%/s</span>`;
            })()
          : '';

        const fsStats = item.hasFunscript
          ? (() => {
              const cnt = Number(item.funscriptActionCount);
              if (!Number.isFinite(cnt) || cnt <= 0) return `<span class="tag mvFsCnt" data-id="${escapeHtml(item.id)}">? actions</span>`;
              return `<span class="tag mvFsCnt" data-id="${escapeHtml(item.id)}">${Math.round(cnt)} actions</span>`;
            })()
          : '';

        // Use server-side generated thumbnail for video.
        const thumbUrl = item.mediaType === 'image' 
          ? `/api/media/${item.id}/stream`
          : `/api/media/${item.id}/thumb?v=${state.thumbVer}`;

        const placeholderImg = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';

        // For videos, defer requesting thumbs until the card is near-visible.
        // This prevents large bursts of thumbnail generation from blocking other API calls.
        const thumb = item.mediaType === 'video'
          ? `<img class="thumbMedia" loading="lazy" src="${placeholderImg}" data-src="${thumbUrl}" alt="${escapeHtml(item.filename)}" />`
          : `<img class="thumbMedia" loading="lazy" src="${thumbUrl}" alt="${escapeHtml(item.filename)}" />`;

        const thumbStatus = `<div class="thumbStatus">Loading…</div>`;

        return `
          <div class="card" role="button" tabindex="0" data-open-id="${escapeHtml(item.id)}" aria-label="Open: ${escapeHtml(item.filename)}">
            <div class="thumb">
              ${thumb}
              ${thumbStatus}
            </div>
            <div class="meta">
              <div class="name">${escapeHtml(item.filename)}</div>
              <div class="tags">${tagT}${tagVr}${durationTag}${resTag}<span class="tagBreak"></span>${tagF}${fsSpeedTag}${fsStats}</div>
            </div>
          </div>
        `;
      }

      function escapeHtml(s) {
        return String(s)
          .replaceAll('&', '&amp;')
          .replaceAll('<', '&lt;')
          .replaceAll('>', '&gt;')
          .replaceAll('"', '&quot;')
          .replaceAll("'", '&#039;');
      }

      async function openById(id) {
        const item = state.items.find((x) => x.id === id) || (await apiJson(`/api/media/${id}/fileinfo`).then(() => ({ id })));
        setView('player', { id, item });
      }

      function renderGrid() {
        const active = document.activeElement;
        const shouldRestoreQ = (active instanceof HTMLInputElement) && active.id === 'q';
        const restoreStart = shouldRestoreQ ? active.selectionStart : null;
        const restoreEnd = shouldRestoreQ ? active.selectionEnd : null;

        const visible = getGridItems();
        el('app').innerHTML = `
          <header>
            <h1>MediaViewer</h1>
            <div class="search"><input id="q" placeholder="Search by filename or title" value="${escapeHtml(state.q)}" /></div>
            <select id="pageSize" title="Items per page">
              ${[12, 24, 48, 96].map((n) => `<option value="${n}" ${n === state.pageSize ? 'selected' : ''}>${n}/page</option>`).join('')}
            </select>
            <select id="funFilter" title="Funscript filter">
              <option value="all" ${state.funFilter === 'all' ? 'selected' : ''}>All videos</option>
              <option value="with" ${state.funFilter === 'with' ? 'selected' : ''}>With funscript</option>
              <option value="without" ${state.funFilter === 'without' ? 'selected' : ''}>Without funscript</option>
            </select>
            <select id="vrFilter" title="VR filter">
              <option value="all" ${state.vrFilter === 'all' ? 'selected' : ''}>All</option>
              <option value="vr" ${state.vrFilter === 'vr' ? 'selected' : ''}>VR only</option>
              <option value="nonvr" ${state.vrFilter === 'nonvr' ? 'selected' : ''}>Non-VR only</option>
            </select>
            <select id="sort" title="Sort">
              <option value="newest" ${state.sort === 'newest' ? 'selected' : ''}>Newest</option>
              <option value="oldest" ${state.sort === 'oldest' ? 'selected' : ''}>Oldest</option>
              <option value="titleAsc" ${state.sort === 'titleAsc' ? 'selected' : ''}>Title (A → Z)</option>
              <option value="titleDesc" ${state.sort === 'titleDesc' ? 'selected' : ''}>Title (Z → A)</option>
              <option value="lenAsc" ${state.sort === 'lenAsc' ? 'selected' : ''}>Length (short → long)</option>
              <option value="lenDesc" ${state.sort === 'lenDesc' ? 'selected' : ''}>Length (long → short)</option>
              <option value="speedAsc" ${state.sort === 'speedAsc' ? 'selected' : ''}>Speed (slow → fast)</option>
              <option value="speedDesc" ${state.sort === 'speedDesc' ? 'selected' : ''}>Speed (fast → slow)</option>
              <option value="resAsc" ${state.sort === 'resAsc' ? 'selected' : ''}>Resolution (low → high)</option>
              <option value="resDesc" ${state.sort === 'resDesc' ? 'selected' : ''}>Resolution (high → low)</option>
            </select>
            <select id="lengthBucket" title="Length">
              <option value="" ${state.lengthBucket === '' ? 'selected' : ''}>Any length</option>
              <option value="veryShort" ${state.lengthBucket === 'veryShort' ? 'selected' : ''}>Very Short</option>
              <option value="short" ${state.lengthBucket === 'short' ? 'selected' : ''}>Short</option>
              <option value="medium" ${state.lengthBucket === 'medium' ? 'selected' : ''}>Medium</option>
              <option value="long" ${state.lengthBucket === 'long' ? 'selected' : ''}>Long</option>
              <option value="veryLong" ${state.lengthBucket === 'veryLong' ? 'selected' : ''}>Very Long</option>
            </select>
            <select id="speedBucket" title="Speed">
              <option value="" ${state.speedBucket === '' ? 'selected' : ''}>Any speed</option>
              <option value="verySlow" ${state.speedBucket === 'verySlow' ? 'selected' : ''}>Very Slow</option>
              <option value="slow" ${state.speedBucket === 'slow' ? 'selected' : ''}>Slow</option>
              <option value="medium" ${state.speedBucket === 'medium' ? 'selected' : ''}>Medium</option>
              <option value="fast" ${state.speedBucket === 'fast' ? 'selected' : ''}>Fast</option>
              <option value="veryFast" ${state.speedBucket === 'veryFast' ? 'selected' : ''}>Very Fast</option>
            </select>
            <select id="resolutionBucket" title="Resolution">
              <option value="" ${state.resolutionBucket === '' ? 'selected' : ''}>Any res</option>
              <option value="veryLow" ${state.resolutionBucket === 'veryLow' ? 'selected' : ''}>Very Low</option>
              <option value="low" ${state.resolutionBucket === 'low' ? 'selected' : ''}>Low</option>
              <option value="medium" ${state.resolutionBucket === 'medium' ? 'selected' : ''}>Medium</option>
              <option value="high" ${state.resolutionBucket === 'high' ? 'selected' : ''}>High</option>
              <option value="veryHigh" ${state.resolutionBucket === 'veryHigh' ? 'selected' : ''}>Very High</option>
            </select>
            <button class="btn" id="gridDec" title="Smaller grid">-</button>
            <button class="btn" id="gridInc" title="Larger grid">+</button>
            <button class="btn" id="scan">Rescan</button>
            <button class="btn" id="regenThumbs" title="Clear server thumbnail cache and refresh">Regenerate thumbs</button>
            <div class="opStatus" id="opStatus" style="display:none">
              <progress id="opProgress"></progress>
              <span class="small" id="opText"></span>
            </div>
          </header>
          <main>
            <div class="small">${formatPageLabel()}</div>
            <div class="grid" id="grid">${visible.map(card).join('')}</div>
            <div class="pager">
              <button class="btn" id="first">First</button>
              <button class="btn" id="prev">Prev</button>
              <div class="page-numbers" id="pageNumbers">${generatePageButtons()}</div>
              <button class="btn" id="next">Next</button>
              <button class="btn" id="last">Last</button>
            </div>
          </main>
        `;

        el('grid').style.setProperty('--card-min', `${state.gridMin}px`);

        el('q').addEventListener('input', (e) => {
          const val = e.target.value;
          window.clearTimeout(window.__qT);
          window.__qT = window.setTimeout(() => doSearch(val), 200);
        });

        el('pageSize').addEventListener('change', async (e) => {
          state.pageSize = Number(e.target.value) || 48;
          state.page = 1;
          savePrefs();
          await loadList();
          render();
        });

        el('funFilter').addEventListener('change', async (e) => {
          state.funFilter = e.target.value;
          state.page = 1;
          await loadList();
          render();
        });

        el('vrFilter').addEventListener('change', async (e) => {
          state.vrFilter = e.target.value;
          state.page = 1;
          await loadList();
          render();
        });

        el('sort').addEventListener('change', async (e) => {
          state.sort = e.target.value;
          state.page = 1;
          savePrefs();
          await loadList();
          render();
        });

        el('lengthBucket').addEventListener('change', async (e) => {
          state.lengthBucket = String(e.target.value || '');
          state.page = 1;
          savePrefs();
          await loadList();
          render();
        });

        el('speedBucket').addEventListener('change', async (e) => {
          state.speedBucket = String(e.target.value || '');
          state.page = 1;
          savePrefs();
          await loadList();
          render();
        });

        el('resolutionBucket').addEventListener('change', async (e) => {
          state.resolutionBucket = String(e.target.value || '');
          state.page = 1;
          savePrefs();
          await loadList();
          render();
        });

        function isAllowedGridColumnCount(n) {
          if (!Number.isFinite(n)) return false;
          const k = Math.max(1, Math.round(n));
          if (k === 1 || k === 2 || k === 3) return true;
          return (k % 4 === 0) || (k % 6 === 0);
        }

        function getGridColumnCount() {
          const grid = el('grid');
          if (!grid) return 1;
          // Count actual columns by measuring the first row.
          // This is more reliable than parsing gridTemplateColumns, which can be a `repeat(...)`
          // expression in some embedded browsers.
          const kids = Array.from(grid.children || []).filter((n) => n && n.nodeType === 1);
          if (kids.length === 0) return 1;
          const first = kids[0];
          const top = first.offsetTop;
          let count = 0;
          for (const node of kids) {
            if (node.offsetTop !== top) break;
            count++;
            if (count > 200) break;
          }
          return Math.max(1, count || 1);
        }

        function setGridMinPx(px) {
          state.gridMin = Math.max(120, Math.min(360, Math.round(px)));
          el('grid').style.setProperty('--card-min', `${state.gridMin}px`);
          savePrefs();
        }

        function setGridMinPxNoPersist(px) {
          state.gridMin = Math.max(120, Math.min(360, Math.round(px)));
          el('grid').style.setProperty('--card-min', `${state.gridMin}px`);
        }

        function snapGridToAllowedColumnCount() {
          const grid = el('grid');
          if (!grid) return;

          const w = grid.getBoundingClientRect().width;
          if (!(w > 0)) return;

          const gap = 12;
          const currentCols = getGridColumnCount();
          if (isAllowedGridColumnCount(currentCols)) return;

          let targetCols = currentCols;
          for (let d = 1; d < 50; d++) {
            const down = currentCols - d;
            const up = currentCols + d;
            if (down >= 1 && isAllowedGridColumnCount(down)) { targetCols = down; break; }
            if (isAllowedGridColumnCount(up)) { targetCols = up; break; }
          }

          // Compute a card-min that guarantees targetCols fits, and targetCols+1 does not.
          // For CSS grid: cols * cardMin + (cols-1)*gap <= w
          const raw = Math.floor((w - gap * (targetCols - 1)) / targetCols);
          let nextMin = Math.max(120, Math.min(360, raw + 1));

          // Apply + verify, then nudge if needed (without saving prefs).
          for (let nudge = 0; nudge < 60; nudge++) {
            setGridMinPxNoPersist(nextMin);
            const cols = getGridColumnCount();
            if (isAllowedGridColumnCount(cols)) return;
            // If we got too many columns, increase min; else decrease min.
            nextMin += (cols > targetCols) ? 2 : -2;
            if (nextMin <= 120 || nextMin >= 360) {
              setGridMinPxNoPersist(nextMin);
              return;
            }
          }
        }

        function stepGridToAllowed(direction) {
          // direction: -1 => smaller cards (more columns), +1 => larger cards (fewer columns)
          const grid = el('grid');
          if (!grid) return;
          const w = grid.getBoundingClientRect().width;
          const gap = 12;
          const currentCols = getGridColumnCount();

          let targetCols = currentCols;
          for (let i = 0; i < 50; i++) {
            targetCols = direction < 0 ? (targetCols + 1) : (targetCols - 1);
            if (targetCols < 1) { targetCols = 1; break; }
            if (isAllowedGridColumnCount(targetCols)) break;
          }

          // Compute a card-min that guarantees targetCols.
          // For CSS grid: cols * cardMin + (cols-1)*gap <= w
          const raw = Math.floor((w - gap * (targetCols - 1)) / targetCols);
          let nextMin = Math.max(120, Math.min(360, raw + 1));

          // Nudge to hit an allowed column count exactly.
          for (let nudge = 0; nudge < 40; nudge++) {
            setGridMinPx(nextMin);
            const cols = getGridColumnCount();
            if (isAllowedGridColumnCount(cols)) return;
            // If we got too many columns, increase min; else decrease min.
            nextMin += (cols > targetCols) ? 2 : -2;
            if (nextMin <= 120 || nextMin >= 360) {
              setGridMinPx(nextMin);
              return;
            }
          }
        }

        el('gridDec').addEventListener('click', () => stepGridToAllowed(-1));
        el('gridInc').addEventListener('click', () => stepGridToAllowed(+1));

        // When resizing the window, snap the grid to allowed column counts only.
        // Debounced to avoid thrashing while dragging the window edge.
        window.__mvGridResizeHandler = window.__mvGridResizeHandler || (() => {
          window.clearTimeout(window.__mvGridResizeT);
          window.__mvGridResizeT = window.setTimeout(() => {
            if (state.view === 'grid') snapGridToAllowedColumnCount();
          }, 120);
        });
        try { window.removeEventListener('resize', window.__mvGridResizeHandler); } catch {}
        window.addEventListener('resize', window.__mvGridResizeHandler);

        // Also ensure current size is snapped (covers initial render + page changes).
        snapGridToAllowedColumnCount();

        const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

        function opShow(text, mode) {
          const wrap = document.getElementById('opStatus');
          const prog = document.getElementById('opProgress');
          const t = document.getElementById('opText');
          if (!wrap || !prog || !t) return;

          wrap.style.display = 'flex';
          t.textContent = text || '';

          // mode: 'indeterminate' | { value, max }
          if (mode && typeof mode === 'object') {
            prog.max = Number(mode.max) || 1;
            prog.value = Number(mode.value) || 0;
          } else {
            prog.removeAttribute('value');
          }
        }

        function opHide() {
          const wrap = document.getElementById('opStatus');
          if (!wrap) return;
          wrap.style.display = 'none';
        }

        async function waitForScanCompletion() {
          // Poll server progress until scan completes.
          for (;;) {
            let p = null;
            try {
              p = await apiJson('/api/scan/progress');
            } catch (e) {
              const msg = (e && e.message) ? e.message : String(e);
              opShow(`Scan status unavailable: ${msg}`, { value: 1, max: 1 });
              await sleep(1200);
              opHide();
              return;
            }

            if (p && p.isScanning) {
              const msg = p.message || 'Scanning...';
              const scanned = typeof p.scanned === 'number' ? p.scanned : 0;
              opShow(`${msg} (${scanned} files)`, 'indeterminate');
              await sleep(500);
              continue;
            }

            const doneMsg = (p && p.message) ? p.message : 'Scan complete';
            opShow(doneMsg, { value: 1, max: 1 });
            await sleep(800);
            opHide();
            return;
          }
        }

        async function resumeScanIfNeeded() {
          try {
            const p = await apiJson('/api/scan/progress');
            if (p && p.isScanning) {
              const msg = p.message || 'Scanning...';
              const scanned = typeof p.scanned === 'number' ? p.scanned : 0;
              opShow(`${msg} (${scanned} files)`, 'indeterminate');
              await waitForScanCompletion();
              if (state.view === 'grid') {
                await loadList();
                render();
              }
            }
          } catch {
            // ignore
          }
        }

        el('scan').addEventListener('click', async () => {
          el('scan').disabled = true;
          try {
            opShow('Starting scan...', 'indeterminate');
            await apiJson('/api/scan', { method: 'POST' });
            await waitForScanCompletion();
            await loadList();
            render();
          } finally {
            el('scan').disabled = false;
          }
        });

        el('regenThumbs').addEventListener('click', async () => {
          const btn = el('regenThumbs');
          btn.disabled = true;
          try {
            opShow('Regenerating thumbs...', 'indeterminate');
            await apiJson('/api/cache/clear', { method: 'POST' });
            // Bust browser cache for /api/media/:id/thumb
            state.thumbVer = (state.thumbVer + 1) | 0;
            render();
            opShow('Thumbnails refreshed', { value: 1, max: 1 });
            await sleep(800);
            opHide();
          } finally {
            btn.disabled = false;
          }
        });

        if (uaHas('deovr')) {
          // In DeoVR's in-app browser, regeneration is not useful.
          el('regenThumbs').style.display = 'none';
        }
        if (uaHas('heresphere')) {
          // In HereSphere's in-app browser, regeneration is not useful.
          el('regenThumbs').style.display = 'none';
        }

        const maxPage = Math.max(1, Math.ceil(state.total / state.pageSize));
        el('first').disabled = state.page <= 1;
        el('prev').disabled = state.page <= 1;
        el('next').disabled = state.page >= maxPage;
        el('last').disabled = state.page >= maxPage;

        const scrollToTopSmooth = () => {
          const main = document.querySelector('main');
          if (main && typeof main.scrollIntoView === 'function') {
            try { main.scrollIntoView({ behavior: 'smooth', block: 'start' }); return; } catch {}
          }
          try { window.scrollTo({ top: 0, behavior: 'smooth' }); } catch { window.scrollTo(0, 0); }
        };
        
        el('first').addEventListener('click', async () => {
          state.page = 1;
          await loadList();
          render();
          scrollToTopSmooth();
        });
        
        el('prev').addEventListener('click', async () => {
          state.page = Math.max(1, state.page - 1);
          await loadList();
          render();
          scrollToTopSmooth();
        });
        
        el('next').addEventListener('click', async () => {
          state.page = Math.min(maxPage, state.page + 1);
          await loadList();
          render();
          scrollToTopSmooth();
        });
        
        el('last').addEventListener('click', async () => {
          state.page = maxPage;
          await loadList();
          render();
          scrollToTopSmooth();
        });
        
        // Page number buttons
        const pageButtons = document.querySelectorAll('.page-btn');
        for (const btn of pageButtons) {
          btn.addEventListener('click', async () => {
            const page = parseInt(btn.getAttribute('data-page'), 10);
            if (page && page !== state.page) {
              state.page = page;
              await loadList();
              render();
              scrollToTopSmooth();
            }
          });
        }

        // Card click-to-open (entire card).
        const cards = Array.from(document.querySelectorAll('.card[data-open-id]'));
        for (const c of cards) {
          c.addEventListener('click', () => {
            const id = c.getAttribute('data-open-id');
            if (id) window.__openBest(id);
          });
          c.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              const id = c.getAttribute('data-open-id');
              if (id) window.__openBest(id);
            }
          });
        }

        initThumbsForGrid();

        if (shouldRestoreQ) {
          const qEl = el('q');
          if (qEl instanceof HTMLInputElement) {
            qEl.focus({ preventScroll: true });
            const len = qEl.value.length;
            const s = typeof restoreStart === 'number' ? Math.min(restoreStart, len) : len;
            const e = typeof restoreEnd === 'number' ? Math.min(restoreEnd, len) : len;
            try { qEl.setSelectionRange(s, e); } catch {}
          }
        }

        prefetchDurationsForPage();
        prefetchMetaForPage();
      }

      function initThumbsForGrid() {
        const imgs = Array.from(document.querySelectorAll('img.thumbMedia'));
        for (const img of imgs) {
          const status = img.parentElement?.querySelector('.thumbStatus');
          if (!status) continue;

          // Default: show loading.
          status.textContent = 'Loading…';
          status.classList.remove('hidden');

          const onLoad = () => {
            status.classList.add('hidden');
          };
          const onError = () => {
            status.textContent = "Thumbnail couldn't load";
            status.classList.remove('hidden');
          };

          img.addEventListener('load', onLoad, { once: true });
          img.addEventListener('error', onError, { once: true });

          // If already loaded (from cache), update immediately.
          try {
            if (img.complete && img.naturalWidth > 0) onLoad();
          } catch {}
        }

        // Throttled loader for deferred thumbs (video thumbs only).
        const deferred = Array.from(document.querySelectorAll('img.thumbMedia[data-src]'));
        if (!deferred.length) return;

        const queue = [];
        let inFlight = 0;
        const maxInFlight = 4;

        const pump = () => {
          while (inFlight < maxInFlight && queue.length) {
            const img = queue.shift();
            if (!(img instanceof HTMLImageElement) || !img.isConnected) continue;

            const src = img.getAttribute('data-src');
            if (!src) continue;
            img.removeAttribute('data-src');

            inFlight++;
            const done = () => {
              inFlight = Math.max(0, inFlight - 1);
              pump();
            };
            img.addEventListener('load', done, { once: true });
            img.addEventListener('error', done, { once: true });
            img.src = src;
          }
        };

        const io = new IntersectionObserver((entries) => {
          for (const ent of entries) {
            if (!ent.isIntersecting) continue;
            const img = ent.target;
            io.unobserve(img);
            queue.push(img);
          }
          pump();
        }, { root: null, rootMargin: '300px', threshold: 0.01 });

        for (const img of deferred) io.observe(img);
      }

      async function prefetchDurationsForPage() {
        // Skip duration prefetch on VR browsers (HereSphere, DeoVR, Quest) to save resources/decoders.
        if (uaHas('heresphere') || uaHas('deovr') || uaHas('oculus') || uaHas('android')) return;

        const token = ++state._durToken;
        const ids = state.items
          .filter((it) => it.mediaType === 'video')
          .map((it) => it.id)
          .filter((id) => getDurationSec(id) === null);

        if (!ids.length) return;

        const concurrency = 4;
        let idx = 0;
        const workers = Array.from({ length: concurrency }, async () => {
          while (idx < ids.length) {
            const id = ids[idx++];
            if (token !== state._durToken) return;
            const meta = await probeDuration(id);
            if (token !== state._durToken) return;
            const d = Number(meta?.durationSec);
            if (Number.isFinite(d) && d > 0) {
              state.durationsSec[id] = d;
              const tag = document.querySelector(`.mvLen[data-id="${CSS.escape(id)}"]`);
              if (tag) tag.textContent = formatDuration(d);
            }

            const w = Number(meta?.width);
            const h = Number(meta?.height);
            if (Number.isFinite(w) && Number.isFinite(h) && w > 0 && h > 0) {
              const item = state.items.find((x) => String(x.id) === String(id));
              if (item) {
                item.width = w;
                item.height = h;
              }
              const res = document.querySelector(`.mvRes[data-id="${CSS.escape(id)}"]`);
              if (res) res.textContent = `${Math.round(w)}x${Math.round(h)}`;
            }
          }
        });

        await Promise.all(workers);
      }

      async function prefetchMetaForPage() {
        const token = ++state._metaToken;
        const ids = state.items
          .filter((it) => it && it.mediaType === 'video')
          .filter((it) => {
            const needsRes = !(Number.isFinite(Number(it.width)) && Number.isFinite(Number(it.height)) && Number(it.width) > 0 && Number(it.height) > 0);
            const needsFs = Boolean(it.hasFunscript) && (
              !(Number.isFinite(Number(it.funscriptAvgSpeed)) && Number(it.funscriptAvgSpeed) >= 0) ||
              !(Number.isFinite(Number(it.funscriptActionCount)) && Number(it.funscriptActionCount) > 0)
            );
            return needsRes || needsFs;
          })
          .map((it) => it.id);

        if (!ids.length) return;

        const setText = (sel, text) => {
          const elx = document.querySelector(sel);
          if (elx) elx.textContent = text;
        };

        const formatSpeedTag = (sp) => {
          const n = Number(sp);
          if (!Number.isFinite(n) || n < 0) return '?%/s';
          return `${n.toFixed(n >= 10 ? 0 : 1)}%/s`;
        };

        const concurrency = 4;
        let idx = 0;
        const workers = Array.from({ length: concurrency }, async () => {
          while (idx < ids.length) {
            const id = ids[idx++];
            if (token !== state._metaToken) return;

            const info = await apiJson(`/api/media/${id}/fileinfo`).catch(() => null);
            if (token !== state._metaToken) return;
            if (!info) continue;

            const item = state.items.find((x) => String(x.id) === String(id));
            if (!item) continue;

            const w = Number(info.width);
            const h = Number(info.height);
            if (Number.isFinite(w) && Number.isFinite(h) && w > 0 && h > 0) {
              item.width = w;
              item.height = h;
              setText(`.mvRes[data-id="${CSS.escape(String(id))}"]`, `${Math.round(w)}x${Math.round(h)}`);
            }

            if (item.hasFunscript) {
              const cnt = Number(info.funscriptActionCount);
              if (Number.isFinite(cnt) && cnt > 0) {
                item.funscriptActionCount = cnt;
                setText(`.mvFsCnt[data-id="${CSS.escape(String(id))}"]`, `${Math.round(cnt)} actions`);
              }

              const sp = Number(info.funscriptAvgSpeed);
              if (Number.isFinite(sp) && sp >= 0) {
                item.funscriptAvgSpeed = sp;
                setText(`.mvFsSpeed[data-id="${CSS.escape(String(id))}"]`, formatSpeedTag(sp));
              } else {
                // Fallback: compute from actual funscript payload if DB/fileinfo fields are missing.
                // Skip this fallback on VR browsers to save resources.
                if (!(uaHas('heresphere') || uaHas('deovr') || uaHas('oculus') || uaHas('android'))) {
                  setText(`.mvFsSpeed[data-id="${CSS.escape(String(id))}"]`, 'Loading…');
                  const j = await apiJson(`/api/media/${id}/funscript`).catch(() => null);
                  if (token !== state._metaToken) return;
                  if (j && Array.isArray(j.actions)) {
                    const stats = computeFunscriptStatsFromActions(j.actions);
                    if (stats) {
                      item.funscriptActionCount = stats.actionCount;
                      item.funscriptAvgSpeed = stats.avgSpeed;
                      setText(`.mvFsCnt[data-id="${CSS.escape(String(id))}"]`, `${Math.round(stats.actionCount)} actions`);
                      setText(`.mvFsSpeed[data-id="${CSS.escape(String(id))}"]`, formatSpeedTag(stats.avgSpeed));
                    } else {
                      setText(`.mvFsSpeed[data-id="${CSS.escape(String(id))}"]`, '?%/s');
                    }
                  } else {
                    setText(`.mvFsSpeed[data-id="${CSS.escape(String(id))}"]`, '?%/s');
                  }
                }
              }
            }
          }
        });

        await Promise.all(workers);
      }

      function probeDuration(id) {
        return new Promise((resolve) => {
          const v = document.createElement('video');
          v.preload = 'metadata';
          v.muted = true;
          v.playsInline = true;
          v.src = `/api/media/${id}/stream`;

          const done = (val) => {
            try {
              v.removeAttribute('src');
              v.load();
            } catch {}
            resolve(val);
          };

          v.addEventListener('loadedmetadata', () => {
            const durationSec = Number.isFinite(v.duration) ? v.duration : null;
            const width = Number.isFinite(v.videoWidth) ? v.videoWidth : null;
            const height = Number.isFinite(v.videoHeight) ? v.videoHeight : null;
            done({ durationSec, width, height });
          }, { once: true });
          v.addEventListener('error', () => done(null), { once: true });
        });
      }

      // Legacy client-side thumbnail generation (unused now that server handles it, but kept for reference if reverted)
      function initVideoThumbs() {
        return; // Deprecated: server now provides /thumb endpoint.
        if (!vids.length) return;

        const io = new IntersectionObserver((entries) => {
          for (const ent of entries) {
            if (!ent.isIntersecting) continue;
            const v = ent.target;
            io.unobserve(v);

            const src = v.getAttribute('data-src');
            if (!src) continue;
            v.src = src;
            v.addEventListener('loadeddata', () => {
              try {
                // Jump a little forward so we don't always show a black first frame.
                v.currentTime = 1;
              } catch {}
            }, { once: true });

            v.addEventListener('error', () => {
              const status = v.parentElement?.querySelector('.thumbStatus');
              if (status) {
                status.textContent = 'Preview unavailable';
                status.classList.remove('hidden');
              }
            }, { once: true });

            v.addEventListener('seeked', () => {
              try { v.pause(); } catch {}

              const id = v.getAttribute('data-id') || '';
              if (id && !getThumbDataUrl(id)) {
                try {
                  const w = Math.max(1, v.videoWidth || 0);
                  const h = Math.max(1, v.videoHeight || 0);
                  if (w > 1 && h > 1) {
                    const c = document.createElement('canvas');
                    c.width = w;
                    c.height = h;
                    const ctx = c.getContext('2d');
                    if (ctx) {
                      ctx.drawImage(v, 0, 0, w, h);
                      const dataUrl = c.toDataURL('image/jpeg', 0.75);
                      if (dataUrl && dataUrl.startsWith('data:image/')) {
                        setThumbDataUrl(id, dataUrl);
                        const img = document.createElement('img');
                        img.className = 'thumbMedia';
                        img.loading = 'lazy';
                        img.alt = '';
                        img.src = dataUrl;
                        v.replaceWith(img);
                      }
                    }
                  }
                } catch {}
              }

              const status = v.parentElement?.querySelector('.thumbStatus');
              if (status) status.classList.add('hidden');
            }, { once: true });
          }
        }, { root: null, rootMargin: '200px', threshold: 0.01 });

        vids.forEach((v) => io.observe(v));
      }

      // Legacy client-side thumbnail generation (unused now that server handles it, but kept for reference if reverted)
      function initImageThumbs() {
         return; // Deprecated.
      }

      function renderPlayer() {
        const id = state.current?.id;
        const item = state.current?.item;
        const vrLink = item?.isVr ? `<a href="#" onclick="window.__openBest('${id}');return false;">Open in VR player</a>` : '';
        const filename = escapeHtml(item?.filename || '');
        const tagVr = item?.isVr ? `<span class="tag tag--vr">vr</span>` : '';
        const tagFun = item?.hasFunscript
          ? `<span class="tag tag--good">funscript</span>`
          : `<span class="tag tag--bad">no funscript</span>`;

        const funPanel = item?.hasFunscript ? `
          <div class="panel">
            <div class="panelTitle">Funscript Info</div>
            <div class="kv" id="fsDetails">
              <div class="kvRow"><div class="kvKey">Stats</div><div class="kvVal" id="d-fs">${formatFunscriptStats(item?.funscriptActionCount, item?.funscriptAvgSpeed) || 'Loading…'}</div></div>
            </div>
          </div>
        ` : '';

        el('app').innerHTML = `
          <header>
            <h1>MediaViewer</h1>
            <div class="small">Player</div>
          </header>
          <div class="playerWrap">
            <div class="topbar">
              <a href="#" onclick="window.__back();return false;">Back</a>
              ${vrLink}
              <span class="small playerTitle">${filename}</span>
            </div>
            <div class="playerLayout">
              <div class="playerMain">
                <video class="playerVideo" id="v" controls autoplay playsinline src="/api/media/${id}/stream"></video>
                <div class="small playerStatus" id="syncStatus"></div>
              </div>
              <aside class="playerSide">
                <div class="panel">
                  <div class="panelTitle">Video Info</div>
                  <div class="tags playerTags">${tagVr}${tagFun}</div>
                  <div class="kv" id="details">
                    <div class="kvRow"><div class="kvKey">Filename</div><div class="kvVal">${filename}</div></div>
                    <div class="kvRow"><div class="kvKey">Path</div><div class="kvVal" id="d-rel">${escapeHtml(item?.relPath || '')}</div></div>
                    <div class="kvRow"><div class="kvKey">Duration</div><div class="kvVal" id="d-dur">Loading…</div></div>
                    <div class="kvRow"><div class="kvKey">Size</div><div class="kvVal" id="d-size">Loading…</div></div>
                    <div class="kvRow"><div class="kvKey">Modified</div><div class="kvVal" id="d-mod">Loading…</div></div>
                    <div class="kvRow"><div class="kvKey">Scheduled play</div><div class="kvVal"><input id="schedPlay" placeholder="off | seconds | HH:MM | ISO" value="${escapeHtml(state.scheduledPlaySpec || '')}" /></div></div>
                  </div>
                </div>
                ${funPanel}
              </aside>
            </div>
          </div>
        `;

        const schedPlayEl = document.getElementById('schedPlay');
        if (schedPlayEl instanceof HTMLInputElement) {
          schedPlayEl.addEventListener('change', () => {
            state.scheduledPlaySpec = String(schedPlayEl.value || '').trim();
            savePrefs();
          });
        }

        const v = el('v');
        const fps = 30;
        const mediaId = id;

        let wasPlayingBeforeSeek = false;

        const push = (e) => {
          if (!(v instanceof HTMLVideoElement)) return;
          if (isLocalVideoEventSuppressed()) return;
          const timeMs = Math.round((v.currentTime || 0) * 1000);
          const frame = Math.max(0, Math.floor((v.currentTime || 0) * fps));
          const force = e && (e.type === 'play' || e.type === 'pause' || e.type === 'seeked');

          // Coordinated seek: if a desktop client is connected and we seek while playing,
          // pause and resync so both ends buffer the new segment before starting together.
          if (e && e.type === 'seeked') {
            const desktopId = getFirstDesktopClientId();
            if (desktopId && wasPlayingBeforeSeek) {
              wasPlayingBeforeSeek = false;
              startSeekSyncAsLeader(v, mediaId, timeMs).catch(() => {});
              return;
            }

            // Some browsers will temporarily pause during a seek into an unbuffered region.
            // If the user was playing before the seek, try to resume once data is available.
            if (wasPlayingBeforeSeek && v.paused) {
              try { v.play(); } catch {}
              const startedAt = Date.now();
              const onCanPlay = () => {
                if (isLocalVideoEventSuppressed()) return;
                if (Date.now() - startedAt > 8000) return;
                if (v.paused) {
                  try { v.play(); } catch {}
                }
              };
              try { v.addEventListener('canplay', onCanPlay, { once: true }); } catch {}
            }
            wasPlayingBeforeSeek = false;
          }

          // Optional scheduled play: only send playAt when configured.
          if (force && e && e.type === 'play') {
            const clockOffset = typeof state.remoteServerClockOffsetMs === 'number' && Number.isFinite(state.remoteServerClockOffsetMs)
              ? state.remoteServerClockOffsetMs
              : 0;
            const sched = parseScheduledPlaySpec(state.scheduledPlaySpec, clockOffset);
            if (sched) {
              sendSyncUpdate({ mediaId, timeMs, paused: false, fps, frame, playAt: sched.playAt }, true);
              try { v.pause(); } catch {}
              try { v.currentTime = timeMs / 1000; } catch {}
              scheduleLocalPlayAt(v, sched.playAtLocalMs);
              return;
            }
            sendSyncUpdate({ mediaId, timeMs, paused: false, fps, frame }, true);
            return;
          }

          sendSyncUpdate({ mediaId, timeMs, paused: v.paused, fps, frame, playAt: v.paused ? null : undefined }, force);
        };

        if (v instanceof HTMLVideoElement) {
          v.addEventListener('seeking', () => {
            if (isLocalVideoEventSuppressed()) return;
            // Capture play intent at the start of the seek.
            wasPlayingBeforeSeek = !v.paused && !v.ended;
          });
          v.addEventListener('play', push);
          v.addEventListener('pause', push);
          v.addEventListener('seeked', push);
          v.addEventListener('timeupdate', push);
        }

        updateSyncStatus();

        hydrateDetailsPanels(id, item);
      }

      async function hydrateDetailsPanels(id, item) {
        // Hydrate fileinfo + duration + (optional) funscript stats.
        try {
          const rel = document.getElementById('d-rel');
          const dur = document.getElementById('d-dur');
          const size = document.getElementById('d-size');
          const mod = document.getElementById('d-mod');
          const fs = document.getElementById('d-fs');

          const info = await apiJson(`/api/media/${id}/fileinfo`).catch(() => null);
          if (info) {
            if (rel) rel.textContent = String(info.relPath || '');
            if (size) size.textContent = formatBytes(info.sizeBytes);
            if (mod) mod.textContent = formatDateTime(info.modifiedMs);
          } else {
            if (size) size.textContent = '--';
            if (mod) mod.textContent = '--';
          }

          const durMs = (info && Number.isFinite(Number(info.durationMs)) && Number(info.durationMs) > 0)
            ? Number(info.durationMs)
            : (item && Number.isFinite(Number(item.durationMs)) && Number(item.durationMs) > 0 ? Number(item.durationMs) : null);
          if (durMs != null) {
            if (dur) dur.textContent = formatDuration(durMs / 1000);
          } else {
            const probe = await apiJson(`/api/media/${id}/probe`).catch(() => null);
            if (probe && Number.isFinite(Number(probe.durationMs)) && Number(probe.durationMs) > 0) {
              if (dur) dur.textContent = formatDuration(Number(probe.durationMs) / 1000);
            } else {
              if (dur) dur.textContent = '--:--';
            }
          }

          if (item?.hasFunscript && fs) {
            const cnt = info?.funscriptActionCount ?? item?.funscriptActionCount;
            const sp = info?.funscriptAvgSpeed ?? item?.funscriptAvgSpeed;

            if (Number.isFinite(Number(cnt)) && Number(cnt) > 0) {
              fs.textContent = formatFunscriptStats(cnt, sp);
            } else {
              // Fallback: compute from actual funscript payload if DB fields are missing.
              fs.textContent = 'Loading…';
              const j = await apiJson(`/api/media/${id}/funscript`).catch(() => null);
              if (!j || !Array.isArray(j.actions)) {
                fs.textContent = 'Unavailable';
              } else {
                const stats = computeFunscriptStatsFromActions(j.actions);
                if (!stats) {
                  fs.textContent = 'Unavailable';
                } else {
                  fs.textContent = formatFunscriptStats(stats.actionCount, stats.avgSpeed);
                }
              }
            }
          }
        } catch {
          const dur = document.getElementById('d-dur');
          const size = document.getElementById('d-size');
          const mod = document.getElementById('d-mod');
          if (dur) dur.textContent = '--:--';
          if (size) size.textContent = '--';
          if (mod) mod.textContent = '--';
        }
      }

      function renderVr() {
        const id = state.current?.id;
        const item = state.current?.item;
        const filename = escapeHtml(item?.filename || '');
        const tagVr = item?.isVr ? `<span class="tag tag--vr">vr</span>` : '';
        const tagFun = item?.hasFunscript
          ? `<span class="tag tag--good">funscript</span>`
          : `<span class="tag tag--bad">no funscript</span>`;

        const funPanel = item?.hasFunscript ? `
          <div class="panel">
            <div class="panelTitle">Funscript Info</div>
            <div class="kv" id="fsDetails">
              <div class="kvRow"><div class="kvKey">Stats</div><div class="kvVal" id="d-fs">${formatFunscriptStats(item?.funscriptActionCount, item?.funscriptAvgSpeed) || 'Loading…'}</div></div>
            </div>
          </div>
        ` : '';

        el('app').innerHTML = `
          <header>
            <h1>MediaViewer</h1>
            <div class="small">VR Player</div>
          </header>
          <div class="playerWrap">
            <div class="topbar">
              <a href="#" onclick="window.__back();return false;">Back</a>
              <a href="#" onclick="window.__openPlayer('${id}');return false;">Open Normal</a>
              <span class="small">${filename}</span>
            </div>
            <div class="playerLayout">
              <div class="playerMain">
                <div class="small">Uses WebXR via A-Frame. If you have a headset, enter VR from the button.</div>
                <script src="https://aframe.io/releases/1.6.0/aframe.min.js"><\/script>
                <a-scene embedded vr-mode-ui="enabled: true">
                  <a-assets>
                    <video id="vvr" crossorigin="anonymous" autoplay loop="false" playsinline webkit-playsinline src="/api/media/${id}/stream"></video>
                  </a-assets>
                  <a-plane position="0 1.6 -2" rotation="0 0 0" width="3.2" height="1.8" material="shader: flat; src: #vvr"></a-plane>
                  <a-camera position="0 1.6 0"></a-camera>
                </a-scene>
                <div class="small playerStatus" id="syncStatus"></div>
              </div>
              <aside class="playerSide">
                <div class="panel">
                  <div class="panelTitle">Video Info</div>
                  <div class="tags playerTags">${tagVr}${tagFun}</div>
                  <div class="kv" id="details">
                    <div class="kvRow"><div class="kvKey">Filename</div><div class="kvVal">${filename}</div></div>
                    <div class="kvRow"><div class="kvKey">Path</div><div class="kvVal" id="d-rel">${escapeHtml(item?.relPath || '')}</div></div>
                    <div class="kvRow"><div class="kvKey">Duration</div><div class="kvVal" id="d-dur">Loading…</div></div>
                    <div class="kvRow"><div class="kvKey">Size</div><div class="kvVal" id="d-size">Loading…</div></div>
                    <div class="kvRow"><div class="kvKey">Modified</div><div class="kvVal" id="d-mod">Loading…</div></div>
                    <div class="kvRow"><div class="kvKey">Scheduled play</div><div class="kvVal"><input id="schedPlay" placeholder="off | seconds | HH:MM | ISO" value="${escapeHtml(state.scheduledPlaySpec || '')}" /></div></div>
                  </div>
                </div>
                ${funPanel}
              </aside>
            </div>
          </div>
        `;

        const schedPlayEl = document.getElementById('schedPlay');
        if (schedPlayEl instanceof HTMLInputElement) {
          schedPlayEl.addEventListener('change', () => {
            state.scheduledPlaySpec = String(schedPlayEl.value || '').trim();
            savePrefs();
          });
        }

        updateSyncStatus();
        hydrateDetailsPanels(id, item);

        // Set up sync for VR player
        const vvr = el('vvr');
        const fps = 30;
        const mediaId = id;

        let wasPlayingBeforeSeek = false;

        const push = (e) => {
          if (!(vvr instanceof HTMLVideoElement)) return;
          if (isLocalVideoEventSuppressed()) return;
          const timeMs = Math.round((vvr.currentTime || 0) * 1000);
          const frame = Math.max(0, Math.floor((vvr.currentTime || 0) * fps));
          const force = e && (e.type === 'play' || e.type === 'pause' || e.type === 'seeked');

          if (e && e.type === 'seeked') {
            const desktopId = getFirstDesktopClientId();
            if (desktopId && wasPlayingBeforeSeek) {
              wasPlayingBeforeSeek = false;
              startSeekSyncAsLeader(vvr, mediaId, timeMs).catch(() => {});
              return;
            }

            if (wasPlayingBeforeSeek && vvr.paused) {
              try { vvr.play(); } catch {}
              const startedAt = Date.now();
              const onCanPlay = () => {
                if (isLocalVideoEventSuppressed()) return;
                if (Date.now() - startedAt > 8000) return;
                if (vvr.paused) {
                  try { vvr.play(); } catch {}
                }
              };
              try { vvr.addEventListener('canplay', onCanPlay, { once: true }); } catch {}
            }
            wasPlayingBeforeSeek = false;
          }

          if (force && e && e.type === 'play') {
            const clockOffset = typeof state.remoteServerClockOffsetMs === 'number' && Number.isFinite(state.remoteServerClockOffsetMs)
              ? state.remoteServerClockOffsetMs
              : 0;
            const sched = parseScheduledPlaySpec(state.scheduledPlaySpec, clockOffset);
            if (sched) {
              sendSyncUpdate({ mediaId, timeMs, paused: false, fps, frame, playAt: sched.playAt }, true);
              try { vvr.pause(); } catch {}
              try { vvr.currentTime = timeMs / 1000; } catch {}
              scheduleLocalPlayAt(vvr, sched.playAtLocalMs);
              return;
            }
            sendSyncUpdate({ mediaId, timeMs, paused: false, fps, frame }, true);
            return;
          }

          sendSyncUpdate({ mediaId, timeMs, paused: vvr.paused, fps, frame, playAt: vvr.paused ? null : undefined }, force);
        };

        if (vvr instanceof HTMLVideoElement) {
          vvr.addEventListener('seeking', () => {
            if (isLocalVideoEventSuppressed()) return;
            wasPlayingBeforeSeek = !vvr.paused && !vvr.ended;
          });
          vvr.addEventListener('play', push);
          vvr.addEventListener('pause', push);
          vvr.addEventListener('seeked', push);
          vvr.addEventListener('timeupdate', push);
        }
      }

      function render() {
        if (state.view === 'grid') return renderGrid();
        if (state.view === 'player') return renderPlayer();
        if (state.view === 'vr') return renderVr();
      }

      window.__openPlayer = async (id) => {
        const item = await getItemInfo(id);
        setView('player', { id, item });
        sendSyncUpdate({ mediaId: id, timeMs: 0, paused: true, fps: 30, frame: 0 });
      };
      window.__openVr = async (id) => {
        const item = await getItemInfo(id);
        setView('vr', { id, item });
      };

      function uaHas(substr) {
        try { return navigator.userAgent.toLowerCase().includes(substr.toLowerCase()); } catch { return false; }
      }

      window.__openBest = async (id) => {
        const item = await getItemInfo(id);
        const isVr = Boolean(item?.isVr);

        if (!isVr) {
          await window.__openPlayer(id);
          return;
        }

        // In HereSphere, the intended flow is to open a HereSphere per-video JSON endpoint.
        // Include sessionId so the server can broadcast VR sync selection.
        if (uaHas('heresphere')) {
          window.location.href = `/heresphere/video/${encodeURIComponent(id)}?sessionId=${encodeURIComponent(state.wsSessionId || 'default')}`;
          return;
        }

        // If we're inside DeoVR, navigate directly to JSON. The browser will handle it.
        if (uaHas('deovr')) {
          window.__openDeoVrVideo(id);
          return;
        }

        // Default: our built-in WebXR/A-Frame view works in VR-capable browsers and still shows a usable fallback in 2D.
        await window.__openVr(id);
      };

      window.__openDeoVrLibrary = () => {
        const sessionId = encodeURIComponent(state.wsSessionId || 'default');
        const url = new URL(`/deovr?sessionId=${sessionId}`, window.location.origin).toString();
        window.location.href = `deovr://${url}`;
      };
      window.__openDeoVrVideo = (id) => {
        const safeId = encodeURIComponent(id);
        const sessionId = encodeURIComponent(state.wsSessionId || 'default');
        const url = new URL(`/deovr/video/${safeId}?sessionId=${sessionId}`, window.location.origin).toString();
        window.location.href = `deovr://${url}`;
      };
      window.__openHereSphereLibrary = () => {
        const url = new URL(`/heresphere?sessionId=${encodeURIComponent(state.wsSessionId || 'default')}`, window.location.origin).toString();
        if (uaHas('heresphere')) {
          window.location.href = url;
        } else {
          window.open(url, '_blank', 'noopener');
        }
      };
      window.__openHereSphereVideo = (id) => {
        const safeId = encodeURIComponent(id);
        const sessionId = encodeURIComponent(state.wsSessionId || 'default');
        const url = new URL(`/heresphere/video/${safeId}?sessionId=${sessionId}`, window.location.origin).toString();
        if (uaHas('heresphere')) {
          window.location.href = url;
        } else {
          window.open(url, '_blank', 'noopener');
        }
      };

      window.__back = async () => {
        setView('grid', null);
      };

      // Some browsers treat function declarations inside blocks as block-scoped.
      // Ensure scan-resume is always callable from the startup IIFE.
      window.resumeScanIfNeeded = window.resumeScanIfNeeded || (async () => {
        try {
          const res = await fetch('/api/scan/progress', { cache: 'no-store' });
          if (!res.ok) return;
          const p = await res.json();
          if (p && p.isScanning) {
            // Prefer the existing in-page helpers if they exist.
            if (typeof resumeScanIfNeeded === 'function') {
              await resumeScanIfNeeded();
              return;
            }
            // Fallback: minimal progress overlay + poll.
            const op = document.getElementById('opStatus');
            const opText = document.getElementById('opText');
            const opProg = document.getElementById('opProgress');
            if (op && opText && opProg) {
              op.style.display = 'flex';
              opText.textContent = String(p.message || 'Scanning...');
              opProg.removeAttribute('value');
            }
            for (;;) {
              const r2 = await fetch('/api/scan/progress', { cache: 'no-store' });
              if (!r2.ok) break;
              const p2 = await r2.json();
              if (p2 && p2.isScanning) {
                if (op && opText) opText.textContent = String(p2.message || 'Scanning...');
                await new Promise((r) => setTimeout(r, 500));
                continue;
              }
              break;
            }
            if (op) op.style.display = 'none';
            if (state.view === 'grid' && typeof loadList === 'function' && typeof render === 'function') {
              await loadList();
              render();
            }
          }
        } catch {
          // ignore
        }
      });

      function renderBootShell() {
        const root = document.getElementById('app');
        if (!root) return;
        // Minimal initial markup so scan progress can render immediately,
        // even while the full list is still loading.
        root.innerHTML = `
          <header>
            <h1>MediaViewer</h1>
            <div class="opStatus" id="opStatus" style="display:none">
              <progress id="opProgress"></progress>
              <span class="small" id="opText"></span>
            </div>
          </header>
          <main>
            <div class="small">Loading…</div>
          </main>
        `;
      }

      (async () => {
        ensureClientId();
        loadPrefs();
        connectWs();

        // Render a minimal shell immediately (prevents blank screen and enables scan indicator).
        renderBootShell();

        // If a scan is in progress, resume the overlay ASAP (do not block list loading).
        try { window.resumeScanIfNeeded(); } catch {}

        await loadList();
        render();
      })();
    </script>
  </head>
  <body>
    <div id="app"></div>
  </body>
</html>
