<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>MediaViewer</title>
    <link rel="stylesheet" href="/styles.css" />
    <script>
      const state = {
        q: '',
        page: 1,
        pageSize: 12,
        total: 0,
        items: [],
        funFilter: 'all', // all | with | without
        vrFilter: 'all', // all | vr | nonvr
        gridMin: 180,
        sort: 'newest', // newest | lenAsc | lenDesc
        lenMinSec: 0,
        durationsSec: {},
        thumbCache: {},
        _durToken: 0,
        view: 'grid', // grid | player | vr
        current: null,
        clientId: null,
        ws: null,
        wsConnected: false,
        wsSessionId: 'default',
        _applyingRemoteUntil: 0,
        _lastSentAt: 0,
        thumbVer: 0,
      };

      function el(id) { return document.getElementById(id); }

      async function apiJson(url, opts) {
        const res = await fetch(url, opts);
        if (!res.ok) throw new Error(await res.text());
        return res.json();
      }

      function setView(view, current = null) {
        state.view = view;
        state.current = current;
        render();
      }

      function ensureClientId() {
        if (state.clientId) return state.clientId;
        const key = 'mvClientId';
        const existing = window.localStorage.getItem(key);
        if (existing) {
          state.clientId = existing;
          return existing;
        }
        const id = 'web-' + Math.random().toString(16).slice(2);
        window.localStorage.setItem(key, id);
        state.clientId = id;
        return id;
      }

      function loadPrefs() {
        try {
          const saved = window.localStorage.getItem('mvPrefs');
          if (saved) {
            const prefs = JSON.parse(saved);
            if (typeof prefs.gridMin === 'number' && prefs.gridMin >= 120 && prefs.gridMin <= 360) {
              state.gridMin = prefs.gridMin;
            }
          }
        } catch {
          // ignore parse errors
        }
      }

      function savePrefs() {
        try {
          window.localStorage.setItem('mvPrefs', JSON.stringify({
            gridMin: state.gridMin,
          }));
        } catch {
          // ignore storage errors
        }
      }

      function loadPrefs() {
        try {
          const saved = window.localStorage.getItem('mvPrefs');
          if (saved) {
            const prefs = JSON.parse(saved);
            if (typeof prefs.gridMin === 'number' && prefs.gridMin >= 120 && prefs.gridMin <= 360) {
              state.gridMin = prefs.gridMin;
            }
          }
        } catch {
          // ignore parse errors
        }
      }

      function savePrefs() {
        try {
          window.localStorage.setItem('mvPrefs', JSON.stringify({
            gridMin: state.gridMin,
          }));
        } catch {
          // ignore storage errors
        }
      }

      function wsUrlFromHttp(base) {
        const u = new URL(base);
        u.protocol = u.protocol === 'https:' ? 'wss:' : 'ws:';
        u.pathname = '/ws';
        u.search = '';
        u.hash = '';
        return u.toString();
      }

      function connectWs() {
        ensureClientId();
        if (state.ws && (state.ws.readyState === 0 || state.ws.readyState === 1)) return;

        const wsUrl = wsUrlFromHttp(window.location.origin);
        const ws = new WebSocket(wsUrl);
        state.ws = ws;

        ws.addEventListener('open', () => {
          state.wsConnected = true;
          ws.send(JSON.stringify({ type: 'sync:hello', clientId: state.clientId, sessionId: state.wsSessionId }));
        });

        ws.addEventListener('close', () => {
          state.wsConnected = false;
          window.setTimeout(() => connectWs(), 1000);
        });

        ws.addEventListener('message', (evt) => {
          let msg;
          try { msg = JSON.parse(String(evt.data)); } catch { return; }
          if (!msg || msg.type !== 'sync:state' || !msg.state) return;
          applyRemoteSyncState(msg.state);
        });
      }

      function sendSyncUpdate(update, force) {
        if (!state.wsConnected || !state.ws || state.ws.readyState !== 1) return;
        if (Date.now() < state._applyingRemoteUntil) return;
        const now = Date.now();
        if (!force && now - state._lastSentAt < 200) return;
        state._lastSentAt = now;

        state.ws.send(JSON.stringify({
          type: 'sync:update',
          sessionId: state.wsSessionId,
          clientId: state.clientId,
          ...update,
        }));
      }

      async function getItemInfo(id) {
        const found = state.items.find((x) => x.id === id);
        if (found) return found;
        try {
          const info = await apiJson(`/api/media/${id}/fileinfo`);
          return {
            id: info.id,
            filename: info.filename,
            relPath: info.relPath,
            mediaType: info.mediaType,
            hasFunscript: info.hasFunscript,
            isVr: info.isVr,
          };
        } catch {
          return { id, filename: '', relPath: '', mediaType: 'video', hasFunscript: false, isVr: false };
        }
      }

      async function applyRemoteSyncState(remote) {
        if (!remote) return;
        if (remote.fromClientId && remote.fromClientId === state.clientId) return;
        if (!remote.mediaId) return;

        const id = String(remote.mediaId);
        const item = await getItemInfo(id);

        // If different media, follow it.
        if (state.current?.id !== id || state.view === 'grid') {
          state._applyingRemoteUntil = Date.now() + 800;
          if (item?.isVr) {
            // For integrated WebVR support.
            setView('vr', { id, item });
          } else {
            setView('player', { id, item });
          }
          // Wait a tick for DOM.
          await new Promise((r) => setTimeout(r, 0));
        }

        const v = document.getElementById('v') || document.getElementById('vvr');
        if (!(v instanceof HTMLVideoElement)) return;

        state._applyingRemoteUntil = Date.now() + 800;

        const targetTime = Math.max(0, (Number(remote.timeMs) || 0) / 1000);
        if (Number.isFinite(v.currentTime) && Math.abs(v.currentTime - targetTime) > 0.5) {
          try { v.currentTime = targetTime; } catch {}
        }

        const paused = Boolean(remote.paused);
        if (paused) {
          try { v.pause(); } catch {}
        } else {
          try { await v.play(); } catch {}
        }
      }

      function formatPageLabel() {
        const maxPage = Math.max(1, Math.ceil(state.total / state.pageSize));
        return `Page ${state.page} / ${maxPage} (${state.total} items)`;
      }
      function generatePageButtons() {
        const maxPage = Math.max(1, Math.ceil(state.total / state.pageSize));
        const current = state.page;
        const buttons = [];
        
        // Calculate which page numbers to show (up to 5)
        let startPage = Math.max(1, current - 2);
        let endPage = Math.min(maxPage, startPage + 4);
        
        // Adjust if we're near the end
        if (endPage - startPage < 4) {
          startPage = Math.max(1, endPage - 4);
        }
        
        for (let i = startPage; i <= endPage; i++) {
          const active = i === current ? ' active' : '';
          buttons.push(`<button class="btn page-btn${active}" data-page="${i}">${i}</button>`);
        }
        
        return buttons.join('');
      }
      function thumbKey(id) {
        return `mvThumb:${id}`;
      }

      function getThumbDataUrl(id) {
        if (state.thumbCache[id]) return state.thumbCache[id];
        try {
          const v = window.sessionStorage.getItem(thumbKey(id));
          if (v) {
            state.thumbCache[id] = v;
            return v;
          }
        } catch {}
        return null;
      }

      function setThumbDataUrl(id, dataUrl) {
        state.thumbCache[id] = dataUrl;
        try {
          window.sessionStorage.setItem(thumbKey(id), dataUrl);
        } catch {}
      }

      async function loadList() {
        const q = encodeURIComponent(state.q);
        const params = new URLSearchParams();
        params.set('q', state.q);
        params.set('page', String(state.page));
        params.set('pageSize', String(state.pageSize));
        params.set('mediaType', 'video');
        if (state.funFilter === 'with') params.set('hasFunscript', '1');
        if (state.funFilter === 'without') params.set('hasFunscript', '0');
        if (state.vrFilter === 'vr') params.set('isVr', '1');
        if (state.vrFilter === 'nonvr') params.set('isVr', '0');

        const data = await apiJson(`/api/media?${params.toString()}`);
        state.total = data.total;
        state.items = data.items;
      }

      async function doSearch(value) {
        state.q = value;
        state.page = 1;
        await loadList();
        render();
      }

      function formatDuration(seconds) {
        if (!Number.isFinite(seconds) || seconds <= 0) return '--:--';
        const total = Math.round(seconds);
        const h = Math.floor(total / 3600);
        const m = Math.floor((total % 3600) / 60);
        const s = total % 60;
        if (h > 0) return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        return `${m}:${String(s).padStart(2, '0')}`;
      }

      function getDurationSec(id) {
        const v = state.durationsSec[id];
        return Number.isFinite(v) ? v : null;
      }

      function getGridItems() {
        let items = [...state.items];
        if (state.lenMinSec > 0) {
          items = items.filter((it) => {
            const d = getDurationSec(it.id);
            return d !== null && d >= state.lenMinSec;
          });
        }

        if (state.sort === 'lenAsc' || state.sort === 'lenDesc') {
          const dir = state.sort === 'lenAsc' ? 1 : -1;
          items.sort((a, b) => {
            const da = getDurationSec(a.id);
            const db = getDurationSec(b.id);

            if (da === null && db === null) return 0;
            if (da === null) return 1;
            if (db === null) return -1;
            return (da - db) * dir;
          });
        }

        return items;
      }

      function card(item) {
        const tagF = item.hasFunscript
          ? `<span class="tag tag--good">funscript</span>`
          : `<span class="tag tag--bad">no funscript</span>`;
        const tagT = `<span class="tag">${item.mediaType}</span>`;

        const durationTag = item.mediaType === 'video'
          ? `<span class="tag mvLen" data-id="${item.id}">${formatDuration(getDurationSec(item.id) ?? NaN)}</span>`
          : '';

        // Use server-side generated thumbnail for video.
        const thumbUrl = item.mediaType === 'image' 
          ? `/api/media/${item.id}/stream`
          : `/api/media/${item.id}/thumb?v=${state.thumbVer}`;

        const thumb = `<img class="thumbMedia" loading="lazy" src="${thumbUrl}" alt="${escapeHtml(item.filename)}" />`;
        // No client-side processing status needed anymore
        const thumbStatus = '';

        return `
          <div class="card" role="button" tabindex="0" data-open-id="${escapeHtml(item.id)}" aria-label="Open: ${escapeHtml(item.filename)}">
            <div class="thumb">
              ${thumb}
              ${thumbStatus}
            </div>
            <div class="meta">
              <div class="name">${escapeHtml(item.filename)}</div>
              <div class="tags">${tagT}${tagF}${durationTag}</div>
            </div>
          </div>
        `;
      }

      function escapeHtml(s) {
        return String(s)
          .replaceAll('&', '&amp;')
          .replaceAll('<', '&lt;')
          .replaceAll('>', '&gt;')
          .replaceAll('"', '&quot;')
          .replaceAll("'", '&#039;');
      }

      async function openById(id) {
        const item = state.items.find((x) => x.id === id) || (await apiJson(`/api/media/${id}/fileinfo`).then(() => ({ id })));
        setView('player', { id, item });
      }

      function renderGrid() {
        const visible = getGridItems();
        el('app').innerHTML = `
          <header>
            <h1>MediaViewer</h1>
            <div class="search"><input id="q" placeholder="Search by filename" value="${escapeHtml(state.q)}" /></div>
            <select id="pageSize" title="Items per page">
              ${[12, 24, 48, 96].map((n) => `<option value="${n}" ${n === state.pageSize ? 'selected' : ''}>${n}/page</option>`).join('')}
            </select>
            <select id="funFilter" title="Funscript filter">
              <option value="all" ${state.funFilter === 'all' ? 'selected' : ''}>All videos</option>
              <option value="with" ${state.funFilter === 'with' ? 'selected' : ''}>With funscript</option>
              <option value="without" ${state.funFilter === 'without' ? 'selected' : ''}>Without funscript</option>
            </select>
            <select id="vrFilter" title="VR filter">
              <option value="all" ${state.vrFilter === 'all' ? 'selected' : ''}>All</option>
              <option value="vr" ${state.vrFilter === 'vr' ? 'selected' : ''}>VR only</option>
              <option value="nonvr" ${state.vrFilter === 'nonvr' ? 'selected' : ''}>Non-VR only</option>
            </select>
            <select id="sort" title="Sort">
              <option value="newest" ${state.sort === 'newest' ? 'selected' : ''}>Newest</option>
              <option value="lenAsc" ${state.sort === 'lenAsc' ? 'selected' : ''}>Length (short → long)</option>
              <option value="lenDesc" ${state.sort === 'lenDesc' ? 'selected' : ''}>Length (long → short)</option>
            </select>
            <select id="lenMin" title="Minimum length">
              <option value="0" ${state.lenMinSec === 0 ? 'selected' : ''}>Any length</option>
              <option value="120" ${state.lenMinSec === 120 ? 'selected' : ''}>>= 2 min</option>
              <option value="300" ${state.lenMinSec === 300 ? 'selected' : ''}>>= 5 min</option>
              <option value="600" ${state.lenMinSec === 600 ? 'selected' : ''}>>= 10 min</option>
              <option value="1200" ${state.lenMinSec === 1200 ? 'selected' : ''}>>= 20 min</option>
              <option value="1800" ${state.lenMinSec === 1800 ? 'selected' : ''}>>= 30 min</option>
            </select>
            <button class="btn" id="gridDec" title="Smaller grid">-</button>
            <button class="btn" id="gridInc" title="Larger grid">+</button>
            <button class="btn" id="scan">Rescan</button>
            <button class="btn" id="regenThumbs" title="Clear server thumbnail cache and refresh">Regenerate thumbs</button>
            <button class="btn" id="deovrLib" title="Open library in DeoVR">DeoVR Library</button>
            <button class="btn" id="hsLib" title="Open HereSphere library JSON">HereSphere Library</button>
          </header>
          <main>
            <div class="small">${formatPageLabel()}</div>
            <div class="grid" id="grid">${visible.map(card).join('')}</div>
            <div class="pager">
              <button class="btn" id="first">First</button>
              <button class="btn" id="prev">Prev</button>
              <div class="page-numbers" id="pageNumbers">${generatePageButtons()}</div>
              <button class="btn" id="next">Next</button>
              <button class="btn" id="last">Last</button>
            </div>
          </main>
        `;

        el('grid').style.setProperty('--card-min', `${state.gridMin}px`);

        el('q').addEventListener('input', (e) => {
          const val = e.target.value;
          window.clearTimeout(window.__qT);
          window.__qT = window.setTimeout(() => doSearch(val), 200);
        });

        el('pageSize').addEventListener('change', async (e) => {
          state.pageSize = Number(e.target.value) || 48;
          state.page = 1;
          await loadList();
          render();
        });

        el('funFilter').addEventListener('change', async (e) => {
          state.funFilter = e.target.value;
          state.page = 1;
          await loadList();
          render();
        });

        el('vrFilter').addEventListener('change', async (e) => {
          state.vrFilter = e.target.value;
          state.page = 1;
          await loadList();
          render();
        });

        el('sort').addEventListener('change', async (e) => {
          state.sort = e.target.value;
          render();
        });

        el('lenMin').addEventListener('change', async (e) => {
          state.lenMinSec = Number(e.target.value) || 0;
          render();
        });

        el('gridDec').addEventListener('click', () => {
          state.gridMin = Math.max(120, state.gridMin - 20);
          el('grid').style.setProperty('--card-min', `${state.gridMin}px`);
          savePrefs();
        });

        el('gridInc').addEventListener('click', () => {
          state.gridMin = Math.min(360, state.gridMin + 20);
          el('grid').style.setProperty('--card-min', `${state.gridMin}px`);
          savePrefs();
        });

        el('scan').addEventListener('click', async () => {
          el('scan').disabled = true;
          try {
            await apiJson('/api/scan', { method: 'POST' });
            await loadList();
            render();
          } finally {
            el('scan').disabled = false;
          }
        });

        el('regenThumbs').addEventListener('click', async () => {
          const btn = el('regenThumbs');
          btn.disabled = true;
          try {
            await apiJson('/api/cache/clear', { method: 'POST' });
            // Bust browser cache for /api/media/:id/thumb
            state.thumbVer = (state.thumbVer + 1) | 0;
            render();
          } finally {
            btn.disabled = false;
          }
        });

        el('deovrLib').addEventListener('click', () => window.__openDeoVrLibrary());
        el('hsLib').addEventListener('click', () => window.__openHereSphereLibrary());
        if (uaHas('deovr')) {
          // In DeoVR's in-app browser, a deovr:// deep link isn't useful.
          el('deovrLib').style.display = 'none';
          el('hsLib').style.display = 'none';
          el('regenThumbs').style.display = 'none';
        }
        if (uaHas('heresphere')) {
          // Keep the HereSphere library link visible so users can open it and use
          // HereSphere's Web Stream / Web API importer.
          el('deovrLib').style.display = 'none';
          el('regenThumbs').style.display = 'none';
        }

        const maxPage = Math.max(1, Math.ceil(state.total / state.pageSize));
        el('first').disabled = state.page <= 1;
        el('prev').disabled = state.page <= 1;
        el('next').disabled = state.page >= maxPage;
        el('last').disabled = state.page >= maxPage;
        
        el('first').addEventListener('click', async () => {
          state.page = 1;
          await loadList();
          render();
        });
        
        el('prev').addEventListener('click', async () => {
          state.page = Math.max(1, state.page - 1);
          await loadList();
          render();
        });
        
        el('next').addEventListener('click', async () => {
          state.page = Math.min(maxPage, state.page + 1);
          await loadList();
          render();
        });
        
        el('last').addEventListener('click', async () => {
          state.page = maxPage;
          await loadList();
          render();
        });
        
        // Page number buttons
        const pageButtons = document.querySelectorAll('.page-btn');
        for (const btn of pageButtons) {
          btn.addEventListener('click', async () => {
            const page = parseInt(btn.getAttribute('data-page'), 10);
            if (page && page !== state.page) {
              state.page = page;
              await loadList();
              render();
            }
          });
        }

        // Card click-to-open (entire card).
        const cards = Array.from(document.querySelectorAll('.card[data-open-id]'));
        for (const c of cards) {
          c.addEventListener('click', () => {
            const id = c.getAttribute('data-open-id');
            if (id) window.__openBest(id);
          });
          c.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              const id = c.getAttribute('data-open-id');
              if (id) window.__openBest(id);
            }
          });
        }

        // initVideoThumbs(); // Removed
        // initImageThumbs(); // Removed
        prefetchDurationsForPage();
      }

      async function prefetchDurationsForPage() {
        // Skip duration prefetch on VR browsers (HereSphere, DeoVR, Quest) to save resources/decoders.
        if (uaHas('heresphere') || uaHas('deovr') || uaHas('oculus') || uaHas('android')) return;

        const token = ++state._durToken;
        const ids = state.items
          .filter((it) => it.mediaType === 'video')
          .map((it) => it.id)
          .filter((id) => getDurationSec(id) === null);

        if (!ids.length) return;

        const concurrency = 4;
        let idx = 0;
        const workers = Array.from({ length: concurrency }, async () => {
          while (idx < ids.length) {
            const id = ids[idx++];
            if (token !== state._durToken) return;
            const d = await probeDuration(id);
            if (token !== state._durToken) return;
            if (typeof d === 'number' && Number.isFinite(d) && d > 0) {
              state.durationsSec[id] = d;
              const tag = document.querySelector(`.mvLen[data-id="${CSS.escape(id)}"]`);
              if (tag) tag.textContent = formatDuration(d);
            }
          }
        });

        await Promise.all(workers);

        // If sorting/filtering depends on duration, re-render once after probes.
        if (token === state._durToken && (state.sort !== 'newest' || state.lenMinSec > 0)) {
          render();
        }
      }

      function probeDuration(id) {
        return new Promise((resolve) => {
          const v = document.createElement('video');
          v.preload = 'metadata';
          v.muted = true;
          v.playsInline = true;
          v.src = `/api/media/${id}/stream`;

          const done = (val) => {
            try {
              v.removeAttribute('src');
              v.load();
            } catch {}
            resolve(val);
          };

          v.addEventListener('loadedmetadata', () => done(v.duration), { once: true });
          v.addEventListener('error', () => done(null), { once: true });
        });
      }

      // Legacy client-side thumbnail generation (unused now that server handles it, but kept for reference if reverted)
      function initVideoThumbs() {
        return; // Deprecated: server now provides /thumb endpoint.
        if (!vids.length) return;

        const io = new IntersectionObserver((entries) => {
          for (const ent of entries) {
            if (!ent.isIntersecting) continue;
            const v = ent.target;
            io.unobserve(v);

            const src = v.getAttribute('data-src');
            if (!src) continue;
            v.src = src;
            v.addEventListener('loadeddata', () => {
              try {
                // Jump a little forward so we don't always show a black first frame.
                v.currentTime = 1;
              } catch {}
            }, { once: true });

            v.addEventListener('error', () => {
              const status = v.parentElement?.querySelector('.thumbStatus');
              if (status) {
                status.textContent = 'Preview unavailable';
                status.classList.remove('hidden');
              }
            }, { once: true });

            v.addEventListener('seeked', () => {
              try { v.pause(); } catch {}

              const id = v.getAttribute('data-id') || '';
              if (id && !getThumbDataUrl(id)) {
                try {
                  const w = Math.max(1, v.videoWidth || 0);
                  const h = Math.max(1, v.videoHeight || 0);
                  if (w > 1 && h > 1) {
                    const c = document.createElement('canvas');
                    c.width = w;
                    c.height = h;
                    const ctx = c.getContext('2d');
                    if (ctx) {
                      ctx.drawImage(v, 0, 0, w, h);
                      const dataUrl = c.toDataURL('image/jpeg', 0.75);
                      if (dataUrl && dataUrl.startsWith('data:image/')) {
                        setThumbDataUrl(id, dataUrl);
                        const img = document.createElement('img');
                        img.className = 'thumbMedia';
                        img.loading = 'lazy';
                        img.alt = '';
                        img.src = dataUrl;
                        v.replaceWith(img);
                      }
                    }
                  }
                } catch {}
              }

              const status = v.parentElement?.querySelector('.thumbStatus');
              if (status) status.classList.add('hidden');
            }, { once: true });
          }
        }, { root: null, rootMargin: '200px', threshold: 0.01 });

        vids.forEach((v) => io.observe(v));
      }

      // Legacy client-side thumbnail generation (unused now that server handles it, but kept for reference if reverted)
      function initImageThumbs() {
         return; // Deprecated.
      }

      function renderPlayer() {
        const id = state.current?.id;
        const item = state.current?.item;
        const vrLink = item?.isVr ? `<a href="#" onclick="window.__openBest('${id}');return false;">Open in VR player</a>` : '';
        el('app').innerHTML = `
          <header>
            <h1>MediaViewer</h1>
            <div class="small">Player</div>
          </header>
          <div class="playerWrap">
            <div class="topbar">
              <a href="#" onclick="window.__back();return false;">Back</a>
              ${vrLink}
              <span class="small">${escapeHtml(state.current?.item?.filename || '')}</span>
            </div>
            <video id="v" controls autoplay playsinline src="/api/media/${id}/stream"></video>
            <div class="small" id="fs"></div>
          </div>
        `;

        const v = el('v');
        const fps = 30;
        const mediaId = id;

        const push = (e) => {
          if (!(v instanceof HTMLVideoElement)) return;
          const timeMs = Math.round((v.currentTime || 0) * 1000);
          const frame = Math.max(0, Math.floor((v.currentTime || 0) * fps));
          const force = e && (e.type === 'play' || e.type === 'pause' || e.type === 'seeked');
          sendSyncUpdate({ mediaId, timeMs, paused: v.paused, fps, frame }, force);
        };

        if (v instanceof HTMLVideoElement) {
          v.addEventListener('play', push);
          v.addEventListener('pause', push);
          v.addEventListener('seeked', push);
          v.addEventListener('timeupdate', push);
        }

        // Show if funscript exists.
        fetch(`/api/media/${id}/funscript`).then(r => r.ok ? r.json() : null).then((j) => {
          if (!j) return;
          el('fs').textContent = `Funscript loaded: ${j.actions?.length ?? 0} actions`;
        }).catch(() => {});
      }

      function renderVr() {
        const id = state.current?.id;
        const filename = escapeHtml(state.current?.item?.filename || '');
        el('app').innerHTML = `
          <header>
            <h1>MediaViewer</h1>
            <div class="small">VR Player</div>
          </header>
          <div class="playerWrap">
            <div class="topbar">
              <a href="#" onclick="window.__back();return false;">Back</a>
              <a href="#" onclick="window.__openPlayer('${id}');return false;">Open Normal</a>
              <span class="small">${filename}</span>
            </div>
            <div class="small">Uses WebXR via A-Frame. If you have a headset, enter VR from the button.</div>
            <script src="https://aframe.io/releases/1.6.0/aframe.min.js"><\/script>
            <a-scene embedded vr-mode-ui="enabled: true">
              <a-assets>
                <video id="vvr" crossorigin="anonymous" autoplay loop="false" playsinline webkit-playsinline src="/api/media/${id}/stream"></video>
              </a-assets>
              <a-plane position="0 1.6 -2" rotation="0 0 0" width="3.2" height="1.8" material="shader: flat; src: #vvr"></a-plane>
              <a-camera position="0 1.6 0"></a-camera>
            </a-scene>
          </div>
        `;

        // Set up sync for VR player
        const vvr = el('vvr');
        const fps = 30;
        const mediaId = id;

        const push = (e) => {
          if (!(vvr instanceof HTMLVideoElement)) return;
          const timeMs = Math.round((vvr.currentTime || 0) * 1000);
          const frame = Math.max(0, Math.floor((vvr.currentTime || 0) * fps));
          const force = e && (e.type === 'play' || e.type === 'pause' || e.type === 'seeked');
          sendSyncUpdate({ mediaId, timeMs, paused: vvr.paused, fps, frame }, force);
        };

        if (vvr instanceof HTMLVideoElement) {
          vvr.addEventListener('play', push);
          vvr.addEventListener('pause', push);
          vvr.addEventListener('seeked', push);
          vvr.addEventListener('timeupdate', push);
        }
      }

      function render() {
        if (state.view === 'grid') return renderGrid();
        if (state.view === 'player') return renderPlayer();
        if (state.view === 'vr') return renderVr();
      }

      window.__openPlayer = async (id) => {
        const item = await getItemInfo(id);
        setView('player', { id, item });
        sendSyncUpdate({ mediaId: id, timeMs: 0, paused: true, fps: 30, frame: 0 });
      };
      window.__openVr = async (id) => {
        const item = await getItemInfo(id);
        setView('vr', { id, item });
      };

      function uaHas(substr) {
        try { return navigator.userAgent.toLowerCase().includes(substr.toLowerCase()); } catch { return false; }
      }

      window.__openBest = async (id) => {
        const item = await getItemInfo(id);
        const isVr = Boolean(item?.isVr);

        if (!isVr) {
          await window.__openPlayer(id);
          return;
        }

        // In HereSphere, the intended flow is to open a HereSphere per-video JSON endpoint.
        // Include sessionId so the server can broadcast VR sync selection.
        if (uaHas('heresphere')) {
          window.location.href = `/heresphere/video/${encodeURIComponent(id)}?sessionId=${encodeURIComponent(state.wsSessionId || 'default')}`;
          return;
        }

        // If we're inside DeoVR, navigate directly to JSON. The browser will handle it.
        if (uaHas('deovr')) {
          window.location.href = `/deovr/video/${id}`;
          return;
        }

        // Default: our built-in WebXR/A-Frame view works in VR-capable browsers and still shows a usable fallback in 2D.
        await window.__openVr(id);
      };

      window.__openDeoVrLibrary = () => {
        const url = new URL('/deovr', window.location.origin).toString();
        window.location.href = `deovr://${url}`;
      };
      window.__openDeoVrVideo = (id) => {
        const url = new URL(`/deovr/video/${id}`, window.location.origin).toString();
        window.location.href = `deovr://${url}`;
      };
      window.__openHereSphereLibrary = () => {
        const url = new URL(`/heresphere?sessionId=${encodeURIComponent(state.wsSessionId || 'default')}`, window.location.origin).toString();
        if (uaHas('heresphere')) {
          window.location.href = url;
        } else {
          window.open(url, '_blank', 'noopener');
        }
      };
      window.__openHereSphereVideo = (id) => {
        const safeId = encodeURIComponent(id);
        const sessionId = encodeURIComponent(state.wsSessionId || 'default');
        const url = new URL(`/heresphere/video/${safeId}?sessionId=${sessionId}`, window.location.origin).toString();
        if (uaHas('heresphere')) {
          window.location.href = url;
        } else {
          window.open(url, '_blank', 'noopener');
        }
      };

      window.__back = async () => {
        setView('grid', null);
      };

      (async () => {
        ensureClientId();
        loadPrefs();
        connectWs();
        await loadList();
        render();
      })();
    </script>
  </head>
  <body>
    <div id="app"></div>
  </body>
</html>
