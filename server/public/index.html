<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>MediaViewer</title>
    <link rel="stylesheet" href="/styles.css" />
    <script>
      const state = {
        q: '',
        page: 1,
        pageSize: 12,
        total: 0,
        items: [],
        funFilter: 'all', // all | with | without
        vrFilter: 'all', // all | vr | nonvr
        gridMin: 180,
        sort: 'newest', // newest | lenAsc | lenDesc
        lenMinSec: 0,
        durationsSec: {},
        thumbCache: {},
        _durToken: 0,
        view: 'grid', // grid | player | vr
        current: null,
        clientId: null,
        ws: null,
        wsConnected: false,
        wsSessionId: 'default',
        _applyingRemoteUntil: 0,
        _lastSentAt: 0,
        lastRemoteSync: null,
        lastRemoteAt: 0,
        thumbVer: 0,
      };

      function el(id) { return document.getElementById(id); }

      async function apiJson(url, opts) {
        const res = await fetch(url, opts);
        if (!res.ok) throw new Error(await res.text());
        return res.json();
      }

      function setView(view, current = null) {
        state.view = view;
        state.current = current;
        render();
      }

      function ensureClientId() {
        if (state.clientId) return state.clientId;
        const key = 'mvClientId';
        const existing = window.localStorage.getItem(key);
        if (existing) {
          state.clientId = existing;
          return existing;
        }
        const id = 'web-' + Math.random().toString(16).slice(2);
        window.localStorage.setItem(key, id);
        state.clientId = id;
        return id;
      }

      function loadPrefs() {
        try {
          const saved = window.localStorage.getItem('mvPrefs');
          if (saved) {
            const prefs = JSON.parse(saved);
            if (typeof prefs.gridMin === 'number' && prefs.gridMin >= 120 && prefs.gridMin <= 360) {
              state.gridMin = prefs.gridMin;
            }
          }
        } catch {
          // ignore parse errors
        }
      }

      function savePrefs() {
        try {
          window.localStorage.setItem('mvPrefs', JSON.stringify({
            gridMin: state.gridMin,
          }));
        } catch {
          // ignore storage errors
        }
      }

      function loadPrefs() {
        try {
          const saved = window.localStorage.getItem('mvPrefs');
          if (saved) {
            const prefs = JSON.parse(saved);
            if (typeof prefs.gridMin === 'number' && prefs.gridMin >= 120 && prefs.gridMin <= 360) {
              state.gridMin = prefs.gridMin;
            }
          }
        } catch {
          // ignore parse errors
        }
      }

      function savePrefs() {
        try {
          window.localStorage.setItem('mvPrefs', JSON.stringify({
            gridMin: state.gridMin,
          }));
        } catch {
          // ignore storage errors
        }
      }

      function wsUrlFromHttp(base) {
        const u = new URL(base);
        u.protocol = u.protocol === 'https:' ? 'wss:' : 'ws:';
        u.pathname = '/ws';
        u.search = '';
        u.hash = '';
        return u.toString();
      }

      function connectWs() {
        ensureClientId();
        if (state.ws && (state.ws.readyState === 0 || state.ws.readyState === 1)) return;

        const wsUrl = wsUrlFromHttp(window.location.origin);
        const ws = new WebSocket(wsUrl);
        state.ws = ws;

        ws.addEventListener('open', () => {
          state.wsConnected = true;
          ws.send(JSON.stringify({ type: 'sync:hello', clientId: state.clientId, sessionId: state.wsSessionId }));
          updateSyncStatus();
        });

        ws.addEventListener('close', () => {
          state.wsConnected = false;
          updateSyncStatus();
          window.setTimeout(() => connectWs(), 1000);
        });

        ws.addEventListener('message', (evt) => {
          let msg;
          try { msg = JSON.parse(String(evt.data)); } catch { return; }
          if (!msg || msg.type !== 'sync:state' || !msg.state) return;
          applyRemoteSyncState(msg.state);
        });
      }

      function sendSyncUpdate(update, force) {
        if (!state.wsConnected || !state.ws || state.ws.readyState !== 1) return;
        if (Date.now() < state._applyingRemoteUntil) return;
        const now = Date.now();
        if (!force && now - state._lastSentAt < 200) return;
        state._lastSentAt = now;

        state.ws.send(JSON.stringify({
          type: 'sync:update',
          sessionId: state.wsSessionId,
          clientId: state.clientId,
          ...update,
        }));
      }

      async function getItemInfo(id) {
        const found = state.items.find((x) => x.id === id);
        if (found) return found;
        try {
          const info = await apiJson(`/api/media/${id}/fileinfo`);
          return {
            id: info.id,
            filename: info.filename,
            relPath: info.relPath,
            mediaType: info.mediaType,
            hasFunscript: info.hasFunscript,
            isVr: info.isVr,
          };
        } catch {
          return { id, filename: '', relPath: '', mediaType: 'video', hasFunscript: false, isVr: false };
        }
      }

      async function applyRemoteSyncState(remote) {
        if (!remote) return;
        if (remote.fromClientId && remote.fromClientId === state.clientId) return;

        state.lastRemoteSync = remote;
        state.lastRemoteAt = Date.now();
        updateSyncStatus();

        // Do not auto-navigate away from the grid when opening the WebUI.
        // Sync-following only applies once the user is already in player/vr.
        if (state.view === 'grid') return;

        if (!remote.mediaId) return;

        const id = String(remote.mediaId);
        const item = await getItemInfo(id);

        // If different media, follow it (only while already in a player view).
        if (state.current?.id !== id) {
          state._applyingRemoteUntil = Date.now() + 800;
          if (item?.isVr) {
            // For integrated WebVR support.
            setView('vr', { id, item });
          } else {
            setView('player', { id, item });
          }
          // Wait a tick for DOM.
          await new Promise((r) => setTimeout(r, 0));
        }

        const v = document.getElementById('v') || document.getElementById('vvr');
        if (!(v instanceof HTMLVideoElement)) return;

        state._applyingRemoteUntil = Date.now() + 800;

        const targetTime = Math.max(0, (Number(remote.timeMs) || 0) / 1000);
        if (Number.isFinite(v.currentTime) && Math.abs(v.currentTime - targetTime) > 0.5) {
          try { v.currentTime = targetTime; } catch {}
        }

        const paused = Boolean(remote.paused);
        if (paused) {
          try { v.pause(); } catch {}
        } else {
          try { await v.play(); } catch {}
        }
      }

      function formatPageLabel() {
        const maxPage = Math.max(1, Math.ceil(state.total / state.pageSize));
        return `Page ${state.page} / ${maxPage} (${state.total} items)`;
      }
      function generatePageButtons() {
        const maxPage = Math.max(1, Math.ceil(state.total / state.pageSize));
        const current = state.page;
        const buttons = [];
        
        // Calculate which page numbers to show (up to 5)
        let startPage = Math.max(1, current - 2);
        let endPage = Math.min(maxPage, startPage + 4);
        
        // Adjust if we're near the end
        if (endPage - startPage < 4) {
          startPage = Math.max(1, endPage - 4);
        }
        
        for (let i = startPage; i <= endPage; i++) {
          const active = i === current ? ' active' : '';
          buttons.push(`<button class="btn page-btn${active}" data-page="${i}">${i}</button>`);
        }
        
        return buttons.join('');
      }
      function thumbKey(id) {
        return `mvThumb:${id}`;
      }

      function getThumbDataUrl(id) {
        if (state.thumbCache[id]) return state.thumbCache[id];
        try {
          const v = window.sessionStorage.getItem(thumbKey(id));
          if (v) {
            state.thumbCache[id] = v;
            return v;
          }
        } catch {}
        return null;
      }

      function setThumbDataUrl(id, dataUrl) {
        state.thumbCache[id] = dataUrl;
        try {
          window.sessionStorage.setItem(thumbKey(id), dataUrl);
        } catch {}
      }

      async function loadList() {
        const q = encodeURIComponent(state.q);
        const params = new URLSearchParams();
        params.set('q', state.q);
        params.set('page', String(state.page));
        params.set('pageSize', String(state.pageSize));
        params.set('mediaType', 'video');
        if (state.funFilter === 'with') params.set('hasFunscript', '1');
        if (state.funFilter === 'without') params.set('hasFunscript', '0');
        if (state.vrFilter === 'vr') params.set('isVr', '1');
        if (state.vrFilter === 'nonvr') params.set('isVr', '0');

        const data = await apiJson(`/api/media?${params.toString()}`);
        state.total = data.total;
        state.items = data.items;
      }

      async function doSearch(value) {
        state.q = value;
        state.page = 1;
        await loadList();
        render();
      }

      function formatDuration(seconds) {
        if (!Number.isFinite(seconds) || seconds <= 0) return '--:--';
        const total = Math.round(seconds);
        const h = Math.floor(total / 3600);
        const m = Math.floor((total % 3600) / 60);
        const s = total % 60;
        if (h > 0) return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        return `${m}:${String(s).padStart(2, '0')}`;
      }

      function formatBytes(bytes) {
        const b = Number(bytes);
        if (!Number.isFinite(b) || b < 0) return '--';
        const units = ['B', 'KB', 'MB', 'GB', 'TB'];
        let n = b;
        let u = 0;
        while (n >= 1024 && u < units.length - 1) {
          n /= 1024;
          u++;
        }
        const digits = u === 0 ? 0 : (n >= 10 ? 1 : 2);
        return `${n.toFixed(digits)} ${units[u]}`;
      }

      function formatDateTime(ms) {
        const t = Number(ms);
        if (!Number.isFinite(t) || t <= 0) return '--';
        try {
          return new Date(t).toLocaleString();
        } catch {
          return '--';
        }
      }

      function updateSyncStatus() {
        const elSync = document.getElementById('syncStatus');
        if (!elSync) return;

        const parts = [];
        parts.push(state.wsConnected ? 'Sync: connected' : 'Sync: disconnected');
        parts.push(`session: ${state.wsSessionId || 'default'}`);

        if (state.lastRemoteSync && state.lastRemoteAt) {
          const ageMs = Math.max(0, Date.now() - state.lastRemoteAt);
          const from = state.lastRemoteSync.fromClientId ? `from ${state.lastRemoteSync.fromClientId}` : 'from remote';
          const paused = Boolean(state.lastRemoteSync.paused);
          const at = formatDuration((Number(state.lastRemoteSync.timeMs) || 0) / 1000);
          parts.push(`${from} · ${paused ? 'paused' : 'playing'} · ${at} · ${Math.round(ageMs / 1000)}s ago`);
        }

        elSync.textContent = parts.join(' · ');
      }

      function getDurationSec(id) {
        const v = state.durationsSec[id];
        return Number.isFinite(v) ? v : null;
      }

      function getGridItems() {
        let items = [...state.items];
        if (state.lenMinSec > 0) {
          items = items.filter((it) => {
            const d = getDurationSec(it.id);
            return d !== null && d >= state.lenMinSec;
          });
        }

        if (state.sort === 'lenAsc' || state.sort === 'lenDesc') {
          const dir = state.sort === 'lenAsc' ? 1 : -1;
          items.sort((a, b) => {
            const da = getDurationSec(a.id);
            const db = getDurationSec(b.id);

            if (da === null && db === null) return 0;
            if (da === null) return 1;
            if (db === null) return -1;
            return (da - db) * dir;
          });
        }

        return items;
      }

      function card(item) {
        const tagF = item.hasFunscript
          ? `<span class="tag tag--good">funscript</span>`
          : `<span class="tag tag--bad">no funscript</span>`;
        const tagT = `<span class="tag">${item.mediaType}</span>`;
        const tagVr = item.isVr
          ? `<span class="tag tag--vr">vr</span>`
          : '';

        const durationTag = item.mediaType === 'video'
          ? `<span class="tag mvLen" data-id="${item.id}">${formatDuration(getDurationSec(item.id) ?? NaN)}</span>`
          : '';

        // Use server-side generated thumbnail for video.
        const thumbUrl = item.mediaType === 'image' 
          ? `/api/media/${item.id}/stream`
          : `/api/media/${item.id}/thumb?v=${state.thumbVer}`;

        const placeholderImg = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';

        // For videos, defer requesting thumbs until the card is near-visible.
        // This prevents large bursts of thumbnail generation from blocking other API calls.
        const thumb = item.mediaType === 'video'
          ? `<img class="thumbMedia" loading="lazy" src="${placeholderImg}" data-src="${thumbUrl}" alt="${escapeHtml(item.filename)}" />`
          : `<img class="thumbMedia" loading="lazy" src="${thumbUrl}" alt="${escapeHtml(item.filename)}" />`;

        const thumbStatus = `<div class="thumbStatus">Loading…</div>`;

        return `
          <div class="card" role="button" tabindex="0" data-open-id="${escapeHtml(item.id)}" aria-label="Open: ${escapeHtml(item.filename)}">
            <div class="thumb">
              ${thumb}
              ${thumbStatus}
            </div>
            <div class="meta">
              <div class="name">${escapeHtml(item.filename)}</div>
              <div class="tags">${tagT}${tagVr}${tagF}${durationTag}</div>
            </div>
          </div>
        `;
      }

      function escapeHtml(s) {
        return String(s)
          .replaceAll('&', '&amp;')
          .replaceAll('<', '&lt;')
          .replaceAll('>', '&gt;')
          .replaceAll('"', '&quot;')
          .replaceAll("'", '&#039;');
      }

      async function openById(id) {
        const item = state.items.find((x) => x.id === id) || (await apiJson(`/api/media/${id}/fileinfo`).then(() => ({ id })));
        setView('player', { id, item });
      }

      function renderGrid() {
        const active = document.activeElement;
        const shouldRestoreQ = (active instanceof HTMLInputElement) && active.id === 'q';
        const restoreStart = shouldRestoreQ ? active.selectionStart : null;
        const restoreEnd = shouldRestoreQ ? active.selectionEnd : null;

        const visible = getGridItems();
        el('app').innerHTML = `
          <header>
            <h1>MediaViewer</h1>
            <div class="search"><input id="q" placeholder="Search by filename" value="${escapeHtml(state.q)}" /></div>
            <select id="pageSize" title="Items per page">
              ${[12, 24, 48, 96].map((n) => `<option value="${n}" ${n === state.pageSize ? 'selected' : ''}>${n}/page</option>`).join('')}
            </select>
            <select id="funFilter" title="Funscript filter">
              <option value="all" ${state.funFilter === 'all' ? 'selected' : ''}>All videos</option>
              <option value="with" ${state.funFilter === 'with' ? 'selected' : ''}>With funscript</option>
              <option value="without" ${state.funFilter === 'without' ? 'selected' : ''}>Without funscript</option>
            </select>
            <select id="vrFilter" title="VR filter">
              <option value="all" ${state.vrFilter === 'all' ? 'selected' : ''}>All</option>
              <option value="vr" ${state.vrFilter === 'vr' ? 'selected' : ''}>VR only</option>
              <option value="nonvr" ${state.vrFilter === 'nonvr' ? 'selected' : ''}>Non-VR only</option>
            </select>
            <select id="sort" title="Sort">
              <option value="newest" ${state.sort === 'newest' ? 'selected' : ''}>Newest</option>
              <option value="lenAsc" ${state.sort === 'lenAsc' ? 'selected' : ''}>Length (short → long)</option>
              <option value="lenDesc" ${state.sort === 'lenDesc' ? 'selected' : ''}>Length (long → short)</option>
            </select>
            <select id="lenMin" title="Minimum length">
              <option value="0" ${state.lenMinSec === 0 ? 'selected' : ''}>Any length</option>
              <option value="120" ${state.lenMinSec === 120 ? 'selected' : ''}>>= 2 min</option>
              <option value="300" ${state.lenMinSec === 300 ? 'selected' : ''}>>= 5 min</option>
              <option value="600" ${state.lenMinSec === 600 ? 'selected' : ''}>>= 10 min</option>
              <option value="1200" ${state.lenMinSec === 1200 ? 'selected' : ''}>>= 20 min</option>
              <option value="1800" ${state.lenMinSec === 1800 ? 'selected' : ''}>>= 30 min</option>
            </select>
            <button class="btn" id="gridDec" title="Smaller grid">-</button>
            <button class="btn" id="gridInc" title="Larger grid">+</button>
            <button class="btn" id="scan">Rescan</button>
            <button class="btn" id="regenThumbs" title="Clear server thumbnail cache and refresh">Regenerate thumbs</button>
            <button class="btn" id="deovrLib" title="Open library in DeoVR">DeoVR Library</button>
            <button class="btn" id="hsLib" title="Open HereSphere library JSON">HereSphere Library</button>
            <div class="opStatus" id="opStatus" style="display:none">
              <progress id="opProgress"></progress>
              <span class="small" id="opText"></span>
            </div>
          </header>
          <main>
            <div class="small">${formatPageLabel()}</div>
            <div class="grid" id="grid">${visible.map(card).join('')}</div>
            <div class="pager">
              <button class="btn" id="first">First</button>
              <button class="btn" id="prev">Prev</button>
              <div class="page-numbers" id="pageNumbers">${generatePageButtons()}</div>
              <button class="btn" id="next">Next</button>
              <button class="btn" id="last">Last</button>
            </div>
          </main>
        `;

        el('grid').style.setProperty('--card-min', `${state.gridMin}px`);

        el('q').addEventListener('input', (e) => {
          const val = e.target.value;
          window.clearTimeout(window.__qT);
          window.__qT = window.setTimeout(() => doSearch(val), 200);
        });

        el('pageSize').addEventListener('change', async (e) => {
          state.pageSize = Number(e.target.value) || 48;
          state.page = 1;
          await loadList();
          render();
        });

        el('funFilter').addEventListener('change', async (e) => {
          state.funFilter = e.target.value;
          state.page = 1;
          await loadList();
          render();
        });

        el('vrFilter').addEventListener('change', async (e) => {
          state.vrFilter = e.target.value;
          state.page = 1;
          await loadList();
          render();
        });

        el('sort').addEventListener('change', async (e) => {
          state.sort = e.target.value;
          render();
        });

        el('lenMin').addEventListener('change', async (e) => {
          state.lenMinSec = Number(e.target.value) || 0;
          render();
        });

        el('gridDec').addEventListener('click', () => {
          state.gridMin = Math.max(120, state.gridMin - 20);
          el('grid').style.setProperty('--card-min', `${state.gridMin}px`);
          savePrefs();
        });

        el('gridInc').addEventListener('click', () => {
          state.gridMin = Math.min(360, state.gridMin + 20);
          el('grid').style.setProperty('--card-min', `${state.gridMin}px`);
          savePrefs();
        });

        const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

        function opShow(text, mode) {
          const wrap = el('opStatus');
          const prog = el('opProgress');
          const t = el('opText');
          wrap.style.display = 'flex';
          t.textContent = text || '';

          // mode: 'indeterminate' | { value, max }
          if (mode && typeof mode === 'object') {
            prog.max = Number(mode.max) || 1;
            prog.value = Number(mode.value) || 0;
          } else {
            prog.removeAttribute('value');
          }
        }

        function opHide() {
          const wrap = el('opStatus');
          wrap.style.display = 'none';
        }

        async function waitForScanCompletion() {
          // Poll server progress until scan completes.
          for (;;) {
            const p = await apiJson('/api/scan/progress');
            if (p && p.isScanning) {
              const msg = p.message || 'Scanning...';
              const scanned = typeof p.scanned === 'number' ? p.scanned : 0;
              opShow(`${msg} (${scanned} files)`, 'indeterminate');
              await sleep(500);
              continue;
            }

            const doneMsg = (p && p.message) ? p.message : 'Scan complete';
            opShow(doneMsg, { value: 1, max: 1 });
            await sleep(800);
            opHide();
            return;
          }
        }

        el('scan').addEventListener('click', async () => {
          el('scan').disabled = true;
          try {
            opShow('Starting scan...', 'indeterminate');
            await apiJson('/api/scan', { method: 'POST' });
            await waitForScanCompletion();
            await loadList();
            render();
          } finally {
            el('scan').disabled = false;
          }
        });

        el('regenThumbs').addEventListener('click', async () => {
          const btn = el('regenThumbs');
          btn.disabled = true;
          try {
            opShow('Regenerating thumbs...', 'indeterminate');
            await apiJson('/api/cache/clear', { method: 'POST' });
            // Bust browser cache for /api/media/:id/thumb
            state.thumbVer = (state.thumbVer + 1) | 0;
            render();
            opShow('Thumbnails refreshed', { value: 1, max: 1 });
            await sleep(800);
            opHide();
          } finally {
            btn.disabled = false;
          }
        });

        el('deovrLib').addEventListener('click', () => window.__openDeoVrLibrary());
        el('hsLib').addEventListener('click', () => window.__openHereSphereLibrary());
        if (uaHas('deovr')) {
          // In DeoVR's in-app browser, a deovr:// deep link isn't useful.
          el('deovrLib').style.display = 'none';
          el('hsLib').style.display = 'none';
          el('regenThumbs').style.display = 'none';
        }
        if (uaHas('heresphere')) {
          // Keep the HereSphere library link visible so users can open it and use
          // HereSphere's Web Stream / Web API importer.
          el('deovrLib').style.display = 'none';
          el('regenThumbs').style.display = 'none';
        }

        const maxPage = Math.max(1, Math.ceil(state.total / state.pageSize));
        el('first').disabled = state.page <= 1;
        el('prev').disabled = state.page <= 1;
        el('next').disabled = state.page >= maxPage;
        el('last').disabled = state.page >= maxPage;
        
        el('first').addEventListener('click', async () => {
          state.page = 1;
          await loadList();
          render();
        });
        
        el('prev').addEventListener('click', async () => {
          state.page = Math.max(1, state.page - 1);
          await loadList();
          render();
        });
        
        el('next').addEventListener('click', async () => {
          state.page = Math.min(maxPage, state.page + 1);
          await loadList();
          render();
        });
        
        el('last').addEventListener('click', async () => {
          state.page = maxPage;
          await loadList();
          render();
        });
        
        // Page number buttons
        const pageButtons = document.querySelectorAll('.page-btn');
        for (const btn of pageButtons) {
          btn.addEventListener('click', async () => {
            const page = parseInt(btn.getAttribute('data-page'), 10);
            if (page && page !== state.page) {
              state.page = page;
              await loadList();
              render();
            }
          });
        }

        // Card click-to-open (entire card).
        const cards = Array.from(document.querySelectorAll('.card[data-open-id]'));
        for (const c of cards) {
          c.addEventListener('click', () => {
            const id = c.getAttribute('data-open-id');
            if (id) window.__openBest(id);
          });
          c.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              const id = c.getAttribute('data-open-id');
              if (id) window.__openBest(id);
            }
          });
        }

        initThumbsForGrid();

        if (shouldRestoreQ) {
          const qEl = el('q');
          if (qEl instanceof HTMLInputElement) {
            qEl.focus({ preventScroll: true });
            const len = qEl.value.length;
            const s = typeof restoreStart === 'number' ? Math.min(restoreStart, len) : len;
            const e = typeof restoreEnd === 'number' ? Math.min(restoreEnd, len) : len;
            try { qEl.setSelectionRange(s, e); } catch {}
          }
        }

        prefetchDurationsForPage();
      }

      function initThumbsForGrid() {
        const imgs = Array.from(document.querySelectorAll('img.thumbMedia'));
        for (const img of imgs) {
          const status = img.parentElement?.querySelector('.thumbStatus');
          if (!status) continue;

          // Default: show loading.
          status.textContent = 'Loading…';
          status.classList.remove('hidden');

          const onLoad = () => {
            status.classList.add('hidden');
          };
          const onError = () => {
            status.textContent = "Couldn't load";
            status.classList.remove('hidden');
          };

          img.addEventListener('load', onLoad, { once: true });
          img.addEventListener('error', onError, { once: true });

          // If already loaded (from cache), update immediately.
          try {
            if (img.complete && img.naturalWidth > 0) onLoad();
          } catch {}
        }

        // Throttled loader for deferred thumbs (video thumbs only).
        const deferred = Array.from(document.querySelectorAll('img.thumbMedia[data-src]'));
        if (!deferred.length) return;

        const queue = [];
        let inFlight = 0;
        const maxInFlight = 4;

        const pump = () => {
          while (inFlight < maxInFlight && queue.length) {
            const img = queue.shift();
            if (!(img instanceof HTMLImageElement) || !img.isConnected) continue;

            const src = img.getAttribute('data-src');
            if (!src) continue;
            img.removeAttribute('data-src');

            inFlight++;
            const done = () => {
              inFlight = Math.max(0, inFlight - 1);
              pump();
            };
            img.addEventListener('load', done, { once: true });
            img.addEventListener('error', done, { once: true });
            img.src = src;
          }
        };

        const io = new IntersectionObserver((entries) => {
          for (const ent of entries) {
            if (!ent.isIntersecting) continue;
            const img = ent.target;
            io.unobserve(img);
            queue.push(img);
          }
          pump();
        }, { root: null, rootMargin: '300px', threshold: 0.01 });

        for (const img of deferred) io.observe(img);
      }

      async function prefetchDurationsForPage() {
        // Skip duration prefetch on VR browsers (HereSphere, DeoVR, Quest) to save resources/decoders.
        if (uaHas('heresphere') || uaHas('deovr') || uaHas('oculus') || uaHas('android')) return;

        const token = ++state._durToken;
        const ids = state.items
          .filter((it) => it.mediaType === 'video')
          .map((it) => it.id)
          .filter((id) => getDurationSec(id) === null);

        if (!ids.length) return;

        const concurrency = 4;
        let idx = 0;
        const workers = Array.from({ length: concurrency }, async () => {
          while (idx < ids.length) {
            const id = ids[idx++];
            if (token !== state._durToken) return;
            const d = await probeDuration(id);
            if (token !== state._durToken) return;
            if (typeof d === 'number' && Number.isFinite(d) && d > 0) {
              state.durationsSec[id] = d;
              const tag = document.querySelector(`.mvLen[data-id="${CSS.escape(id)}"]`);
              if (tag) tag.textContent = formatDuration(d);
            }
          }
        });

        await Promise.all(workers);

        // If sorting/filtering depends on duration, re-render once after probes.
        if (token === state._durToken && (state.sort !== 'newest' || state.lenMinSec > 0)) {
          render();
        }
      }

      function probeDuration(id) {
        return new Promise((resolve) => {
          const v = document.createElement('video');
          v.preload = 'metadata';
          v.muted = true;
          v.playsInline = true;
          v.src = `/api/media/${id}/stream`;

          const done = (val) => {
            try {
              v.removeAttribute('src');
              v.load();
            } catch {}
            resolve(val);
          };

          v.addEventListener('loadedmetadata', () => done(v.duration), { once: true });
          v.addEventListener('error', () => done(null), { once: true });
        });
      }

      // Legacy client-side thumbnail generation (unused now that server handles it, but kept for reference if reverted)
      function initVideoThumbs() {
        return; // Deprecated: server now provides /thumb endpoint.
        if (!vids.length) return;

        const io = new IntersectionObserver((entries) => {
          for (const ent of entries) {
            if (!ent.isIntersecting) continue;
            const v = ent.target;
            io.unobserve(v);

            const src = v.getAttribute('data-src');
            if (!src) continue;
            v.src = src;
            v.addEventListener('loadeddata', () => {
              try {
                // Jump a little forward so we don't always show a black first frame.
                v.currentTime = 1;
              } catch {}
            }, { once: true });

            v.addEventListener('error', () => {
              const status = v.parentElement?.querySelector('.thumbStatus');
              if (status) {
                status.textContent = 'Preview unavailable';
                status.classList.remove('hidden');
              }
            }, { once: true });

            v.addEventListener('seeked', () => {
              try { v.pause(); } catch {}

              const id = v.getAttribute('data-id') || '';
              if (id && !getThumbDataUrl(id)) {
                try {
                  const w = Math.max(1, v.videoWidth || 0);
                  const h = Math.max(1, v.videoHeight || 0);
                  if (w > 1 && h > 1) {
                    const c = document.createElement('canvas');
                    c.width = w;
                    c.height = h;
                    const ctx = c.getContext('2d');
                    if (ctx) {
                      ctx.drawImage(v, 0, 0, w, h);
                      const dataUrl = c.toDataURL('image/jpeg', 0.75);
                      if (dataUrl && dataUrl.startsWith('data:image/')) {
                        setThumbDataUrl(id, dataUrl);
                        const img = document.createElement('img');
                        img.className = 'thumbMedia';
                        img.loading = 'lazy';
                        img.alt = '';
                        img.src = dataUrl;
                        v.replaceWith(img);
                      }
                    }
                  }
                } catch {}
              }

              const status = v.parentElement?.querySelector('.thumbStatus');
              if (status) status.classList.add('hidden');
            }, { once: true });
          }
        }, { root: null, rootMargin: '200px', threshold: 0.01 });

        vids.forEach((v) => io.observe(v));
      }

      // Legacy client-side thumbnail generation (unused now that server handles it, but kept for reference if reverted)
      function initImageThumbs() {
         return; // Deprecated.
      }

      function renderPlayer() {
        const id = state.current?.id;
        const item = state.current?.item;
        const vrLink = item?.isVr ? `<a href="#" onclick="window.__openBest('${id}');return false;">Open in VR player</a>` : '';
        const filename = escapeHtml(item?.filename || '');
        const tagVr = item?.isVr ? `<span class="tag tag--vr">vr</span>` : '';
        const tagFun = item?.hasFunscript
          ? `<span class="tag tag--good">funscript</span>`
          : `<span class="tag tag--bad">no funscript</span>`;
        el('app').innerHTML = `
          <header>
            <h1>MediaViewer</h1>
            <div class="small">Player</div>
          </header>
          <div class="playerWrap">
            <div class="topbar">
              <a href="#" onclick="window.__back();return false;">Back</a>
              ${vrLink}
              <span class="small playerTitle">${filename}</span>
            </div>
            <div class="playerLayout">
              <div class="playerMain">
                <video class="playerVideo" id="v" controls autoplay playsinline src="/api/media/${id}/stream"></video>
                <div class="small playerStatus" id="syncStatus"></div>
              </div>
              <aside class="playerSide">
                <div class="panel">
                  <div class="panelTitle">Details</div>
                  <div class="tags playerTags">${tagVr}${tagFun}</div>
                  <div class="kv" id="details">
                    <div class="kvRow"><div class="kvKey">Filename</div><div class="kvVal">${filename}</div></div>
                    <div class="kvRow"><div class="kvKey">Path</div><div class="kvVal" id="d-rel">${escapeHtml(item?.relPath || '')}</div></div>
                    <div class="kvRow"><div class="kvKey">Duration</div><div class="kvVal" id="d-dur">Loading…</div></div>
                    <div class="kvRow"><div class="kvKey">Size</div><div class="kvVal" id="d-size">Loading…</div></div>
                    <div class="kvRow"><div class="kvKey">Modified</div><div class="kvVal" id="d-mod">Loading…</div></div>
                    <div class="kvRow"><div class="kvKey">Funscript</div><div class="kvVal" id="d-fs">${item?.hasFunscript ? 'Loading…' : 'None'}</div></div>
                  </div>
                </div>
              </aside>
            </div>
          </div>
        `;

        const v = el('v');
        const fps = 30;
        const mediaId = id;

        const push = (e) => {
          if (!(v instanceof HTMLVideoElement)) return;
          const timeMs = Math.round((v.currentTime || 0) * 1000);
          const frame = Math.max(0, Math.floor((v.currentTime || 0) * fps));
          const force = e && (e.type === 'play' || e.type === 'pause' || e.type === 'seeked');
          sendSyncUpdate({ mediaId, timeMs, paused: v.paused, fps, frame }, force);
        };

        if (v instanceof HTMLVideoElement) {
          v.addEventListener('play', push);
          v.addEventListener('pause', push);
          v.addEventListener('seeked', push);
          v.addEventListener('timeupdate', push);
        }

        updateSyncStatus();

        // Hydrate fileinfo + duration
        Promise.all([
          apiJson(`/api/media/${id}/fileinfo`).catch(() => null),
          apiJson(`/api/media/${id}/probe`).catch(() => null),
        ]).then(([info, probe]) => {
          const rel = document.getElementById('d-rel');
          const dur = document.getElementById('d-dur');
          const size = document.getElementById('d-size');
          const mod = document.getElementById('d-mod');

          if (info) {
            if (rel) rel.textContent = String(info.relPath || '');
            if (size) size.textContent = formatBytes(info.sizeBytes);
            if (mod) mod.textContent = formatDateTime(info.modifiedMs);
          } else {
            if (size) size.textContent = '--';
            if (mod) mod.textContent = '--';
          }

          if (probe && Number.isFinite(Number(probe.durationMs)) && Number(probe.durationMs) > 0) {
            if (dur) dur.textContent = formatDuration(Number(probe.durationMs) / 1000);
          } else {
            if (dur) dur.textContent = '--:--';
          }
        }).catch(() => {
          const dur = document.getElementById('d-dur');
          const size = document.getElementById('d-size');
          const mod = document.getElementById('d-mod');
          if (dur) dur.textContent = '--:--';
          if (size) size.textContent = '--';
          if (mod) mod.textContent = '--';
        });

        // Show if funscript exists.
        if (item?.hasFunscript) {
          fetch(`/api/media/${id}/funscript`).then(r => r.ok ? r.json() : null).then((j) => {
            const fs = document.getElementById('d-fs');
            if (!fs) return;
            if (!j) {
              fs.textContent = 'Unavailable';
              return;
            }
            fs.textContent = `${j.actions?.length ?? 0} actions`;
          }).catch(() => {
            const fs = document.getElementById('d-fs');
            if (fs) fs.textContent = 'Unavailable';
          });
        }
      }

      function renderVr() {
        const id = state.current?.id;
        const filename = escapeHtml(state.current?.item?.filename || '');
        el('app').innerHTML = `
          <header>
            <h1>MediaViewer</h1>
            <div class="small">VR Player</div>
          </header>
          <div class="playerWrap">
            <div class="topbar">
              <a href="#" onclick="window.__back();return false;">Back</a>
              <a href="#" onclick="window.__openPlayer('${id}');return false;">Open Normal</a>
              <span class="small">${filename}</span>
            </div>
            <div class="small">Uses WebXR via A-Frame. If you have a headset, enter VR from the button.</div>
            <script src="https://aframe.io/releases/1.6.0/aframe.min.js"><\/script>
            <a-scene embedded vr-mode-ui="enabled: true">
              <a-assets>
                <video id="vvr" crossorigin="anonymous" autoplay loop="false" playsinline webkit-playsinline src="/api/media/${id}/stream"></video>
              </a-assets>
              <a-plane position="0 1.6 -2" rotation="0 0 0" width="3.2" height="1.8" material="shader: flat; src: #vvr"></a-plane>
              <a-camera position="0 1.6 0"></a-camera>
            </a-scene>
          </div>
        `;

        // Set up sync for VR player
        const vvr = el('vvr');
        const fps = 30;
        const mediaId = id;

        const push = (e) => {
          if (!(vvr instanceof HTMLVideoElement)) return;
          const timeMs = Math.round((vvr.currentTime || 0) * 1000);
          const frame = Math.max(0, Math.floor((vvr.currentTime || 0) * fps));
          const force = e && (e.type === 'play' || e.type === 'pause' || e.type === 'seeked');
          sendSyncUpdate({ mediaId, timeMs, paused: vvr.paused, fps, frame }, force);
        };

        if (vvr instanceof HTMLVideoElement) {
          vvr.addEventListener('play', push);
          vvr.addEventListener('pause', push);
          vvr.addEventListener('seeked', push);
          vvr.addEventListener('timeupdate', push);
        }
      }

      function render() {
        if (state.view === 'grid') return renderGrid();
        if (state.view === 'player') return renderPlayer();
        if (state.view === 'vr') return renderVr();
      }

      window.__openPlayer = async (id) => {
        const item = await getItemInfo(id);
        setView('player', { id, item });
        sendSyncUpdate({ mediaId: id, timeMs: 0, paused: true, fps: 30, frame: 0 });
      };
      window.__openVr = async (id) => {
        const item = await getItemInfo(id);
        setView('vr', { id, item });
      };

      function uaHas(substr) {
        try { return navigator.userAgent.toLowerCase().includes(substr.toLowerCase()); } catch { return false; }
      }

      window.__openBest = async (id) => {
        const item = await getItemInfo(id);
        const isVr = Boolean(item?.isVr);

        if (!isVr) {
          await window.__openPlayer(id);
          return;
        }

        // In HereSphere, the intended flow is to open a HereSphere per-video JSON endpoint.
        // Include sessionId so the server can broadcast VR sync selection.
        if (uaHas('heresphere')) {
          window.location.href = `/heresphere/video/${encodeURIComponent(id)}?sessionId=${encodeURIComponent(state.wsSessionId || 'default')}`;
          return;
        }

        // If we're inside DeoVR, navigate directly to JSON. The browser will handle it.
        if (uaHas('deovr')) {
          window.__openDeoVrVideo(id);
          return;
        }

        // Default: our built-in WebXR/A-Frame view works in VR-capable browsers and still shows a usable fallback in 2D.
        await window.__openVr(id);
      };

      window.__openDeoVrLibrary = () => {
        const sessionId = encodeURIComponent(state.wsSessionId || 'default');
        const url = new URL(`/deovr?sessionId=${sessionId}`, window.location.origin).toString();
        window.location.href = `deovr://${url}`;
      };
      window.__openDeoVrVideo = (id) => {
        const safeId = encodeURIComponent(id);
        const sessionId = encodeURIComponent(state.wsSessionId || 'default');
        const url = new URL(`/deovr/video/${safeId}?sessionId=${sessionId}`, window.location.origin).toString();
        window.location.href = `deovr://${url}`;
      };
      window.__openHereSphereLibrary = () => {
        const url = new URL(`/heresphere?sessionId=${encodeURIComponent(state.wsSessionId || 'default')}`, window.location.origin).toString();
        if (uaHas('heresphere')) {
          window.location.href = url;
        } else {
          window.open(url, '_blank', 'noopener');
        }
      };
      window.__openHereSphereVideo = (id) => {
        const safeId = encodeURIComponent(id);
        const sessionId = encodeURIComponent(state.wsSessionId || 'default');
        const url = new URL(`/heresphere/video/${safeId}?sessionId=${sessionId}`, window.location.origin).toString();
        if (uaHas('heresphere')) {
          window.location.href = url;
        } else {
          window.open(url, '_blank', 'noopener');
        }
      };

      window.__back = async () => {
        setView('grid', null);
      };

      (async () => {
        ensureClientId();
        loadPrefs();
        connectWs();
        await loadList();
        render();
      })();
    </script>
  </head>
  <body>
    <div id="app"></div>
  </body>
</html>
