<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>MediaViewer Desktop</title>
    <style>
      :root { color-scheme: dark; }
      body { margin: 0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; background: #0b0c0f; color: #e6e6e6; }
      header { padding: 12px 16px; border-bottom: 1px solid #222; display: flex; gap: 12px; align-items: center; }
      header h1 { font-size: 14px; margin: 0; }
      .wrap { display: grid; grid-template-columns: 360px 1fr; height: calc(100vh - 50px); }
      .left { border-right: 1px solid #222; padding: 12px; overflow: auto; }
      .right { padding: 12px; overflow: auto; }
      .row { display: flex; gap: 8px; align-items: center; }
      input, select { width: 100%; padding: 10px 12px; border-radius: 8px; border: 1px solid #2a2f3a; background: #11131a; color: #e6e6e6; }
      button { padding: 10px 12px; border-radius: 8px; border: 1px solid #2a2f3a; background: #11131a; color: #e6e6e6; cursor: pointer; }
      button:disabled { opacity: 0.6; cursor: not-allowed; }
      .list { margin-top: 12px; display: grid; gap: 8px; }
      .item { border: 1px solid #222; border-radius: 10px; padding: 10px; cursor: pointer; }
      .item small { opacity: 0.8; }
      video { width: 100%; max-height: 70vh; background: #000; }
      .small { font-size: 12px; opacity: 0.85; }
      .pill { display: inline-block; padding: 2px 8px; border: 1px solid #2a2f3a; border-radius: 999px; font-size: 11px; margin-left: 6px; }
      .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    </style>
  </head>
  <body>
    <header>
      <h1>MediaViewer Desktop</h1>
      <div class="small" id="status"></div>
    </header>

    <div class="wrap">
      <div class="left">
        <div class="grid2">
          <div>
            <div class="small">Server URL</div>
            <input id="serverUrl" value="http://localhost:3000" />
          </div>
          <div>
            <div class="small">Search</div>
            <input id="q" placeholder="filename" />
          </div>
        </div>

        <div class="row" style="margin-top: 8px;">
          <button id="refresh">Refresh</button>
          <div class="small" id="pageLabel"></div>
        </div>

        <div class="row" style="margin-top: 12px;">
          <button id="prev">Prev</button>
          <button id="next">Next</button>
        </div>

        <hr style="border: none; border-top: 1px solid #222; margin: 12px 0;" />

        <div class="small">Serial</div>
        <div class="row">
          <select id="port"></select>
          <input id="baud" value="115200" style="max-width: 120px;" />
        </div>
        <div class="row" style="margin-top: 8px;">
          <button id="ports">List Ports</button>
          <button id="connect">Connect</button>
          <button id="disconnect">Disconnect</button>
        </div>

        <hr style="border: none; border-top: 1px solid #222; margin: 12px 0;" />

        <div class="small">Funscript â†’ TCode</div>
        <div class="row">
          <input id="axis" value="L0" style="max-width: 100px;" />
          <button id="toggleDrive">Drive: OFF</button>
        </div>

        <div class="list" id="list"></div>
      </div>

      <div class="right">
        <div class="small" id="now"></div>
        <video id="video" controls></video>
        <div class="small" id="playback"></div>
      </div>
    </div>

    <script type="module">
      const state = {
        serverUrl: 'http://localhost:8080',
        q: '',
        page: 1,
        pageSize: 30,
        total: 0,
        items: [],
        current: null,
        funscript: null,
        funIndex: -1,
        drive: false,
        axis: 'L0',
        clientId: 'desktop-' + Math.random().toString(16).slice(2),
        sessionId: 'default',
        ws: null,
        wsConnected: false,
        applyingRemoteUntil: 0,
        lastSyncSentAt: 0,
        lastPlaybackPutAt: 0,
      };

      const $ = (id) => document.getElementById(id);
      const statusEl = $('status');

      async function apiJson(path, opts) {
        const url = new URL(path, state.serverUrl);
        const res = await fetch(url.toString(), opts);
        if (!res.ok) throw new Error(await res.text());
        return res.json();
      }

      function setStatus(s) { statusEl.textContent = s; }

      function wsUrlFromHttp(httpUrl) {
        const u = new URL(httpUrl);
        u.protocol = u.protocol === 'https:' ? 'wss:' : 'ws:';
        u.pathname = '/ws';
        u.search = '';
        u.hash = '';
        return u.toString();
      }

      function connectWs() {
        if (state.ws && (state.ws.readyState === 0 || state.ws.readyState === 1)) return;
        const ws = new WebSocket(wsUrlFromHttp(state.serverUrl));
        state.ws = ws;

        ws.addEventListener('open', () => {
          state.wsConnected = true;
          setStatus('WS connected');
          ws.send(JSON.stringify({ type: 'sync:hello', clientId: state.clientId, sessionId: state.sessionId }));
        });

        ws.addEventListener('close', () => {
          state.wsConnected = false;
          setStatus('WS disconnected');
          window.setTimeout(() => connectWs(), 1000);
        });

        ws.addEventListener('message', (evt) => {
          let msg;
          try { msg = JSON.parse(String(evt.data)); } catch { return; }
          if (!msg || msg.type !== 'sync:state' || !msg.state) return;
          applyRemoteSyncState(msg.state);
        });
      }

      function sendSyncUpdate(update) {
        if (!state.wsConnected || !state.ws || state.ws.readyState !== 1) return;
        if (Date.now() < state.applyingRemoteUntil) return;
        const now = Date.now();
        if (now - state.lastSyncSentAt < 200) return;
        state.lastSyncSentAt = now;
        state.ws.send(JSON.stringify({
          type: 'sync:update',
          sessionId: state.sessionId,
          clientId: state.clientId,
          ...update,
        }));
      }

      async function applyRemoteSyncState(remote) {
        if (!remote || !remote.mediaId) return;
        if (remote.fromClientId && remote.fromClientId === state.clientId) return;

        const id = String(remote.mediaId);

        // Follow remote media selection.
        if (!state.current || state.current.id !== id) {
          // ensure list contains it or fetch minimal info
          const it = state.items.find((x) => x.id === id) || { id, filename: id, mediaType: 'video', hasFunscript: false };
          await openMedia(it.id, { suppressSync: true });
        }

        const v = $('video');
        if (!(v instanceof HTMLVideoElement)) return;

        state.applyingRemoteUntil = Date.now() + 800;

        const targetTime = Math.max(0, (Number(remote.timeMs) || 0) / 1000);
        if (Number.isFinite(v.currentTime) && Math.abs(v.currentTime - targetTime) > 0.5) {
          try { v.currentTime = targetTime; } catch {}
        }

        const paused = Boolean(remote.paused);
        if (paused) {
          try { v.pause(); } catch {}
        } else {
          try { await v.play(); } catch {}
        }
      }

      function esc(s) {
        return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'",'&#039;');
      }

      async function refresh() {
        setStatus('Loading list...');
        const url = new URL('/api/media', state.serverUrl);
        url.searchParams.set('q', state.q);
        url.searchParams.set('page', String(state.page));
        url.searchParams.set('pageSize', String(state.pageSize));
        const res = await fetch(url.toString());
        if (!res.ok) throw new Error(await res.text());
        const data = await res.json();
        state.total = data.total;
        state.items = data.items;
        renderList();
        renderPager();
        setStatus('Ready');
      }

      function renderPager() {
        const maxPage = Math.max(1, Math.ceil(state.total / state.pageSize));
        $('pageLabel').textContent = `Page ${state.page} / ${maxPage} (${state.total})`;
        $('prev').disabled = state.page <= 1;
        $('next').disabled = state.page >= maxPage;
      }

      function renderList() {
        $('list').innerHTML = state.items.map((it) => {
          const fs = it.hasFunscript ? `<span class='pill'>funscript</span>` : '';
          return `<div class='item' data-id='${it.id}'>${esc(it.filename)} ${fs}<br/><small>${esc(it.mediaType)}</small></div>`;
        }).join('');
        for (const div of $('list').querySelectorAll('.item')) {
          div.addEventListener('click', () => openMedia(div.getAttribute('data-id')));
        }
      }

      async function openMedia(id, opts = {}) {
        const suppressSync = Boolean(opts.suppressSync);
        const it = state.items.find((x) => x.id === id);
        state.current = it;
        state.funscript = null;
        state.funIndex = -1;
        $('now').textContent = it ? `Now: ${it.filename}` : `Now: ${id}`;
        $('video').src = new URL(`/api/media/${id}/stream`, state.serverUrl).toString();

        if (!suppressSync) {
          sendSyncUpdate({ mediaId: id, timeMs: 0, paused: true, fps: 30, frame: 0 });
        }

        try {
          state.funscript = await apiJson(`/api/media/${id}/funscript`);
          state.funscript.actions.sort((a,b) => a.at - b.at);
        } catch {
          state.funscript = null;
        }
      }

      function currentFrame(timeSeconds, fps) {
        return Math.max(0, Math.floor(timeSeconds * fps));
      }

      async function tick() {
        const v = $('video');
        const fps = 30;
        const timeMs = Math.round(v.currentTime * 1000);
        const frame = currentFrame(v.currentTime, fps);

        if (state.current && Number.isFinite(v.currentTime)) {
          $('playback').textContent = `t=${timeMs}ms frame=${frame} fps=${fps}`;
          // Persist playback state to server (throttled).
          if (Date.now() - state.lastPlaybackPutAt > 1000) {
            state.lastPlaybackPutAt = Date.now();
            try {
              await apiJson('/api/playback', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  clientId: state.clientId,
                  mediaId: state.current.id,
                  timeMs,
                  fps,
                  frame
                })
              });
            } catch {}
          }

          // Publish sync state (throttled) so Web UI can follow desktop.
          sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: v.paused, fps, frame });

          // Drive serial from funscript.
          if (state.drive && state.funscript?.actions?.length) {
            const actions = state.funscript.actions;
            while (state.funIndex + 1 < actions.length && actions[state.funIndex + 1].at <= timeMs) {
              state.funIndex++;
              const act = actions[state.funIndex];
              const tcode = window.mv ? null : null;
              // send
              const axis = String(state.axis || 'L0').toUpperCase();
              const pos = Math.max(0, Math.min(100, Math.round(act.pos)));
              const scaled = Math.round((pos / 100) * 999);
              const vvv = String(scaled).padStart(3, '0');
              const line = `${axis}${vvv}`;
              try { await window.mv.tcodeSend(line); } catch {}
            }
          }
        }

        window.requestAnimationFrame(tick);
      }

      async function listPorts() {
        const ports = await window.mv.listSerialPorts();
        const sel = $('port');
        sel.innerHTML = ports.map((p) => `<option value='${esc(p.path)}'>${esc(p.path)}</option>`).join('');
      }

      $('serverUrl').addEventListener('change', (e) => { state.serverUrl = e.target.value; });
      $('q').addEventListener('input', (e) => {
        state.q = e.target.value;
        state.page = 1;
        window.clearTimeout(window.__qt);
        window.__qt = window.setTimeout(() => refresh(), 200);
      });

      $('refresh').addEventListener('click', () => refresh());
      $('prev').addEventListener('click', async () => { state.page = Math.max(1, state.page - 1); await refresh(); });
      $('next').addEventListener('click', async () => {
        const maxPage = Math.max(1, Math.ceil(state.total / state.pageSize));
        state.page = Math.min(maxPage, state.page + 1);
        await refresh();
      });

      $('ports').addEventListener('click', () => listPorts());
      $('connect').addEventListener('click', async () => {
        await window.mv.serialConnect({ path: $('port').value, baudRate: Number($('baud').value || 115200) });
        setStatus('Serial connected');
      });
      $('disconnect').addEventListener('click', async () => {
        await window.mv.serialDisconnect();
        setStatus('Serial disconnected');
      });

      $('axis').addEventListener('input', (e) => { state.axis = e.target.value; });
      $('toggleDrive').addEventListener('click', () => {
        state.drive = !state.drive;
        $('toggleDrive').textContent = state.drive ? 'Drive: ON' : 'Drive: OFF';
        state.funIndex = -1;
      });

      state.serverUrl = $('serverUrl').value;
      setStatus('Ready');
      connectWs();
      await listPorts();
      await refresh();

      const v = $('video');
      if (v instanceof HTMLVideoElement) {
        const fps = 30;
        const push = () => {
          if (!state.current) return;
          const timeMs = Math.round((v.currentTime || 0) * 1000);
          const frame = currentFrame(v.currentTime || 0, fps);
          sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: v.paused, fps, frame });
        };
        v.addEventListener('play', push);
        v.addEventListener('pause', push);
        v.addEventListener('seeked', push);
      }

      tick();
    </script>
  </body>
</html>
