<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>MediaViewer Desktop</title>
    <style>
      :root { color-scheme: dark; }
      *, *::before, *::after { box-sizing: border-box; }
      body { margin: 0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; background: #0b0c0f; color: #e6e6e6; }
      header { padding: 12px 16px; border-bottom: 1px solid #222; display: flex; gap: 12px; align-items: center; justify-content: space-between; }
      header h1 { font-size: 14px; margin: 0; }
      .wrap { display: grid; grid-template-columns: 380px 380px 1fr; height: calc(100vh - 50px); }
      .left { border-right: 1px solid #222; padding: 12px; overflow-y: auto; display: grid; gap: 12px; grid-template-rows: auto auto auto 1fr; align-content: start; }
      .middle { border-right: 1px solid #222; padding: 12px; overflow: auto; display: grid; gap: 12px; }
      .right { padding: 12px; overflow: auto; display: grid; gap: 10px; }
      .row { display: flex; gap: 8px; align-items: center; }
      input, select { width: 100%; padding: 10px 12px; border-radius: 8px; border: 1px solid #2a2f3a; background: #11131a; color: #e6e6e6; }
      button { padding: 10px 12px; border-radius: 8px; border: 1px solid #2a2f3a; background: #11131a; color: #e6e6e6; cursor: pointer; }
      button:disabled { opacity: 0.6; cursor: not-allowed; }
      .list { margin-top: 12px; display: grid; gap: 8px; }
      .item { border: 1px solid #222; border-radius: 10px; padding: 10px; cursor: pointer; background: #0f1117; white-space: normal; overflow-wrap: anywhere; word-break: break-word; }
      .item.active { outline: 2px solid #2a2f3a; }
      .item small { opacity: 0.8; }
      video { width: 100%; max-height: 70vh; background: #000; }
      input[type="range"] { width: 100%; max-width: 100%; padding: 0; border: 0; background: transparent; }
      .small { font-size: 12px; opacity: 0.85; }
      .pill { display: inline-block; padding: 2px 8px; border: 1px solid #2a2f3a; border-radius: 999px; font-size: 11px; margin-left: 6px; }
      .pill.connected { background: #10b981; color: #fff; border-color: #059669; }
      .pill.disconnected { background: #ef4444; color: #fff; border-color: #dc2626; }
      .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
      .card { border: 1px solid #222; border-radius: 12px; padding: 12px; background: #0f1117; }
      .card.console-card { display: flex; flex-direction: column; min-height: 150px; overflow: hidden; }
      .card h2 { margin: 0 0 10px 0; font-size: 12px; font-weight: 600; opacity: 0.9; }
      .kpi { display: flex; gap: 8px; flex-wrap: wrap; justify-content: flex-end; }
      .kpi .pill { margin-left: 0; }
      .stack { display: grid; gap: 8px; }
      .meter { position: relative; height: 14px; border-radius: 999px; background: #1a1c24; border: 1px solid #2a2f3a; overflow: hidden; }
      .meter-fill { position: absolute; inset: 0; background: linear-gradient(90deg, #5b8cff, #2cd3a7); transform-origin: left center; transform: scaleX(0); transition: transform 0.12s ease-out; }
      .meter-label { font-size: 11px; opacity: 0.8; margin-top: 4px; text-align: right; }
      .console-view { border: 1px solid #222; border-radius: 8px; padding: 8px; background: #000; overflow-y: auto; font-family: monospace; font-size: 11px; flex: 1; min-height: 100px; }
    </style>
  </head>
  <body>
    <header>
      <h1>MediaViewer Desktop</h1>
      <div class="kpi">
        <span class="pill" id="wsPill">Server: —</span>
        <span class="pill" id="serialPill">Serial: —</span>
        <span class="pill" id="drivePill">Drive: OFF</span>
        <span class="pill" id="fsPill">Funscript: —</span>
      </div>
    </header>

    <div class="wrap">
      <div class="left">
        <div class="card">
          <h2>Server</h2>
          <div class="stack">
            <div>
              <div class="small">Server URL</div>
              <div class="row">
                <input id="serverUrl" value="http://localhost:3000" />
                <button id="applyServer" style="max-width: 120px;">Apply</button>
              </div>
            </div>
            <div class="row"><div class="small" id="status"></div></div>
          </div>
        </div>

        <div class="card">
          <h2>Serial</h2>
          <div class="stack">
            <div class="row">
              <select id="port"></select>
              <input id="baud" value="115200" style="max-width: 120px;" />
            </div>
            <div class="row">
              <button id="ports">Refresh</button>
              <button id="connect">Connect</button>
              <button id="disconnect">Disconnect</button>
            </div>
            <div class="row">
              <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                <input type="checkbox" id="autoConnectSerial" />
                <span class="small">Auto-connect on startup</span>
              </label>
            </div>
          </div>
        </div>

        <div class="card">
          <h2>Funscript → TCode</h2>
          <div class="stack">
            <div class="row">
              <select id="axisSelect" style="max-width: 220px;">
                <option value="L0">L0 (Stroke)</option>
                <option value="L1">L1 (Twist)</option>
                <option value="L2">L2 (Roll)</option>
                <option value="L3">L3 (Pitch)</option>
                <option value="CUSTOM">Custom…</option>
              </select>
              <input id="axisCustom" value="L0" style="max-width: 120px; display:none;" />
              <button id="toggleDrive" style="max-width: 140px;">Drive: OFF</button>
              <button id="btnSettings" style="max-width: 140px;">⚙️ Settings</button>
            </div>
            <div class="small">Sends TCode lines based on the funscript actions while playing.</div>
            
            <div style="border-top: 1px solid #222; padding-top: 8px; margin-top: 4px;">
              <div class="row" style="justify-content:space-between;">
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                  <input type="checkbox" id="autoHomeEnabled" />
                  <span class="small">Auto-home on pause/stop</span>
                </label>
                <button id="btnToggleAutoHomeSettings" class="small" style="padding:2px 4px; opacity:0.7;">Details</button>
              </div>
              <div id="autoHomeSettings" style="display: none; margin-top: 8px;">
                <div class="small" style="margin-bottom: 4px;">Home position (%):</div>
                <input type="number" id="autoHomePosition" min="0" max="100" step="1" value="0" style="margin-bottom: 8px;" />
                <div class="small" style="margin-bottom: 4px;">Delay (seconds):</div>
                <input type="number" id="autoHomeDelay" min="0" max="60" step="0.5" value="2" style="margin-bottom: 8px;" />
                <div class="small" style="margin-bottom: 4px;">Transition time (ms):</div>
                <input type="number" id="autoHomeTransition" min="100" max="10000" step="100" value="2000" />
              </div>
            </div>
          </div>
        </div>

        <div class="card console-card">
          <h2>Console Log</h2>
          <div id="consoleView" class="console-view">
            <div style="margin-bottom: 6px; display: flex; justify-content: space-between;">
              <span style="opacity: 0.7;">Debug Output</span>
              <button id="btnClearConsole" style="padding: 2px 8px; font-size: 10px;">Clear</button>
            </div>
            <div id="consoleOutput"></div>
          </div>
        </div>
      </div>

      <div class="middle">
        <div class="card">
          <h2>Media</h2>
          <div class="stack">
            <div class="grid2">
              <div>
                <div class="small">Search</div>
                <input id="q" placeholder="filename" />
              </div>
              <div>
                <div class="small">Paging</div>
                <div class="row">
                  <button id="prev" style="max-width: 90px;">Prev</button>
                  <button id="next" style="max-width: 90px;">Next</button>
                  <div class="small" id="pageLabel" style="white-space: nowrap;"></div>
                </div>
              </div>
            </div>
            <div class="row">
              <button id="refresh" style="max-width: 120px;">Refresh</button>
              <div class="small"></div>
            </div>
            <div class="list" id="list"></div>
          </div>
        </div>
      </div>

      <div class="right">
        <div class="row" style="justify-content: space-between; gap: 12px; flex-wrap: wrap;">
          <div class="small" id="now"></div>
          <div class="row" style="gap: 8px;">
            <button id="btnPlayPause" style="max-width: 140px;">Play/Pause</button>
            <button id="btnVideo" style="max-width: 140px;">Video: ON</button>
            <button id="btnFollow" style="max-width: 220px;">Follow remote: ON</button>
          </div>
        </div>

        <div class="row" style="justify-content: flex-end; gap: 8px; flex-wrap: wrap;">
          <div class="small" style="white-space: nowrap;">Follow source</div>
          <select id="followSource" style="max-width: 260px;"></select>
        </div>

        <video id="video" controls></video>
        <input id="progress" type="range" min="0" max="1" value="0" step="1" />
        <div class="small" id="progressTime">--:-- / --:--</div>
        <div class="small" id="funscriptStatus">Funscript: not loaded</div>
        <div class="meter" aria-hidden="true">
          <div class="meter-fill" id="funscriptMeter"></div>
        </div>
        <div class="meter-label" id="funscriptLabel">Value: 0% (000)</div>
        <div class="small" id="noVideoHint" style="display:none;">No-video mode: using sync playback time only (no /stream requests).</div>
        <div class="small" id="playback"></div>
      </div>
    </div>

    <div id="settingsModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); z-index:1000; overflow:auto;">
      <div style="max-width:700px; margin:40px auto; background:#1e1e1e; border:1px solid #333; border-radius:8px; padding:30px;">
        <h2 style="margin-top:0; color:#fff;">Script & Axis Settings</h2>
        
        <div style="margin-bottom:30px;">
          <h3 style="color:#fff;">Script Transformations</h3>
          <div style="margin-bottom:15px;">
            <label style="display:flex; align-items:center; color:#fff; cursor:pointer;">
              <input type="checkbox" id="invertScriptCheck" style="margin-right:10px;">
              <span>Invert Script Positions (0↔100)</span>
            </label>
          </div>
          <div style="margin-bottom:15px;">
            <label style="display:block; color:#fff; margin-bottom:5px;">Script Delay (ms)</label>
            <input type="number" id="scriptDelayInput" step="10" style="width:150px; padding:5px;">
            <span style="color:#888; font-size:0.9em; margin-left:10px;">Negative = earlier, Positive = later</span>
          </div>
        </div>

        <div style="margin-bottom:30px;">
          <h3 style="color:#fff;">Axis Position Limits</h3>
          
          <div style="margin-bottom:20px;">
            <label style="display:block; color:#fff; margin-bottom:5px;">L0 (Stroke) - Min: <span id="L0MinLabel">0</span>% | Max: <span id="L0MaxLabel">100</span>%</label>
            <div style="display:flex; gap:15px; align-items:center;">
              <input type="range" id="L0MinSlider" min="0" max="100" value="0" style="flex:1;">
              <input type="range" id="L0MaxSlider" min="0" max="100" value="100" style="flex:1;">
            </div>
          </div>

          <div style="margin-bottom:20px;">
            <label style="display:block; color:#fff; margin-bottom:5px;">L1 (Twist) - Min: <span id="L1MinLabel">0</span>% | Max: <span id="L1MaxLabel">100</span>%</label>
            <div style="display:flex; gap:15px; align-items:center;">
              <input type="range" id="L1MinSlider" min="0" max="100" value="0" style="flex:1;">
              <input type="range" id="L1MaxSlider" min="0" max="100" value="100" style="flex:1;">
            </div>
          </div>

          <div style="margin-bottom:20px;">
            <label style="display:block; color:#fff; margin-bottom:5px;">L2 (Roll) - Min: <span id="L2MinLabel">0</span>% | Max: <span id="L2MaxLabel">100</span>%</label>
            <div style="display:flex; gap:15px; align-items:center;">
              <input type="range" id="L2MinSlider" min="0" max="100" value="0" style="flex:1;">
              <input type="range" id="L2MaxSlider" min="0" max="100" value="100" style="flex:1;">
            </div>
          </div>

          <div style="margin-bottom:20px;">
            <label style="display:block; color:#fff; margin-bottom:5px;">L3 (Pitch) - Min: <span id="L3MinLabel">0</span>% | Max: <span id="L3MaxLabel">100</span>%</label>
            <div style="display:flex; gap:15px; align-items:center;">
              <input type="range" id="L3MinSlider" min="0" max="100" value="0" style="flex:1;">
              <input type="range" id="L3MaxSlider" min="0" max="100" value="100" style="flex:1;">
            </div>
          </div>
        </div>

        <div style="display:flex; gap:10px; justify-content:flex-end;">
          <button id="btnResetSettings" style="padding:8px 16px;">Reset to Defaults</button>
          <button id="btnCloseSettings" style="padding:8px 16px; background:#007acc; color:#fff; border:none; border-radius:4px;">Close</button>
        </div>
      </div>
    </div>

    <script type="module">
      const state = {
        serverUrl: 'http://localhost:3000',
        q: '',
        page: 1,
        pageSize: 30,
        total: 0,
        items: [],
        durationsSec: {},
        _durToken: 0,
        current: null,
        funscript: null,
        funIndex: -1,
        funscriptPointer: -1,
        lastFunscriptValue: 0,
        drive: false,
        axis: 'L0',
        autoHomeEnabled: false,
        autoHomePosition: 0,
        autoHomeDelay: 2,
        autoHomeTransition: 2000,
        autoHomeTimer: null,
        invertScript: false,
        scriptDelay: 0,
        autoConnectSerial: false,
        lastSerialPort: '',
        lastSerialBaud: 115200,
        axisLimits: {
          L0: { min: 0, max: 100 },
          L1: { min: 0, max: 100 },
          L2: { min: 0, max: 100 },
          L3: { min: 0, max: 100 },
        },
        clientId: 'desktop-' + Math.random().toString(16).slice(2),
        sessionId: 'default',
        ws: null,
        wsConnected: false,
        applyingRemoteUntil: 0,
        lastSyncSentAt: 0,
        lastPlaybackPutAt: 0,
        followRemote: true,
        noVideo: false,
        remoteTimeMs: 0,
        remotePaused: true,
        remoteFps: 30,
        remoteLastUpdateAt: 0,
        lastAppliedRemotePaused: null,
        serialConnected: false,
        isApplyingRemoteState: false,

        durationMs: null,
        durationCache: new Map(),
        durationInFlightFor: null,

        followSource: 'any',
        seenSources: new Map(),
        clientsMetadata: new Map(),

        consoleLogs: [],
        consoleVisible: false,
      };

      const $ = (id) => document.getElementById(id);
      const statusEl = $('status');
      const wsPill = $('wsPill');
      const serialPill = $('serialPill');
      const drivePill = $('drivePill');
      const fsPill = $('fsPill');
      const progressTimeEl = $('progressTime');
      const funscriptStatusEl = $('funscriptStatus');
      const funscriptMeterEl = $('funscriptMeter');
      const funscriptLabelEl = $('funscriptLabel');

      function logToConsole(level, ...args) {
        const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
        const message = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
        state.consoleLogs.push({ timestamp, level, message });
        if (state.consoleLogs.length > 500) state.consoleLogs.shift();
        updateConsoleView();
        // Also log to browser console
        if (level === 'error') console.error(...args);
        else if (level === 'warn') console.warn(...args);
        else console.log(...args);
      }

      function updateConsoleView() {
        const output = $('consoleOutput');
        if (!output) return;
        const colorMap = { log: '#9ca3af', warn: '#fbbf24', error: '#f87171' };
        output.innerHTML = state.consoleLogs.slice(-100).map(log => 
          `<div style="color: ${colorMap[log.level] || '#9ca3af'}; margin-bottom: 2px;">[${log.timestamp}] ${esc(log.message)}</div>`
        ).join('');
        output.scrollTop = output.scrollHeight;
      }

      async function apiJson(path, opts) {
        const url = new URL(path, state.serverUrl);
        const res = await fetch(url.toString(), opts);
        if (!res.ok) throw new Error(await res.text());
        return res.json();
      }

      async function ensureDurationMs(mediaId) {
        if (!mediaId) return;
        if (state.durationCache.has(mediaId)) {
          state.durationMs = state.durationCache.get(mediaId);
          return;
        }
        if (state.durationInFlightFor === mediaId) return;
        state.durationInFlightFor = mediaId;
        try {
          const r = await apiJson(`/api/media/${encodeURIComponent(mediaId)}/probe`);
          const ms = typeof r?.durationMs === 'number' && Number.isFinite(r.durationMs) && r.durationMs > 0 ? Math.round(r.durationMs) : null;
          state.durationCache.set(mediaId, ms);
          state.durationMs = ms;
        } catch {
          state.durationCache.set(mediaId, null);
          state.durationMs = null;
        } finally {
          if (state.durationInFlightFor === mediaId) state.durationInFlightFor = null;
        }
      }

      function setStatus(s) { statusEl.textContent = s; }

      function setWsPill(connected) {
        wsPill.textContent = connected ? 'Server: connected' : 'Server: disconnected';
        wsPill.className = connected ? 'pill connected' : 'pill disconnected';
      }

      function setSerialPill(connected) {
        serialPill.textContent = connected ? 'Serial: connected' : 'Serial: disconnected';
        serialPill.className = connected ? 'pill connected' : 'pill disconnected';
      }

      function setDrivePill() {
        drivePill.textContent = state.drive ? 'Drive: ON' : 'Drive: OFF';
        drivePill.className = state.drive ? 'pill connected' : 'pill disconnected';
      }

      function setFsPill() {
        const n = state.funscript?.actions?.length;
        if (typeof n === 'number') {
          fsPill.textContent = 'Funscript: Loaded';
          fsPill.className = 'pill connected';
        } else {
          fsPill.textContent = 'Funscript: Not available';
          fsPill.className = 'pill disconnected';
        }
      }

      function loadPrefs() {
        try {
          const p = JSON.parse(localStorage.getItem('mvDesktopPrefs') || 'null');
          if (p && typeof p === 'object') {
            if (typeof p.serverUrl === 'string') state.serverUrl = p.serverUrl;
            if (typeof p.axis === 'string') state.axis = p.axis;
            if (typeof p.drive === 'boolean') state.drive = p.drive;
            if (typeof p.followRemote === 'boolean') state.followRemote = p.followRemote;
            if (typeof p.noVideo === 'boolean') state.noVideo = p.noVideo;
            if (typeof p.followSource === 'string') state.followSource = p.followSource;
            if (typeof p.autoHomeEnabled === 'boolean') state.autoHomeEnabled = p.autoHomeEnabled;
            if (typeof p.autoHomePosition === 'number') state.autoHomePosition = p.autoHomePosition;
            if (typeof p.autoHomeDelay === 'number') state.autoHomeDelay = p.autoHomeDelay;
            if (typeof p.autoHomeTransition === 'number') state.autoHomeTransition = p.autoHomeTransition;
            if (typeof p.invertScript === 'boolean') state.invertScript = p.invertScript;
            if (typeof p.scriptDelay === 'number') state.scriptDelay = p.scriptDelay;
            if (typeof p.autoConnectSerial === 'boolean') state.autoConnectSerial = p.autoConnectSerial;
            if (typeof p.lastSerialPort === 'string') state.lastSerialPort = p.lastSerialPort;
            if (typeof p.lastSerialBaud === 'number') state.lastSerialBaud = p.lastSerialBaud;
            if (p.axisLimits && typeof p.axisLimits === 'object') {
              ['L0', 'L1', 'L2', 'L3'].forEach(axis => {
                if (p.axisLimits[axis]) {
                  if (typeof p.axisLimits[axis].min === 'number') state.axisLimits[axis].min = p.axisLimits[axis].min;
                  if (typeof p.axisLimits[axis].max === 'number') state.axisLimits[axis].max = p.axisLimits[axis].max;
                }
              });
            }
          }
        } catch {}
      }

      function savePrefs() {
        localStorage.setItem('mvDesktopPrefs', JSON.stringify({
          serverUrl: state.serverUrl,
          axis: state.axis,
          drive: state.drive,
          followRemote: state.followRemote,
          noVideo: state.noVideo,
          followSource: state.followSource,
          autoHomeEnabled: state.autoHomeEnabled,
          autoHomePosition: state.autoHomePosition,
          autoHomeDelay: state.autoHomeDelay,
          autoHomeTransition: state.autoHomeTransition,
          invertScript: state.invertScript,
          scriptDelay: state.scriptDelay,
          axisLimits: state.axisLimits,
          autoConnectSerial: state.autoConnectSerial,
          lastSerialPort: state.lastSerialPort,
          lastSerialBaud: state.lastSerialBaud,
        }));
      }

      function cancelAutoHome() {
        if (state.autoHomeTimer) {
          clearTimeout(state.autoHomeTimer);
          state.autoHomeTimer = null;
        }
      }

      async function triggerAutoHome() {
        cancelAutoHome();
        
        // Check requirements
        if (!state.autoHomeEnabled) {
          logToConsole('log', 'Auto-home skipped: not enabled');
          return;
        }
        if (!state.drive) {
          logToConsole('log', 'Auto-home skipped: drive is off');
          return;
        }
        if (!state.serialConnected) {
          logToConsole('log', 'Auto-home skipped: serial not connected');
          return;
        }
        
        logToConsole('log', `Auto-home scheduled: ${state.autoHomeDelay}s delay to position ${state.autoHomePosition}%`);
        
        state.autoHomeTimer = setTimeout(async () => {
          try {
            const axis = String(state.axis || 'L0').toUpperCase();
            const pos = Math.max(0, Math.min(100, Math.round(state.autoHomePosition)));
            const scaled = Math.round((pos / 100) * 999);
            const vvv = String(scaled).padStart(3, '0');
            const interval = Math.max(100, Math.min(10000, Math.round(state.autoHomeTransition)));
            const iii = String(interval).padStart(5, '0');
            const line = `${axis}${vvv}I${iii}`;
            logToConsole('log', `Auto-home executing: ${line}`);
            if (window.mv) await window.mv.tcodeSend(line);
          } catch (err) {
            logToConsole('error', 'Auto-home failed:', err);
          }
        }, state.autoHomeDelay * 1000);
      }

      function labelForSource(id) {
        if (!id) return 'Unknown';
        
        // Check if we have metadata for this client
        const meta = state.clientsMetadata.get(id);
        if (meta) {
          const browser = parseBrowserFromUserAgent(meta.userAgent);
          // Strip ::ffff: prefix from IP
          const ip = (meta.ipAddress || '').replace(/^::ffff:/, '');
          return `${browser} (${ip})`;
        }
        
        // Fallbacks
        if (id.startsWith('vr:deovr')) return 'VR (DeoVR)';
        if (id.startsWith('vr:heresphere')) return 'VR (HereSphere)';
        if (id.startsWith('desktop-')) return 'Desktop Client';
        if (id.startsWith('web-')) return 'Web Browser';
        
        if (id.length > 20) return id.slice(0, 17) + '...';
        return id;
      }
      
      function parseBrowserFromUserAgent(ua) {
        if (!ua || ua === 'Unknown') return 'Unknown Browser';
        
        // Specific VR browsers/agents
        if (ua.includes('DeoVR')) return 'DeoVR';
        if (ua.includes('HereSphere')) return 'HereSphere';
        if (ua.includes('OculusBrowser')) return 'Oculus Browser';
        if (ua.includes('Wolvic')) return 'Wolvic';
        
        // Common desktop
        if (ua.includes('Edg/')) return 'Edge';
        if (ua.includes('Chrome/')) return 'Chrome';
        if (ua.includes('Firefox/')) return 'Firefox';
        if (ua.includes('Safari/') && !ua.includes('Chrome')) return 'Safari';
        if (ua.includes('OPR/') || ua.includes('Opera/')) return 'Opera';
        
        return 'Browser';
      }

      function updateFollowSourceOptions() {
        const sel = $('followSource');
        if (!(sel instanceof HTMLSelectElement)) return;

        // "Any" option removed per user request.
        // List only active sources.
        const activeIds = Array.from(state.seenSources.keys());
        
        // If followSource is not in active list, we might want to add a "Select a source" option
        // or just show the active ones.
        // User said: "If current selected source gets disconnected change follow source to none."
        
        let html = '<option value="">(None)</option>';
        html += activeIds.map((id) => `<option value="${esc(id)}" ${id === state.followSource ? 'selected' : ''}>${esc(labelForSource(id))}</option>`).join('');
        
        sel.innerHTML = html;

        // If currently selected source is no longer valid/active, reset to none.
        if (state.followSource && state.followSource !== 'any' && !state.seenSources.has(state.followSource)) {
           state.followSource = '';
           savePrefs();
           sel.value = '';
        }
      }

      function setVideoModeUi() {
        $('btnVideo').textContent = state.noVideo ? 'Video: OFF' : 'Video: ON';
        $('btnPlayPause').disabled = state.noVideo;

        const v = $('video');
        if (v instanceof HTMLVideoElement) {
          v.style.display = state.noVideo ? 'none' : '';
        }

        const hint = $('noVideoHint');
        if (hint) hint.style.display = state.noVideo ? '' : 'none';

        if (state.noVideo && v instanceof HTMLVideoElement) {
          // Ensure we don't keep any active stream.
          try {
            v.pause();
            v.removeAttribute('src');
            v.load();
          } catch {}
        }
      }

      function wsUrlFromHttp(httpUrl) {
        const u = new URL(httpUrl);
        u.protocol = u.protocol === 'https:' ? 'wss:' : 'ws:';
        u.pathname = '/ws';
        u.search = '';
        u.hash = '';
        return u.toString();
      }

      function connectWs() {
        if (state.ws && (state.ws.readyState === 0 || state.ws.readyState === 1)) return;
        const ws = new WebSocket(wsUrlFromHttp(state.serverUrl));
        state.ws = ws;

        ws.addEventListener('open', () => {
          state.wsConnected = true;
          setStatus('WS connected');
          setWsPill(true);
          ws.send(JSON.stringify({ type: 'sync:hello', clientId: state.clientId, sessionId: state.sessionId }));
          
          // Send initial empty sync state to announce presence/reset
          sendSyncUpdate({ 
              mediaId: state.current?.id || null, 
              timeMs: 0, 
              paused: true, 
              fps: 30, 
              frame: 0 
          }, true);
        });

        ws.addEventListener('close', () => {
          state.wsConnected = false;
          setStatus('WS disconnected');
          setWsPill(false);
          window.setTimeout(() => connectWs(), 1000);
        });

        ws.addEventListener('message', (evt) => {
          let msg;
          try { msg = JSON.parse(String(evt.data)); } catch { return; }
          if (!msg || msg.type !== 'sync:state' || !msg.state) return;

          // Update clients metadata if provided
          if (msg.clients && Array.isArray(msg.clients)) {
            state.seenSources.clear();
            state.clientsMetadata.clear();
            for (const client of msg.clients) {
              if (client.clientId && client.clientId !== state.clientId) {
                state.seenSources.set(client.clientId, Date.now());
                state.clientsMetadata.set(client.clientId, {
                  userAgent: client.userAgent || 'Unknown',
                  ipAddress: client.ipAddress || 'Unknown',
                });
              }
            }
            updateFollowSourceOptions();
          }

          const src = String(msg.state.fromClientId || '');
          if (src && src !== state.clientId) {
            state.seenSources.set(src, Date.now());
            updateFollowSourceOptions();
            
            // Log VR sync events for debugging
            if (src.startsWith('vr:')) {
              logToConsole('log', `VR sync received: ${src} → media ${msg.state.mediaId}`);
            }
          }

          applyRemoteSyncState(msg.state);
        });
      }

      function sendSyncUpdate(update, force = false) {
        if (!state.wsConnected || !state.ws || state.ws.readyState !== 1) return;
        if (!force && Date.now() < state.applyingRemoteUntil) return;
        const now = Date.now();
        if (!force && now - state.lastSyncSentAt < 200) return;
        state.lastSyncSentAt = now;
        state.ws.send(JSON.stringify({
          type: 'sync:update',
          sessionId: state.sessionId,
          clientId: state.clientId,
          ...update,
        }));
      }

      async function applyRemoteSyncState(remote) {
        if (!state.followRemote) return;
        
        // Handle empty/null remote state (deselect current media)
        if (!remote || !remote.mediaId) {
          if (state.current) {
             state.current = null;
             state.funscript = null;
             state.funscriptPointer = -1;
             state.durationMs = null;
             state.lastAppliedRemotePaused = null;
             $('now').textContent = 'Now: (Nothing)';
             
             // Reset player
             const v = $('video');
             if (v instanceof HTMLVideoElement) {
               v.pause();
               v.removeAttribute('src');
               v.load();
             }
             
             updateFunscriptUi(0);
             renderList();
             logToConsole('log', 'Remote cleared media - resetting player');
          }
          return;
        }

        if (remote.fromClientId && remote.fromClientId === state.clientId) return;

        if (state.followSource) {
          // Strict checking if a source is selected
          if (String(remote.fromClientId || '') !== state.followSource) {
             // ... validation
             return; 
          }
        } else {
           // If followSource is empty ("(None)"), do NOT follow "any".
           // User wants strict following if I removed "any".
           // "Remove the option Any... If current selected source gets disconnected change follow source to none."
           // This implies default behavior is NOT "follow anyone".
           return;
        }

        const id = String(remote.mediaId);

        // Follow remote media selection.
        if (!state.current || state.current.id !== id) {
          // ensure list contains it or fetch minimal info
          const it = state.items.find((x) => x.id === id) || { id, filename: id, mediaType: 'video', hasFunscript: false };
          await openMedia(it.id, { suppressSync: true });
        }

        // Only throttle time updates, not pause state changes
        const now = Date.now();
        const isThrottled = now < state.applyingRemoteUntil;
        
        state.remoteTimeMs = Math.max(0, Math.round(Number(remote.timeMs) || 0));
        // Be strict about paused parsing (handles booleans, 0/1, and 'true'/'false').
        const pausedRaw = remote.paused;
        const paused = pausedRaw === true || pausedRaw === 1 || pausedRaw === '1' || pausedRaw === 'true';
        const pausedChanged = state.remotePaused !== paused;
        state.remotePaused = paused;
        state.remoteFps = Math.max(1, Math.round(Number(remote.fps) || 30));
        state.remoteLastUpdateAt = Date.now();

        if (pausedChanged) {
          logToConsole('log', `Remote pause state changed: ${paused ? 'PAUSED' : 'PLAYING'}`);
        }

        // In no-video mode, do not load/control the stream.
        if (state.noVideo) return;

        const v = $('video');
        if (!(v instanceof HTMLVideoElement)) return;

        state.isApplyingRemoteState = true;
        try {
          // Apply time seek only if not throttled
          if (!isThrottled) {
            const targetTime = Math.max(0, state.remoteTimeMs / 1000);
            if (Number.isFinite(v.currentTime) && Math.abs(v.currentTime - targetTime) > 0.5) {
              try { v.currentTime = targetTime; } catch {}
            }
            state.applyingRemoteUntil = Date.now() + 1500;
          }

          // Always apply pause state changes immediately (not throttled)
          if (state.lastAppliedRemotePaused !== state.remotePaused) {
            state.lastAppliedRemotePaused = state.remotePaused;
            state.applyingRemoteUntil = Date.now() + 1500; // Prevent immediate sync back
            if (state.remotePaused) {
              logToConsole('log', 'Pausing video (remote)');
              try { v.pause(); } catch {}
              triggerAutoHome(); // Trigger auto-home when remotely paused
            } else {
              logToConsole('log', 'Playing video (remote)');
              try { await v.play(); } catch {}
              cancelAutoHome(); // Cancel auto-home when remotely unpaused
            }
          }
        } finally {
          state.isApplyingRemoteState = false;
        }
      }

      function esc(s) {
        return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'",'&#039;');
      }

      async function refresh() {
        setStatus('Loading list...');
        const url = new URL('/api/media', state.serverUrl);
        url.searchParams.set('q', state.q);
        url.searchParams.set('page', String(state.page));
        url.searchParams.set('pageSize', String(state.pageSize));
        const res = await fetch(url.toString());
        if (!res.ok) throw new Error(await res.text());
        const data = await res.json();
        state.total = data.total;
        state.items = data.items;
        renderList();
        renderPager();
        setStatus('Ready');
        prefetchDurations();
      }

      function getDurationSec(id) {
        const v = state.durationsSec[id];
        return Number.isFinite(v) ? v : null;
      }

      function formatDuration(seconds) {
        if (!Number.isFinite(seconds) || seconds <= 0) return '--:--';
        const total = Math.round(seconds);
        const h = Math.floor(total / 3600);
        const m = Math.floor((total % 3600) / 60);
        const s = total % 60;
        if (h > 0) return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        return `${m}:${String(s).padStart(2, '0')}`;
      }

      function renderPager() {
        const maxPage = Math.max(1, Math.ceil(state.total / state.pageSize));
        $('pageLabel').textContent = `Page ${state.page} / ${maxPage} (${state.total})`;
        $('prev').disabled = state.page <= 1;
        $('next').disabled = state.page >= maxPage;
      }

      function renderList() {
        $('list').innerHTML = state.items.map((it) => {
          const fs = it.hasFunscript ? `<span class='pill' style='background:#10b981;color:#fff;'>funscript</span>` : '';
          const vr = it.isVr ? `<span class='pill' style='background:#8b5cf6;color:#fff;'>VR</span>` : '';
          const active = state.current?.id === it.id ? 'active' : '';
          const dur = formatDuration(getDurationSec(it.id) ?? NaN);
          const durTag = dur !== '--:--' ? `<span class='pill' style='background:#374151;color:#d1d5db;'>${dur}</span>` : '';
          return `<div class='item ${active}' data-id='${it.id}'>
            <div style="display:flex; justify-content:space-between;">
              <span>${esc(it.filename)}</span>
              <span>${durTag} ${vr} ${fs}</span>
            </div>
            <small style="opacity:0.7;">${esc(it.mediaType)}</small>
          </div>`;
        }).join('');
        const items = $('list').querySelectorAll('.item');
        for (const div of items) {
          div.addEventListener('click', () => openMedia(div.getAttribute('data-id')));
        }
      }

      async function probeDuration(id) {
        // Desktop version: use hidden video element to probe
        return new Promise((resolve) => {
          const v = document.createElement('video');
          v.preload = 'metadata';
          v.src = new URL(`/api/media/${id}/stream`, state.serverUrl).toString();
          v.onloadedmetadata = () => {
             const d = v.duration;
             v.removeAttribute('src');
             resolve(d);
          };
          v.onerror = () => resolve(null);
          // Timeout
          setTimeout(() => {
             v.removeAttribute('src');
             resolve(null); 
          }, 5000);
        });
      }

      async function prefetchDurations() {
        const token = ++state._durToken;
        const ids = state.items
          .filter(it => it.mediaType === 'video')
          .map(it => it.id)
          .filter(id => getDurationSec(id) === null);
          
        if (!ids.length) return;
        
        // Process sequentially to avoid flooding network/process
        for (const id of ids) {
          if (token !== state._durToken) return;
          const d = await probeDuration(id);
          if (token !== state._durToken) return;
          if (typeof d === 'number' && Number.isFinite(d) && d > 0) {
             state.durationsSec[id] = d;
             // Update UI if item is still visible
             const el = document.querySelector(`.item[data-id="${id}"]`);
             if (el) renderList(); 
          }
        }
      }

      async function openMedia(id, opts = {}) {
        const suppressSync = Boolean(opts.suppressSync);
        const it = state.items.find((x) => x.id === id);
        // When following remote, the media might not be in the currently loaded page.
        // Keep a placeholder so progress/UI can still update.
        state.current = it || { id, filename: id, mediaType: 'video', hasFunscript: false };
        state.funscript = null;
        state.funIndex = -1;
        state.funscriptPointer = -1;
        state.lastFunscriptValue = 0;
        state.durationMs = null;
        // Reset pause tracking so the new video's pause state is applied
        state.lastAppliedRemotePaused = null;
        $('now').textContent = it ? `Now: ${it.filename}` : `Now: ${id}`;
        updateFunscriptUi(0);

        const v = $('video');
        if (v instanceof HTMLVideoElement) {
          if (state.noVideo) {
            try {
              v.pause();
              v.removeAttribute('src');
              v.load();
            } catch {}

            // No-video mode: fetch duration via ffprobe so we can render a real progress bar.
            ensureDurationMs(id);
          } else {
            v.src = new URL(`/api/media/${id}/stream`, state.serverUrl).toString();
          }
        }

        if (!suppressSync && !state.followRemote) {
          sendSyncUpdate({ mediaId: id, timeMs: 0, paused: true, fps: 30, frame: 0 });
        }

        try {
          state.funscript = await apiJson(`/api/media/${id}/funscript`);
          state.funscript.actions.sort((a,b) => a.at - b.at);
          state.funscriptPointer = -1;
          state.lastFunscriptValue = 0;
        } catch {
          state.funscript = null;
        }

        setFsPill();
        updateFunscriptUi(0);
        renderList();
      }

      function currentFrame(timeSeconds, fps) {
        return Math.max(0, Math.floor(timeSeconds * fps));
      }

      function updateFunscriptUi(timeMs) {
        if (!funscriptStatusEl || !funscriptMeterEl || !funscriptLabelEl) return;

        const actions = state.funscript?.actions;
        if (!actions || !Array.isArray(actions) || actions.length === 0) {
          funscriptStatusEl.textContent = 'Funscript: not loaded';
          funscriptMeterEl.style.transform = 'scaleX(0)';
          const axis = String(state.axis || 'L0').toUpperCase();
          funscriptLabelEl.textContent = `${axis}: 0% (000)`;
          state.funscriptPointer = -1;
          state.lastFunscriptValue = 0;
          return;
        }

        const driveStatus = state.drive ? 'Drive: ON' : 'Drive: OFF';
        funscriptStatusEl.textContent = `Funscript: loaded (${actions.length} actions) - ${driveStatus}`;

        const ms = Number.isFinite(timeMs) ? Math.max(0, timeMs) : 0;
        let idx = Number.isInteger(state.funscriptPointer) ? state.funscriptPointer : -1;
        if (idx >= actions.length) idx = actions.length - 1;
        if (idx < -1) idx = -1;

        if (idx + 1 < actions.length && actions[idx + 1].at <= ms) {
          while (idx + 1 < actions.length && actions[idx + 1].at <= ms) idx++;
        } else if (idx >= 0 && actions[idx].at > ms) {
          while (idx >= 0 && actions[idx].at > ms) idx--;
        } else if (idx === -1 && actions[0].at <= ms) {
          while (idx + 1 < actions.length && actions[idx + 1].at <= ms) idx++;
        }

        state.funscriptPointer = idx;

        const prev = idx >= 0 ? actions[idx] : null;
        const next = idx + 1 < actions.length ? actions[idx + 1] : null;
        let pos;
        if (!prev && next) pos = next.pos;
        else if (!next && prev) pos = prev.pos;
        else if (prev && next) {
          const span = Math.max(1, next.at - prev.at);
          const ratio = Math.min(1, Math.max(0, (ms - prev.at) / span));
          pos = prev.pos + (next.pos - prev.pos) * ratio;
        } else {
          pos = 0;
        }

        if (!Number.isFinite(pos)) pos = 0;

        state.lastFunscriptValue = pos;
        const pct = Math.max(0, Math.min(100, pos));
        funscriptMeterEl.style.transform = `scaleX(${pct / 100})`;
        const tcodeVal = String(Math.round((pct / 100) * 999)).padStart(3, '0');
        const axis = String(state.axis || 'L0').toUpperCase();
        funscriptLabelEl.textContent = `${axis}: ${Math.round(pct)}% (${tcodeVal})`;
      }

      function formatTime(ms) {
        if (!Number.isFinite(ms) || ms < 0) return '--:--';
        const totalSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        const mm = String(minutes).padStart(2, '0');
        const ss = String(seconds).padStart(2, '0');
        if (hours > 0) {
          return `${hours}:${mm}:${ss}`;
        }
        return `${minutes}:${ss}`;
      }

      async function tick() {
        const v = $('video');
        const fps = state.noVideo ? (state.remoteFps || 30) : 30;

        let timeMs = 0;
        let paused = true;

        if (!state.noVideo && v instanceof HTMLVideoElement) {
          timeMs = Math.round((v.currentTime || 0) * 1000);
          paused = Boolean(v.paused);
        } else if (state.noVideo && state.followRemote) {
          const base = state.remoteTimeMs || 0;
          paused = Boolean(state.remotePaused);
          if (paused) timeMs = base;
          else timeMs = base + Math.max(0, Date.now() - (state.remoteLastUpdateAt || Date.now()));
        }

        const frame = currentFrame(timeMs / 1000, fps);

        // Update progress bar and time display.
        const progress = $('progress');
        let durationMs = state.durationMs;
        if (!state.noVideo && v instanceof HTMLVideoElement) {
          const d = Number(v.duration);
          if (Number.isFinite(d) && d > 0) durationMs = Math.round(d * 1000);
        }

        if (progress instanceof HTMLInputElement) {
          if (durationMs && durationMs > 0) {
            progress.max = String(durationMs);
            progress.value = String(Math.max(0, Math.min(durationMs, timeMs)));
            progress.disabled = false;
          } else {
            // Unknown duration yet; keep a stable bar until ffprobe/video metadata arrives.
            progress.max = '1';
            progress.value = '0';
            progress.disabled = true;
          }
        }

        if (progressTimeEl) {
          progressTimeEl.textContent = `${formatTime(timeMs)} / ${formatTime(durationMs)}`;
        }

        updateFunscriptUi(timeMs);

        const canReport = Boolean(state.current) && (!state.noVideo ? (v instanceof HTMLVideoElement && Number.isFinite(v.currentTime)) : state.followRemote);

        if (canReport) {
          $('playback').textContent = `t=${timeMs}ms frame=${frame} fps=${fps}`;
          // Persist playback state only when playing the stream locally.
          if (!state.noVideo) {
            if (Date.now() - state.lastPlaybackPutAt > 1000) {
              state.lastPlaybackPutAt = Date.now();
              try {
                await apiJson('/api/playback', {
                  method: 'PUT',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    clientId: state.clientId,
                    mediaId: state.current.id,
                    timeMs,
                    fps,
                    frame
                  })
                });
              } catch {}
            }
          }

          // Publish sync state only when we're the "driver".
          // If followRemote is ON, we shouldn't send updates.
          // Throttle automatic updates to prevent feedback loops.
          if (!state.followRemote && !state.noVideo) {
            // Don't send automatic updates if we're still applying remote state
            if (Date.now() >= state.applyingRemoteUntil) {
              sendSyncUpdate({ mediaId: state.current.id, timeMs, paused, fps, frame });
            }
          }

          // Drive serial from funscript.
          if (state.drive && state.funscript?.actions?.length) {
            const actions = state.funscript.actions;
            // Apply script delay by adjusting the time we're looking up
            const adjustedTimeMs = timeMs - state.scriptDelay;
            while (state.funIndex + 1 < actions.length && actions[state.funIndex + 1].at <= adjustedTimeMs) {
              state.funIndex++;
              const act = actions[state.funIndex];
              const axis = String(state.axis || 'L0').toUpperCase();
              
              // Get raw position from funscript
              let pos = Math.max(0, Math.min(100, Math.round(act.pos)));
              
              // Apply inversion if enabled
              if (state.invertScript) {
                pos = 100 - pos;
              }
              
              // Apply axis-specific min/max limits
              const limits = state.axisLimits[axis] || { min: 0, max: 100 };
              const range = limits.max - limits.min;
              pos = limits.min + (pos / 100) * range;
              pos = Math.max(0, Math.min(100, Math.round(pos)));
              
              const scaled = Math.round((pos / 100) * 999);
              const vvv = String(scaled).padStart(3, '0');
              const line = `${axis}${vvv}`;
              try { await window.mv.tcodeSend(line); } catch {}
            }
          }
        }

        window.requestAnimationFrame(tick);
      }

      async function listPorts() {
        try {
          if (!window.mv || typeof window.mv.listSerialPorts !== 'function') {
            logToConsole('error', 'Serial API not available - preload script may not have loaded correctly');
            const sel = $('port');
            sel.innerHTML = '<option value="">Serial API not available</option>';
            return;
          }
          logToConsole('log', 'Listing serial ports...');
          const ports = await window.mv.listSerialPorts();
          logToConsole('log', `Found ${ports.length} serial port(s):`, ports.map(p => p.path).join(', ') || 'none');
          const sel = $('port');
          if (ports.length === 0) {
            sel.innerHTML = '<option value="">No serial ports found</option>';
          } else {
            sel.innerHTML = ports.map((p) => `<option value='${esc(p.path)}'>${esc(p.path)}</option>`).join('');
          }
        } catch (err) {
          const errMsg = err instanceof Error ? err.message : String(err);
          logToConsole('error', 'Failed to list serial ports:', errMsg);
          const sel = $('port');
          sel.innerHTML = '<option value="">Error loading ports</option>';
        }
      }

      $('serverUrl').addEventListener('change', (e) => { state.serverUrl = e.target.value; });
      $('applyServer').addEventListener('click', async () => {
        state.serverUrl = $('serverUrl').value.trim() || state.serverUrl;
        savePrefs();
        try { if (state.ws) state.ws.close(); } catch {}
        connectWs();
        state.page = 1;
        await refresh();
      });
      $('q').addEventListener('input', (e) => {
        state.q = e.target.value;
        state.page = 1;
        window.clearTimeout(window.__qt);
        window.__qt = window.setTimeout(() => refresh(), 200);
      });

      $('refresh').addEventListener('click', () => refresh());
      $('prev').addEventListener('click', async () => { state.page = Math.max(1, state.page - 1); await refresh(); });
      $('next').addEventListener('click', async () => {
        const maxPage = Math.max(1, Math.ceil(state.total / state.pageSize));
        state.page = Math.min(maxPage, state.page + 1);
        await refresh();
      });

      $('ports').addEventListener('click', () => listPorts());
      $('connect').addEventListener('click', async () => {
        const portPath = $('port').value;
        const baudRate = Number($('baud').value || 115200);
        await window.mv.serialConnect({ path: portPath, baudRate });
        setStatus('Serial connected');
        state.serialConnected = true;
        state.lastSerialPort = portPath;
        state.lastSerialBaud = baudRate;
        setSerialPill(true);
        savePrefs();
      });
      $('disconnect').addEventListener('click', async () => {
        await window.mv.serialDisconnect();
        setStatus('Serial disconnected');
        state.serialConnected = false;
        setSerialPill(false);
      });

      $('autoConnectSerial').addEventListener('change', () => {
        state.autoConnectSerial = $('autoConnectSerial').checked;
        savePrefs();
      });

      function setAxis(val) {
        state.axis = String(val || 'L0').toUpperCase();
        savePrefs();
      }

      $('axisSelect').addEventListener('change', () => {
        const sel = $('axisSelect').value;
        if (sel === 'CUSTOM') {
          $('axisCustom').style.display = '';
          $('axisCustom').focus();
          setAxis($('axisCustom').value);
        } else {
          $('axisCustom').style.display = 'none';
          $('axisCustom').value = sel;
          setAxis(sel);
        }
      });

      $('axisCustom').addEventListener('input', () => setAxis($('axisCustom').value));

      $('toggleDrive').addEventListener('click', () => {
        state.drive = !state.drive;
        $('toggleDrive').textContent = state.drive ? 'Drive: ON' : 'Drive: OFF';
        setDrivePill();
        savePrefs();
        state.funIndex = -1;
        updateFunscriptUi(state.lastFunscriptValue);
      });

      $('autoHomeEnabled').addEventListener('change', () => {
        state.autoHomeEnabled = $('autoHomeEnabled').checked;
        savePrefs();
        if (!state.autoHomeEnabled) cancelAutoHome();
      });

      $('btnToggleAutoHomeSettings').addEventListener('click', () => {
        const el = $('autoHomeSettings');
        el.style.display = el.style.display === 'none' ? '' : 'none';
      });

      $('autoHomePosition').addEventListener('input', () => {
        state.autoHomePosition = Number($('autoHomePosition').value) || 0;
        savePrefs();
      });

      $('autoHomeDelay').addEventListener('input', () => {
        state.autoHomeDelay = Number($('autoHomeDelay').value) || 0;
        savePrefs();
      });

      $('autoHomeTransition').addEventListener('input', () => {
        state.autoHomeTransition = Number($('autoHomeTransition').value) || 1000;
        savePrefs();
      });

      // Settings modal
      $('btnSettings').addEventListener('click', () => {
        // Update UI from state
        $('invertScriptCheck').checked = state.invertScript;
        $('scriptDelayInput').value = state.scriptDelay;
        
        // Update axis sliders
        ['L0', 'L1', 'L2', 'L3'].forEach(axis => {
          $(`${axis}MinSlider`).value = state.axisLimits[axis].min;
          $(`${axis}MaxSlider`).value = state.axisLimits[axis].max;
          $(`${axis}MinLabel`).textContent = state.axisLimits[axis].min;
          $(`${axis}MaxLabel`).textContent = state.axisLimits[axis].max;
        });
        
        $('settingsModal').style.display = '';
      });

      $('btnCloseSettings').addEventListener('click', () => {
        $('settingsModal').style.display = 'none';
      });

      $('btnResetSettings').addEventListener('click', () => {
        state.invertScript = false;
        state.scriptDelay = 0;
        state.axisLimits = {
          L0: { min: 0, max: 100 },
          L1: { min: 0, max: 100 },
          L2: { min: 0, max: 100 },
          L3: { min: 0, max: 100 },
        };
        savePrefs();
        
        // Update UI
        $('invertScriptCheck').checked = false;
        $('scriptDelayInput').value = 0;
        ['L0', 'L1', 'L2', 'L3'].forEach(axis => {
          $(`${axis}MinSlider`).value = 0;
          $(`${axis}MaxSlider`).value = 100;
          $(`${axis}MinLabel`).textContent = 0;
          $(`${axis}MaxLabel`).textContent = 100;
        });
      });

      $('invertScriptCheck').addEventListener('change', () => {
        state.invertScript = $('invertScriptCheck').checked;
        savePrefs();
      });

      $('scriptDelayInput').addEventListener('input', () => {
        state.scriptDelay = Number($('scriptDelayInput').value) || 0;
        savePrefs();
      });

      // Axis sliders
      ['L0', 'L1', 'L2', 'L3'].forEach(axis => {
        $(`${axis}MinSlider`).addEventListener('input', (e) => {
          const minVal = Number(e.target.value);
          const maxVal = state.axisLimits[axis].max;
          if (minVal > maxVal) {
            e.target.value = maxVal;
            return;
          }
          state.axisLimits[axis].min = minVal;
          $(`${axis}MinLabel`).textContent = minVal;
          savePrefs();
        });

        $(`${axis}MaxSlider`).addEventListener('input', (e) => {
          const maxVal = Number(e.target.value);
          const minVal = state.axisLimits[axis].min;
          if (maxVal < minVal) {
            e.target.value = minVal;
            return;
          }
          state.axisLimits[axis].max = maxVal;
          $(`${axis}MaxLabel`).textContent = maxVal;
          savePrefs();
        });
      });

      $('btnPlayPause').addEventListener('click', async () => {
        const v = $('video');
        if (!(v instanceof HTMLVideoElement)) return;
        if (state.noVideo) return;
        if (v.paused) {
          try { await v.play(); } catch {}
          cancelAutoHome(); // Cancel auto-home when playing
        } else {
          try { v.pause(); } catch {}
          triggerAutoHome(); // Trigger auto-home when pausing
        }
        // Sync the play/pause state to web UI
        if (state.current) {
          const fps = 30;
          const timeMs = Math.round((v.currentTime || 0) * 1000);
          const frame = currentFrame(v.currentTime || 0, fps);
          sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: v.paused, fps, frame }, true);
        }
      });

      $('btnVideo').addEventListener('click', () => {
        state.noVideo = !state.noVideo;
        savePrefs();
        setVideoModeUi();
        
        // When toggling video mode, we try to preserve playback state as much as possible
        const v = $('video');
        if (!state.noVideo) {
          // Turning Video ON
          if (state.current?.id && v instanceof HTMLVideoElement) {
             const wasPaused = state.remotePaused ?? true; // fallback to paused
             const currentTime = state.durationMs ? (state.lastFunscriptValue / 100 * state.durationMs / 1000) : 0; // rough guess if we were in no-video mode, actually better to use last known time
             
             // Reload stream but try to seek to where we were
             // openMedia is too destructive (resets funscript state), so we manually set src
             v.src = new URL(`/api/media/${state.current.id}/stream`, state.serverUrl).toString();
             v.currentTime = state.remoteTimeMs ? state.remoteTimeMs / 1000 : 0;
             if (!wasPaused) {
                 v.play().catch(()=>{});
             }
          }
        } else {
           // Turning Video OFF
           if (v instanceof HTMLVideoElement) {
             v.pause();
             v.removeAttribute('src');
             v.load();
           }
        }
      });

      $('btnFollow').addEventListener('click', () => {
        state.followRemote = !state.followRemote;
        $('btnFollow').textContent = state.followRemote ? 'Follow remote: ON' : 'Follow remote: OFF';
        savePrefs();

        // If we just became the driver, immediately publish our current state.
        if (!state.followRemote) {
          const v = $('video');
          if (state.current && v instanceof HTMLVideoElement) {
            const fps = 30;
            const timeMs = Math.round((v.currentTime || 0) * 1000);
            const frame = currentFrame(v.currentTime || 0, fps);
            sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: v.paused, fps, frame });
          }
        }
      });

      $('followSource').addEventListener('change', () => {
        state.followSource = String($('followSource').value || 'any');
        savePrefs();
      });

      loadPrefs();
      $('serverUrl').value = state.serverUrl;

      // Init axis dropdown
      const common = ['L0','L1','L2','L3'];
      if (common.includes(state.axis)) {
        $('axisSelect').value = state.axis;
        $('axisCustom').value = state.axis;
        $('axisCustom').style.display = 'none';
      } else {
        $('axisSelect').value = 'CUSTOM';
        $('axisCustom').value = state.axis;
        $('axisCustom').style.display = '';
      }

      $('toggleDrive').textContent = state.drive ? 'Drive: ON' : 'Drive: OFF';
      $('btnFollow').textContent = state.followRemote ? 'Follow remote: ON' : 'Follow remote: OFF';

      // Auto-home UI initialization
      $('autoHomeEnabled').checked = state.autoHomeEnabled;
      $('autoHomePosition').value = state.autoHomePosition;
      $('autoHomeDelay').value = state.autoHomeDelay;
      $('autoHomeTransition').value = state.autoHomeTransition;
      $('autoHomeSettings').style.display = 'none'; // always start hidden unless manually toggled

      // Auto-connect serial UI initialization
      $('autoConnectSerial').checked = state.autoConnectSerial;
      if (state.lastSerialBaud) $('baud').value = state.lastSerialBaud;

      setVideoModeUi();
      updateFollowSourceOptions();

      setWsPill(false);
      setSerialPill(false);
      setDrivePill();
      setFsPill();

      setStatus('Ready');
      connectWs();
      await listPorts();
      
      // Auto-connect to serial if enabled
      if (state.autoConnectSerial && state.lastSerialPort) {
        // Wait a bit for port list to be ready
        setTimeout(async () => {
          try {
            // Check if the last used port is still available
            const select = $('port');
            const options = Array.from(select.options).map(opt => opt.value);
            if (options.includes(state.lastSerialPort)) {
              select.value = state.lastSerialPort;
              logToConsole('log', `Auto-connecting to ${state.lastSerialPort}...`);
              await window.mv.serialConnect({ path: state.lastSerialPort, baudRate: state.lastSerialBaud });
              state.serialConnected = true;
              setSerialPill(true);
              setStatus('Serial auto-connected');
              logToConsole('log', 'Serial auto-connect successful');
            } else {
              logToConsole('warn', `Auto-connect failed: ${state.lastSerialPort} not found`);
            }
          } catch (err) {
            logToConsole('error', 'Auto-connect failed:', err);
          }
        }, 500);
      }
      
      await refresh();

      const v = $('video');
      if (v instanceof HTMLVideoElement) {
        const fps = 30;
        const push = () => {
          // Don't send sync updates if we're currently applying remote state (prevent feedback loop)
          if (state.isApplyingRemoteState) return;
          if (!state.current) return;
          const timeMs = Math.round((v.currentTime || 0) * 1000);
          const frame = currentFrame(v.currentTime || 0, fps);
          logToConsole('log', `Manual video ${v.paused ? 'pause' : 'play'} - syncing to remote`);
          // Manual user interactions always sync (force=true), regardless of follow-remote state
          sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: v.paused, fps, frame }, true);
        };
        v.addEventListener('play', push);
        v.addEventListener('pause', push);
        v.addEventListener('seeked', push);
      }

      // Progress bar seeking
      const progressBar = $('progress');
      if (progressBar instanceof HTMLInputElement) {
        progressBar.addEventListener('input', () => {
          if (state.noVideo || !state.current) return;
          const v = $('video');
          if (!(v instanceof HTMLVideoElement)) return;
          const seekMs = Number(progressBar.value);
          if (!Number.isFinite(seekMs)) return;
          try {
            v.currentTime = seekMs / 1000;
            // Immediately sync the seek to web UI
            const fps = 30;
            const frame = currentFrame(seekMs / 1000, fps);
            sendSyncUpdate({ mediaId: state.current.id, timeMs: seekMs, paused: v.paused, fps, frame }, true);
          } catch {}
        });
      }

      // Console view
      $('btnClearConsole').addEventListener('click', () => {
        state.consoleLogs = [];
        updateConsoleView();
        logToConsole('log', 'Console cleared');
      });

      logToConsole('log', 'Desktop client initialized');
      
      // Check if preload API is available
      if (window.mv) {
        logToConsole('log', 'Preload API available:', Object.keys(window.mv).join(', '));
      } else {
        logToConsole('error', 'Preload API (window.mv) not available! Check that preload.js is loaded correctly.');
      }

      tick();
    </script>
  </body>
</html>
