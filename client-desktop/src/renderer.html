<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>MediaViewer Desktop</title>
    <style>
      :root { color-scheme: dark; }
      body { margin: 0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; background: #0b0c0f; color: #e6e6e6; }
      header { padding: 12px 16px; border-bottom: 1px solid #222; display: flex; gap: 12px; align-items: center; justify-content: space-between; }
      header h1 { font-size: 14px; margin: 0; }
      .wrap { display: grid; grid-template-columns: 380px 380px 1fr; height: calc(100vh - 50px); }
      .left { border-right: 1px solid #222; padding: 12px; overflow: auto; display: grid; gap: 12px; }
      .middle { border-right: 1px solid #222; padding: 12px; overflow: auto; display: grid; gap: 12px; }
      .right { padding: 12px; overflow: auto; display: grid; gap: 10px; }
      .row { display: flex; gap: 8px; align-items: center; }
      input, select { width: 100%; padding: 10px 12px; border-radius: 8px; border: 1px solid #2a2f3a; background: #11131a; color: #e6e6e6; }
      button { padding: 10px 12px; border-radius: 8px; border: 1px solid #2a2f3a; background: #11131a; color: #e6e6e6; cursor: pointer; }
      button:disabled { opacity: 0.6; cursor: not-allowed; }
      .list { margin-top: 12px; display: grid; gap: 8px; }
      .item { border: 1px solid #222; border-radius: 10px; padding: 10px; cursor: pointer; background: #0f1117; white-space: normal; overflow-wrap: anywhere; word-break: break-word; }
      .item.active { outline: 2px solid #2a2f3a; }
      .item small { opacity: 0.8; }
      video { width: 100%; max-height: 70vh; background: #000; }
      input[type="range"] { width: 100%; }
      .small { font-size: 12px; opacity: 0.85; }
      .pill { display: inline-block; padding: 2px 8px; border: 1px solid #2a2f3a; border-radius: 999px; font-size: 11px; margin-left: 6px; }
      .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
      .card { border: 1px solid #222; border-radius: 12px; padding: 12px; background: #0f1117; }
      .card h2 { margin: 0 0 10px 0; font-size: 12px; font-weight: 600; opacity: 0.9; }
      .kpi { display: flex; gap: 8px; flex-wrap: wrap; justify-content: flex-end; }
      .kpi .pill { margin-left: 0; }
      .stack { display: grid; gap: 8px; }
    </style>
  </head>
  <body>
    <header>
      <h1>MediaViewer Desktop</h1>
      <div class="kpi">
        <span class="pill" id="wsPill">WS: —</span>
        <span class="pill" id="serialPill">Serial: —</span>
        <span class="pill" id="drivePill">Drive: OFF</span>
        <span class="pill" id="fsPill">Funscript: —</span>
      </div>
    </header>

    <div class="wrap">
      <div class="left">
        <div class="card">
          <h2>Server</h2>
          <div class="stack">
            <div>
              <div class="small">Server URL</div>
              <div class="row">
                <input id="serverUrl" value="http://localhost:3000" />
                <button id="applyServer" style="max-width: 120px;">Apply</button>
              </div>
            </div>
            <div class="row"><div class="small" id="status"></div></div>
          </div>
        </div>

        <div class="card">
          <h2>Serial</h2>
          <div class="stack">
            <div class="row">
              <select id="port"></select>
              <input id="baud" value="115200" style="max-width: 120px;" />
            </div>
            <div class="row">
              <button id="ports">List Ports</button>
              <button id="connect">Connect</button>
              <button id="disconnect">Disconnect</button>
            </div>
          </div>
        </div>

        <div class="card">
          <h2>Funscript → TCode</h2>
          <div class="stack">
            <div class="row">
              <select id="axisSelect" style="max-width: 220px;">
                <option value="L0">L0 (primary)</option>
                <option value="L1">L1</option>
                <option value="L2">L2</option>
                <option value="L3">L3</option>
                <option value="CUSTOM">Custom…</option>
              </select>
              <input id="axisCustom" value="L0" style="max-width: 120px; display:none;" />
              <button id="toggleDrive" style="max-width: 140px;">Drive: OFF</button>
            </div>
            <div class="small">Sends TCode lines based on the funscript actions while playing.</div>
          </div>
        </div>
      </div>

      <div class="middle">
        <div class="card">
          <h2>Media</h2>
          <div class="stack">
            <div class="grid2">
              <div>
                <div class="small">Search</div>
                <input id="q" placeholder="filename" />
              </div>
              <div>
                <div class="small">Paging</div>
                <div class="row">
                  <button id="prev" style="max-width: 90px;">Prev</button>
                  <button id="next" style="max-width: 90px;">Next</button>
                  <div class="small" id="pageLabel" style="white-space: nowrap;"></div>
                </div>
              </div>
            </div>
            <div class="row">
              <button id="refresh" style="max-width: 120px;">Refresh</button>
              <div class="small"></div>
            </div>
            <div class="list" id="list"></div>
          </div>
        </div>
      </div>

      <div class="right">
        <div class="row" style="justify-content: space-between; gap: 12px; flex-wrap: wrap;">
          <div class="small" id="now"></div>
          <div class="row" style="gap: 8px;">
            <button id="btnPlayPause" style="max-width: 140px;">Play/Pause</button>
            <button id="btnVideo" style="max-width: 140px;">Video: ON</button>
            <button id="btnFollow" style="max-width: 220px;">Follow remote: ON</button>
          </div>
        </div>

        <div class="row" style="justify-content: flex-end; gap: 8px; flex-wrap: wrap;">
          <div class="small" style="white-space: nowrap;">Follow source</div>
          <select id="followSource" style="max-width: 260px;"></select>
        </div>

        <video id="video" controls></video>
        <input id="progress" type="range" min="0" max="1" value="0" step="1" disabled />
        <div class="small" id="noVideoHint" style="display:none;">No-video mode: using sync playback time only (no /stream requests).</div>
        <div class="small" id="playback"></div>
      </div>
    </div>

    <script type="module">
      const state = {
        serverUrl: 'http://localhost:3000',
        q: '',
        page: 1,
        pageSize: 30,
        total: 0,
        items: [],
        current: null,
        funscript: null,
        funIndex: -1,
        drive: false,
        axis: 'L0',
        clientId: 'desktop-' + Math.random().toString(16).slice(2),
        sessionId: 'default',
        ws: null,
        wsConnected: false,
        applyingRemoteUntil: 0,
        lastSyncSentAt: 0,
        lastPlaybackPutAt: 0,
        followRemote: true,
        noVideo: false,
        remoteTimeMs: 0,
        remotePaused: true,
        remoteFps: 30,
        remoteLastUpdateAt: 0,
        lastAppliedRemotePaused: null,
        serialConnected: false,

        durationMs: null,
        durationCache: new Map(),
        durationInFlightFor: null,

        followSource: 'any',
        seenSources: new Map(),
      };

      const $ = (id) => document.getElementById(id);
      const statusEl = $('status');
      const wsPill = $('wsPill');
      const serialPill = $('serialPill');
      const drivePill = $('drivePill');
      const fsPill = $('fsPill');

      async function apiJson(path, opts) {
        const url = new URL(path, state.serverUrl);
        const res = await fetch(url.toString(), opts);
        if (!res.ok) throw new Error(await res.text());
        return res.json();
      }

      async function ensureDurationMs(mediaId) {
        if (!mediaId) return;
        if (state.durationCache.has(mediaId)) {
          state.durationMs = state.durationCache.get(mediaId);
          return;
        }
        if (state.durationInFlightFor === mediaId) return;
        state.durationInFlightFor = mediaId;
        try {
          const r = await apiJson(`/api/media/${encodeURIComponent(mediaId)}/probe`);
          const ms = typeof r?.durationMs === 'number' && Number.isFinite(r.durationMs) && r.durationMs > 0 ? Math.round(r.durationMs) : null;
          state.durationCache.set(mediaId, ms);
          state.durationMs = ms;
        } catch {
          state.durationCache.set(mediaId, null);
          state.durationMs = null;
        } finally {
          if (state.durationInFlightFor === mediaId) state.durationInFlightFor = null;
        }
      }

      function setStatus(s) { statusEl.textContent = s; }

      function setWsPill(connected) {
        wsPill.textContent = connected ? 'WS: connected' : 'WS: disconnected';
      }

      function setSerialPill(connected) {
        serialPill.textContent = connected ? 'Serial: connected' : 'Serial: disconnected';
      }

      function setDrivePill() {
        drivePill.textContent = state.drive ? 'Drive: ON' : 'Drive: OFF';
      }

      function setFsPill() {
        const n = state.funscript?.actions?.length;
        if (typeof n === 'number') fsPill.textContent = `Funscript: ${n} actions`;
        else fsPill.textContent = 'Funscript: —';
      }

      function loadPrefs() {
        try {
          const p = JSON.parse(localStorage.getItem('mvDesktopPrefs') || 'null');
          if (p && typeof p === 'object') {
            if (typeof p.serverUrl === 'string') state.serverUrl = p.serverUrl;
            if (typeof p.axis === 'string') state.axis = p.axis;
            if (typeof p.drive === 'boolean') state.drive = p.drive;
            if (typeof p.followRemote === 'boolean') state.followRemote = p.followRemote;
            if (typeof p.noVideo === 'boolean') state.noVideo = p.noVideo;
            if (typeof p.followSource === 'string') state.followSource = p.followSource;
          }
        } catch {}
      }

      function savePrefs() {
        localStorage.setItem('mvDesktopPrefs', JSON.stringify({
          serverUrl: state.serverUrl,
          axis: state.axis,
          drive: state.drive,
          followRemote: state.followRemote,
          noVideo: state.noVideo,
          followSource: state.followSource,
        }));
      }

      function labelForSource(id) {
        if (!id) return 'Any';
        if (id === 'any') return 'Any';
        return id;
      }

      function updateFollowSourceOptions() {
        const sel = $('followSource');
        if (!(sel instanceof HTMLSelectElement)) return;

        const entries = Array.from(state.seenSources.entries())
          .sort((a, b) => b[1] - a[1])
          .map(([id]) => id);

        const opts = ['any', ...entries];
        sel.innerHTML = opts
          .map((id) => `<option value="${esc(id)}" ${id === state.followSource ? 'selected' : ''}>${esc(labelForSource(id))}</option>`)
          .join('');

        if (!opts.includes(state.followSource)) {
          state.followSource = 'any';
          savePrefs();
          sel.value = 'any';
        }
      }

      function setVideoModeUi() {
        $('btnVideo').textContent = state.noVideo ? 'Video: OFF' : 'Video: ON';
        $('btnPlayPause').disabled = state.noVideo;

        const v = $('video');
        if (v instanceof HTMLVideoElement) {
          v.style.display = state.noVideo ? 'none' : '';
        }

        const hint = $('noVideoHint');
        if (hint) hint.style.display = state.noVideo ? '' : 'none';

        if (state.noVideo && v instanceof HTMLVideoElement) {
          // Ensure we don't keep any active stream.
          try {
            v.pause();
            v.removeAttribute('src');
            v.load();
          } catch {}
        }
      }

      function wsUrlFromHttp(httpUrl) {
        const u = new URL(httpUrl);
        u.protocol = u.protocol === 'https:' ? 'wss:' : 'ws:';
        u.pathname = '/ws';
        u.search = '';
        u.hash = '';
        return u.toString();
      }

      function connectWs() {
        if (state.ws && (state.ws.readyState === 0 || state.ws.readyState === 1)) return;
        const ws = new WebSocket(wsUrlFromHttp(state.serverUrl));
        state.ws = ws;

        ws.addEventListener('open', () => {
          state.wsConnected = true;
          setStatus('WS connected');
          setWsPill(true);
          ws.send(JSON.stringify({ type: 'sync:hello', clientId: state.clientId, sessionId: state.sessionId }));
        });

        ws.addEventListener('close', () => {
          state.wsConnected = false;
          setStatus('WS disconnected');
          setWsPill(false);
          window.setTimeout(() => connectWs(), 1000);
        });

        ws.addEventListener('message', (evt) => {
          let msg;
          try { msg = JSON.parse(String(evt.data)); } catch { return; }
          if (!msg || msg.type !== 'sync:state' || !msg.state) return;

          const src = String(msg.state.fromClientId || '');
          if (src && src !== state.clientId) {
            state.seenSources.set(src, Date.now());
            updateFollowSourceOptions();
          }

          applyRemoteSyncState(msg.state);
        });
      }

      function sendSyncUpdate(update) {
        if (!state.wsConnected || !state.ws || state.ws.readyState !== 1) return;
        if (Date.now() < state.applyingRemoteUntil) return;
        const now = Date.now();
        if (now - state.lastSyncSentAt < 200) return;
        state.lastSyncSentAt = now;
        state.ws.send(JSON.stringify({
          type: 'sync:update',
          sessionId: state.sessionId,
          clientId: state.clientId,
          ...update,
        }));
      }

      async function applyRemoteSyncState(remote) {
        if (!state.followRemote) return;
        if (!remote || !remote.mediaId) return;
        if (remote.fromClientId && remote.fromClientId === state.clientId) return;

        if (state.followSource && state.followSource !== 'any') {
          if (String(remote.fromClientId || '') !== state.followSource) return;
        }

        const id = String(remote.mediaId);

        // Follow remote media selection.
        if (!state.current || state.current.id !== id) {
          // ensure list contains it or fetch minimal info
          const it = state.items.find((x) => x.id === id) || { id, filename: id, mediaType: 'video', hasFunscript: false };
          await openMedia(it.id, { suppressSync: true });
        }

        state.applyingRemoteUntil = Date.now() + 800;
        state.remoteTimeMs = Math.max(0, Math.round(Number(remote.timeMs) || 0));
        // Be strict about paused parsing (handles booleans, 0/1, and 'true'/'false').
        const pausedRaw = remote.paused;
        const paused = pausedRaw === true || pausedRaw === 1 || pausedRaw === '1' || pausedRaw === 'true';
        state.remotePaused = paused;
        state.remoteFps = Math.max(1, Math.round(Number(remote.fps) || 30));
        state.remoteLastUpdateAt = Date.now();

        // In no-video mode, do not load/control the stream.
        if (state.noVideo) return;

        const v = $('video');
        if (!(v instanceof HTMLVideoElement)) return;

        const targetTime = Math.max(0, state.remoteTimeMs / 1000);
        if (Number.isFinite(v.currentTime) && Math.abs(v.currentTime - targetTime) > 0.5) {
          try { v.currentTime = targetTime; } catch {}
        }

        // Avoid rapid play/pause toggling: only apply when the desired paused state changes.
        if (state.lastAppliedRemotePaused !== state.remotePaused) {
          state.lastAppliedRemotePaused = state.remotePaused;
          if (state.remotePaused) {
            try { v.pause(); } catch {}
          } else {
            try { await v.play(); } catch {}
          }
        }
      }

      function esc(s) {
        return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'",'&#039;');
      }

      async function refresh() {
        setStatus('Loading list...');
        const url = new URL('/api/media', state.serverUrl);
        url.searchParams.set('q', state.q);
        url.searchParams.set('page', String(state.page));
        url.searchParams.set('pageSize', String(state.pageSize));
        const res = await fetch(url.toString());
        if (!res.ok) throw new Error(await res.text());
        const data = await res.json();
        state.total = data.total;
        state.items = data.items;
        renderList();
        renderPager();
        setStatus('Ready');
      }

      function renderPager() {
        const maxPage = Math.max(1, Math.ceil(state.total / state.pageSize));
        $('pageLabel').textContent = `Page ${state.page} / ${maxPage} (${state.total})`;
        $('prev').disabled = state.page <= 1;
        $('next').disabled = state.page >= maxPage;
      }

      function renderList() {
        $('list').innerHTML = state.items.map((it) => {
          const fs = it.hasFunscript ? `<span class='pill'>funscript</span>` : '';
          const active = state.current?.id === it.id ? 'active' : '';
          return `<div class='item ${active}' data-id='${it.id}'>${esc(it.filename)} ${fs}<br/><small>${esc(it.mediaType)}</small></div>`;
        }).join('');
        for (const div of $('list').querySelectorAll('.item')) {
          div.addEventListener('click', () => openMedia(div.getAttribute('data-id')));
        }
      }

      async function openMedia(id, opts = {}) {
        const suppressSync = Boolean(opts.suppressSync);
        const it = state.items.find((x) => x.id === id);
        // When following remote, the media might not be in the currently loaded page.
        // Keep a placeholder so progress/UI can still update.
        state.current = it || { id, filename: id, mediaType: 'video', hasFunscript: false };
        state.funscript = null;
        state.funIndex = -1;
        state.durationMs = null;
        $('now').textContent = it ? `Now: ${it.filename}` : `Now: ${id}`;

        const v = $('video');
        if (v instanceof HTMLVideoElement) {
          if (state.noVideo) {
            try {
              v.pause();
              v.removeAttribute('src');
              v.load();
            } catch {}

            // No-video mode: fetch duration via ffprobe so we can render a real progress bar.
            ensureDurationMs(id);
          } else {
            v.src = new URL(`/api/media/${id}/stream`, state.serverUrl).toString();
          }
        }

        if (!suppressSync && !state.followRemote) {
          sendSyncUpdate({ mediaId: id, timeMs: 0, paused: true, fps: 30, frame: 0 });
        }

        try {
          state.funscript = await apiJson(`/api/media/${id}/funscript`);
          state.funscript.actions.sort((a,b) => a.at - b.at);
        } catch {
          state.funscript = null;
        }

        setFsPill();
        renderList();
      }

      function currentFrame(timeSeconds, fps) {
        return Math.max(0, Math.floor(timeSeconds * fps));
      }

      async function tick() {
        const v = $('video');
        const fps = state.noVideo ? (state.remoteFps || 30) : 30;

        let timeMs = 0;
        let paused = true;

        if (!state.noVideo && v instanceof HTMLVideoElement) {
          timeMs = Math.round((v.currentTime || 0) * 1000);
          paused = Boolean(v.paused);
        } else if (state.noVideo && state.followRemote) {
          const base = state.remoteTimeMs || 0;
          paused = Boolean(state.remotePaused);
          if (paused) timeMs = base;
          else timeMs = base + Math.max(0, Date.now() - (state.remoteLastUpdateAt || Date.now()));
        }

        const frame = currentFrame(timeMs / 1000, fps);

        // Update progress bar.
        const progress = $('progress');
        if (progress instanceof HTMLInputElement) {
          let durationMs = state.durationMs;
          if (!state.noVideo && v instanceof HTMLVideoElement) {
            const d = Number(v.duration);
            if (Number.isFinite(d) && d > 0) durationMs = Math.round(d * 1000);
          }
          if (durationMs && durationMs > 0) {
            progress.max = String(durationMs);
            progress.value = String(Math.max(0, Math.min(durationMs, timeMs)));
          } else {
            // Unknown duration yet; keep a stable bar until ffprobe/video metadata arrives.
            progress.max = '1';
            progress.value = '0';
          }
        }

        const canReport = Boolean(state.current) && (!state.noVideo ? (v instanceof HTMLVideoElement && Number.isFinite(v.currentTime)) : state.followRemote);

        if (canReport) {
          $('playback').textContent = `t=${timeMs}ms frame=${frame} fps=${fps}`;
          // Persist playback state only when playing the stream locally.
          if (!state.noVideo) {
            if (Date.now() - state.lastPlaybackPutAt > 1000) {
              state.lastPlaybackPutAt = Date.now();
              try {
                await apiJson('/api/playback', {
                  method: 'PUT',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    clientId: state.clientId,
                    mediaId: state.current.id,
                    timeMs,
                    fps,
                    frame
                  })
                });
              } catch {}
            }
          }

          // Publish sync state only when we're the "driver".
          // If followRemote is ON, publishing our paused=true back would fight the web player.
          if (!state.followRemote && !state.noVideo) {
            sendSyncUpdate({ mediaId: state.current.id, timeMs, paused, fps, frame });
          }

          // Drive serial from funscript.
          if (state.drive && state.funscript?.actions?.length) {
            const actions = state.funscript.actions;
            while (state.funIndex + 1 < actions.length && actions[state.funIndex + 1].at <= timeMs) {
              state.funIndex++;
              const act = actions[state.funIndex];
              const tcode = window.mv ? null : null;
              // send
              const axis = String(state.axis || 'L0').toUpperCase();
              const pos = Math.max(0, Math.min(100, Math.round(act.pos)));
              const scaled = Math.round((pos / 100) * 999);
              const vvv = String(scaled).padStart(3, '0');
              const line = `${axis}${vvv}`;
              try { await window.mv.tcodeSend(line); } catch {}
            }
          }
        }

        window.requestAnimationFrame(tick);
      }

      async function listPorts() {
        const ports = await window.mv.listSerialPorts();
        const sel = $('port');
        sel.innerHTML = ports.map((p) => `<option value='${esc(p.path)}'>${esc(p.path)}</option>`).join('');
      }

      $('serverUrl').addEventListener('change', (e) => { state.serverUrl = e.target.value; });
      $('applyServer').addEventListener('click', async () => {
        state.serverUrl = $('serverUrl').value.trim() || state.serverUrl;
        savePrefs();
        try { if (state.ws) state.ws.close(); } catch {}
        connectWs();
        state.page = 1;
        await refresh();
      });
      $('q').addEventListener('input', (e) => {
        state.q = e.target.value;
        state.page = 1;
        window.clearTimeout(window.__qt);
        window.__qt = window.setTimeout(() => refresh(), 200);
      });

      $('refresh').addEventListener('click', () => refresh());
      $('prev').addEventListener('click', async () => { state.page = Math.max(1, state.page - 1); await refresh(); });
      $('next').addEventListener('click', async () => {
        const maxPage = Math.max(1, Math.ceil(state.total / state.pageSize));
        state.page = Math.min(maxPage, state.page + 1);
        await refresh();
      });

      $('ports').addEventListener('click', () => listPorts());
      $('connect').addEventListener('click', async () => {
        await window.mv.serialConnect({ path: $('port').value, baudRate: Number($('baud').value || 115200) });
        setStatus('Serial connected');
        state.serialConnected = true;
        setSerialPill(true);
      });
      $('disconnect').addEventListener('click', async () => {
        await window.mv.serialDisconnect();
        setStatus('Serial disconnected');
        state.serialConnected = false;
        setSerialPill(false);
      });

      function setAxis(val) {
        state.axis = String(val || 'L0').toUpperCase();
        savePrefs();
      }

      $('axisSelect').addEventListener('change', () => {
        const sel = $('axisSelect').value;
        if (sel === 'CUSTOM') {
          $('axisCustom').style.display = '';
          $('axisCustom').focus();
          setAxis($('axisCustom').value);
        } else {
          $('axisCustom').style.display = 'none';
          $('axisCustom').value = sel;
          setAxis(sel);
        }
      });

      $('axisCustom').addEventListener('input', () => setAxis($('axisCustom').value));

      $('toggleDrive').addEventListener('click', () => {
        state.drive = !state.drive;
        $('toggleDrive').textContent = state.drive ? 'Drive: ON' : 'Drive: OFF';
        setDrivePill();
        savePrefs();
        state.funIndex = -1;
      });

      $('btnPlayPause').addEventListener('click', async () => {
        const v = $('video');
        if (!(v instanceof HTMLVideoElement)) return;
        if (state.noVideo) return;
        if (v.paused) {
          try { await v.play(); } catch {}
        } else {
          try { v.pause(); } catch {}
        }
      });

      $('btnVideo').addEventListener('click', () => {
        state.noVideo = !state.noVideo;
        savePrefs();
        setVideoModeUi();

        // If turning video back on and we have a current item, reload the stream.
        if (!state.noVideo && state.current?.id) {
          openMedia(state.current.id, { suppressSync: true });
        }
      });

      $('btnFollow').addEventListener('click', () => {
        state.followRemote = !state.followRemote;
        $('btnFollow').textContent = state.followRemote ? 'Follow remote: ON' : 'Follow remote: OFF';
        savePrefs();

        // If we just became the driver, immediately publish our current state.
        if (!state.followRemote) {
          const v = $('video');
          if (state.current && v instanceof HTMLVideoElement) {
            const fps = 30;
            const timeMs = Math.round((v.currentTime || 0) * 1000);
            const frame = currentFrame(v.currentTime || 0, fps);
            sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: v.paused, fps, frame });
          }
        }
      });

      $('followSource').addEventListener('change', () => {
        state.followSource = String($('followSource').value || 'any');
        savePrefs();
      });

      loadPrefs();
      $('serverUrl').value = state.serverUrl;

      // Init axis dropdown
      const common = ['L0','L1','L2','L3'];
      if (common.includes(state.axis)) {
        $('axisSelect').value = state.axis;
        $('axisCustom').value = state.axis;
        $('axisCustom').style.display = 'none';
      } else {
        $('axisSelect').value = 'CUSTOM';
        $('axisCustom').value = state.axis;
        $('axisCustom').style.display = '';
      }

      $('toggleDrive').textContent = state.drive ? 'Drive: ON' : 'Drive: OFF';
      $('btnFollow').textContent = state.followRemote ? 'Follow remote: ON' : 'Follow remote: OFF';

      setVideoModeUi();
      updateFollowSourceOptions();

      setWsPill(false);
      setSerialPill(false);
      setDrivePill();
      setFsPill();

      setStatus('Ready');
      connectWs();
      await listPorts();
      await refresh();

      const v = $('video');
      if (v instanceof HTMLVideoElement) {
        const fps = 30;
        const push = () => {
          if (!state.current) return;
          if (state.followRemote) return;
          const timeMs = Math.round((v.currentTime || 0) * 1000);
          const frame = currentFrame(v.currentTime || 0, fps);
          sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: v.paused, fps, frame });
        };
        v.addEventListener('play', push);
        v.addEventListener('pause', push);
        v.addEventListener('seeked', push);
      }

      tick();
    </script>
  </body>
</html>
