<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>MediaViewer Desktop</title>
    <style>
      :root { color-scheme: dark; }
      *, *::before, *::after { box-sizing: border-box; }
      body { margin: 0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; background: #0b0c0f; color: #e6e6e6; }
      header { padding: 12px 16px; border-bottom: 1px solid #222; display: flex; gap: 12px; align-items: center; justify-content: space-between; }
      header h1 { font-size: 14px; margin: 0; }
      .wrap { display: grid; grid-template-columns: 380px 380px 1fr; height: calc(100vh - 50px); }
      .left { border-right: 1px solid #222; padding: 12px; overflow-y: auto; display: grid; gap: 12px; grid-template-rows: auto auto auto 1fr; align-content: start; }
      .middle { border-right: 1px solid #222; padding: 12px; overflow: auto; display: grid; gap: 12px; }
      .right { padding: 12px; overflow: auto; display: grid; gap: 10px; }
      .row { display: flex; gap: 8px; align-items: center; }
      input, select { width: 100%; padding: 10px 12px; border-radius: 8px; border: 1px solid #2a2f3a; background: #11131a; color: #e6e6e6; }
      button { padding: 10px 12px; border-radius: 8px; border: 1px solid #2a2f3a; background: #11131a; color: #e6e6e6; cursor: pointer; }
      button:disabled { opacity: 0.6; cursor: not-allowed; }
      .list { margin-top: 12px; display: grid; gap: 8px; }
      .item { border: 1px solid #222; border-radius: 10px; padding: 10px; cursor: pointer; background: #0f1117; white-space: normal; overflow-wrap: anywhere; word-break: break-word; }
      .item.active { outline: 2px solid #2a2f3a; }
      .item small { opacity: 0.8; }
      video { width: 100%; aspect-ratio: 16 / 9; height: auto; max-height: 70vh; background: #000; object-fit: contain; }
      input[type="range"] { width: 100%; max-width: 100%; padding: 0; border: 0; background: transparent; }
      .small { font-size: 12px; opacity: 0.85; }
      .pill { display: inline-block; padding: 2px 8px; border: 1px solid #2a2f3a; border-radius: 999px; font-size: 11px; margin-left: 6px; }
      .pill.connected { background: #10b981; color: #fff; border-color: #059669; }
      .pill.disconnected { background: #ef4444; color: #fff; border-color: #dc2626; }
      .pill.tag-good { border-color: #14532d; background: rgba(20,83,45,0.35); color: #86efac; }
      .pill.tag-bad { border-color: #7f1d1d; background: rgba(127,29,29,0.35); color: #fecaca; }
      .pill.tag-vr { border-color: #8b5cf6; background: rgba(139,92,246,0.35); color: #fff; }
      .pill.tag-muted { border-color: #374151; background: rgba(55,65,81,0.35); color: #d1d5db; }
      .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
      .card { border: 1px solid #222; border-radius: 12px; padding: 12px; background: #0f1117; }
      .card.console-card { display: flex; flex-direction: column; min-height: 150px; overflow: hidden; }
      .card h2 { margin: 0 0 10px 0; font-size: 12px; font-weight: 600; opacity: 0.9; }
      .kpi { display: flex; gap: 8px; flex-wrap: wrap; justify-content: flex-end; }
      .kpi .pill { margin-left: 0; }
      .stack { display: grid; gap: 8px; }
      .meter { position: relative; height: 14px; border-radius: 999px; background: #1a1c24; border: 1px solid #2a2f3a; overflow: hidden; }
      .meter-fill { position: absolute; inset: 0; background: linear-gradient(90deg, #5b8cff, #2cd3a7); transform-origin: left center; transform: scaleX(0); transition: transform 0.12s ease-out; }
      .meter-label { font-size: 11px; opacity: 0.8; margin-top: 4px; text-align: right; }
      .console-view { border: 1px solid #222; border-radius: 8px; padding: 8px; background: #000; overflow-y: auto; font-family: monospace; font-size: 11px; flex: 1; min-height: 100px; }
    </style>
  </head>
  <body>
    <header>
      <h1>MediaViewer Desktop</h1>
      <div class="kpi">
        <span class="pill" id="wsPill">Server: —</span>
        <span class="pill" id="serialPill">Serial: —</span>
        <span class="pill" id="drivePill">Drive: OFF</span>
        <span class="pill" id="fsPill">Funscript: —</span>
      </div>
    </header>

    <div class="wrap">
      <div class="left">
        <div class="card">
          <h2>Server</h2>
          <div class="stack">
            <div>
              <div class="small">Server URL</div>
              <div class="row">
                <input id="serverUrl" value="http://localhost:3000" />
                <button id="applyServer" style="max-width: 120px;">Apply</button>
              </div>
            </div>
          </div>
        </div>

        <div class="card">
          <h2>Serial</h2>
          <div class="stack">
            <div class="row">
              <select id="port"></select>
              <input id="baud" value="115200" style="max-width: 120px;" />
            </div>
            <div class="row">
              <button id="ports">Refresh</button>
              <button id="connect">Connect</button>
              <button id="disconnect">Disconnect</button>
            </div>
            <div class="row">
              <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                <input type="checkbox" id="autoConnectSerial" />
                <span class="small">Auto-connect on startup</span>
              </label>
            </div>
            <div class="row"><div class="small" id="status"></div></div>
          </div>
        </div>

        <div class="card">
          <h2>Funscript → TCode</h2>
          <div class="stack">
            <div class="row">
              <select id="axisSelect" style="max-width: 220px;">
                <option value="L0">L0 (Stroke)</option>
                <option value="L1">L1 (Twist)</option>
                <option value="L2">L2 (Roll)</option>
                <option value="L3">L3 (Pitch)</option>
                <option value="CUSTOM">Custom…</option>
              </select>
              <input id="axisCustom" value="L0" style="max-width: 120px; display:none;" />
              <button id="toggleDrive" style="max-width: 140px;">Drive: OFF</button>
              <button id="btnSettings" style="max-width: 140px;">⚙️ Settings</button>
            </div>
            <div class="small">Sends TCode lines based on the funscript actions while playing.</div>
            
            <div style="border-top: 1px solid #222; padding-top: 8px; margin-top: 4px;">
              <div class="row" style="justify-content:space-between;">
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                  <input type="checkbox" id="autoHomeEnabled" />
                  <span class="small">Auto-home on pause/stop</span>
                </label>
                <button id="btnToggleAutoHomeSettings" style="max-width: 140px;">Show</button>
              </div>
              <div id="autoHomeSettings" style="display: none; margin-top: 8px;">
                <div class="small" style="margin-bottom: 4px;">Home position (%):</div>
                <input type="number" id="autoHomePosition" min="0" max="100" step="1" value="0" style="margin-bottom: 8px;" />
                <div class="small" style="margin-bottom: 4px;">Delay (seconds):</div>
                <input type="number" id="autoHomeDelay" min="0" max="60" step="0.5" value="2" style="margin-bottom: 8px;" />
                <div class="small" style="margin-bottom: 4px;">Transition time (ms):</div>
                <input type="number" id="autoHomeTransition" min="100" max="10000" step="100" value="2000" />
                <div class="small" style="margin-top: 10px; margin-bottom: 4px;">Resume delay (ms):</div>
                <input type="number" id="serialResumeDelay" min="0" max="10000" step="50" value="0" />
              </div>
            </div>
          </div>
        </div>

        <div class="card console-card">
          <h2>Console Log</h2>
          <div id="consoleView" class="console-view">
            <div style="margin-bottom: 6px; display: flex; justify-content: space-between;">
              <span style="opacity: 0.7;">Debug Output</span>
              <button id="btnClearConsole" style="padding: 2px 8px; font-size: 10px;">Clear</button>
            </div>
            <div id="consoleOutput"></div>
          </div>
        </div>
      </div>

      <div class="middle">
        <div class="card">
          <h2>Media</h2>
          <div class="stack">
            <div class="grid2">
              <div>
                <div class="small">Search</div>
                <input id="q" placeholder="filename" />
              </div>
              <div>
                <div class="small">Paging</div>
                <div class="row">
                  <button id="prev" style="max-width: 90px;">Prev</button>
                  <button id="next" style="max-width: 90px;">Next</button>
                  <div class="small" id="pageLabel" style="white-space: nowrap;"></div>
                </div>
              </div>
            </div>
            <div class="row">
              <button id="refresh" style="max-width: 120px;">Refresh</button>
              <div class="small"></div>
            </div>
            <div class="list" id="list"></div>
          </div>
        </div>
      </div>

      <div class="right">
        <div class="row" style="justify-content: space-between; gap: 12px; flex-wrap: wrap;">
          <div class="small" id="now"></div>
          <div class="row" style="gap: 8px;">
            <button id="btnPlayPause" style="max-width: 140px;">Play/Pause</button>
            <button id="btnVideo" style="max-width: 140px;">Video: ON</button>
            <button id="btnFollow" style="max-width: 220px;">Follow remote: ON</button>
          </div>
        </div>

        <div class="column" style="margin-top: 10px;">
          <div class="small" style="white-space: nowrap; margin-bottom: 4px;">Sync WebUI</div>
          <select id="followSource" style="width: 100%;"></select>
        </div>

        <video id="video" controls></video>
        <input id="progress" type="range" min="0" max="1" value="0" step="1" />
        <div class="small" id="progressTime">--:-- / --:--</div>
        <div class="small" id="funscriptStatus">Funscript: not loaded</div>
        <div class="meter" aria-hidden="true">
          <div class="meter-fill" id="funscriptMeter"></div>
        </div>
        <div class="meter-label" id="funscriptLabel">Value: 0% (000)</div>
        <canvas id="funscriptGraph" width="640" height="140" style="width:100%; height:140px; border:1px solid #333; border-radius:8px; background:#0f1117;"></canvas>
        <div class="small" id="noVideoHint" style="display:none;">No-video mode: using sync playback time only (no /stream requests).</div>
        <div class="small" id="playback"></div>
      </div>
    </div>

    <div id="settingsModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); z-index:1000; overflow:auto;">
      <div style="max-width:700px; margin:40px auto; background:#1e1e1e; border:1px solid #333; border-radius:8px; padding:30px;">
        <h2 style="margin-top:0; color:#fff;">Script & Axis Settings</h2>
        
        <div style="margin-bottom:30px;">
          <h3 style="color:#fff;">Script Transformations</h3>
          <div style="margin-bottom:15px;">
            <label style="display:flex; align-items:center; color:#fff; cursor:pointer;">
              <input type="checkbox" id="invertScriptCheck" style="margin-right:10px;">
              <span>Invert Script Positions (0↔100)</span>
            </label>
          </div>
          <div style="margin-bottom:15px;">
            <label style="display:flex; align-items:center; color:#fff; cursor:pointer;">
              <input type="checkbox" id="smoothResumeCheck" style="margin-right:10px;">
              <span>Smooth resume funscript on play</span>
            </label>
            <div style="color:#888; font-size:0.9em; margin-left:26px; margin-top:4px;">Ramps device output briefly after pause → play.</div>
          </div>

          <div style="margin-bottom:15px;">
            <label style="display:block; color:#fff; margin-bottom:5px;">Scheduled play (sync)</label>
            <input type="text" id="scheduledPlaySpecInput" style="width:260px; padding:5px;" placeholder="off | seconds | HH:MM | ISO" />
            <div style="color:#888; font-size:0.9em; margin-top:4px;">When set, Play sends a scheduled start time so synced clients can start together.</div>
          </div>
          <div style="margin-bottom:15px;">
            <label style="display:block; color:#fff; margin-bottom:5px;">Script Delay (ms)</label>
            <input type="number" id="scriptDelayInput" step="10" style="width:150px; padding:5px;">
            <span style="color:#888; font-size:0.9em; margin-left:10px;">Negative = earlier, Positive = later</span>
          </div>

          <div style="margin-top:20px; padding-top:15px; border-top:1px solid #333;">
            <label style="display:block; color:#fff; margin-bottom:5px;">Interpolation</label>
            <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
              <select id="interpModeSelect" style="width:220px; padding:5px;">
                <option value="spline">Spline (cubic Hermite)</option>
                <option value="pchip">PCHIP (shape-preserving cubic)</option>
                <option value="makima">MAKIMA (modified Akima)</option>
                <option value="linear">Linear</option>
                <option value="step">Step (hold)</option>
              </select>
              <span style="color:#888; font-size:0.9em;">Applies to the meter and the TCode drive output</span>
            </div>

            <div style="margin-top:12px;">
              <div style="color:#bbb; font-size:0.9em; margin-bottom:6px;">Example comparison</div>
              <canvas id="interpGraph" width="640" height="220" style="width:100%; height:220px; border:1px solid #333; border-radius:8px; background:#0f1117;"></canvas>
              <div id="interpLegend" style="margin-top:6px; color:#aaa; font-size:0.85em; display:flex; gap:12px; flex-wrap:wrap;"></div>
            </div>
          </div>
        </div>

        <div style="margin-bottom:30px;">
          <h3 style="color:#fff;">Axis Position Limits</h3>
          
          <div style="margin-bottom:20px;">
            <label style="display:block; color:#fff; margin-bottom:5px;">L0 (Stroke) - Min: <span id="L0MinLabel">0</span>% | Max: <span id="L0MaxLabel">100</span>%</label>
            <div style="display:flex; gap:15px; align-items:center;">
              <input type="range" id="L0MinSlider" min="0" max="100" value="0" style="flex:1;">
              <input type="range" id="L0MaxSlider" min="0" max="100" value="100" style="flex:1;">
            </div>
          </div>

          <div style="margin-bottom:20px;">
            <label style="display:block; color:#fff; margin-bottom:5px;">L1 (Twist) - Min: <span id="L1MinLabel">0</span>% | Max: <span id="L1MaxLabel">100</span>%</label>
            <div style="display:flex; gap:15px; align-items:center;">
              <input type="range" id="L1MinSlider" min="0" max="100" value="0" style="flex:1;">
              <input type="range" id="L1MaxSlider" min="0" max="100" value="100" style="flex:1;">
            </div>
          </div>

          <div style="margin-bottom:20px;">
            <label style="display:block; color:#fff; margin-bottom:5px;">L2 (Roll) - Min: <span id="L2MinLabel">0</span>% | Max: <span id="L2MaxLabel">100</span>%</label>
            <div style="display:flex; gap:15px; align-items:center;">
              <input type="range" id="L2MinSlider" min="0" max="100" value="0" style="flex:1;">
              <input type="range" id="L2MaxSlider" min="0" max="100" value="100" style="flex:1;">
            </div>
          </div>

          <div style="margin-bottom:20px;">
            <label style="display:block; color:#fff; margin-bottom:5px;">L3 (Pitch) - Min: <span id="L3MinLabel">0</span>% | Max: <span id="L3MaxLabel">100</span>%</label>
            <div style="display:flex; gap:15px; align-items:center;">
              <input type="range" id="L3MinSlider" min="0" max="100" value="0" style="flex:1;">
              <input type="range" id="L3MaxSlider" min="0" max="100" value="100" style="flex:1;">
            </div>
          </div>
        </div>

        <div style="display:flex; gap:10px; justify-content:flex-end;">
          <button id="btnResetSettings" style="padding:8px 16px;">Reset to Defaults</button>
          <button id="btnCloseSettings" style="padding:8px 16px; background:#007acc; color:#fff; border:none; border-radius:4px;">Close</button>
        </div>
      </div>
    </div>

    <script type="module">
      const state = {
        serverUrl: 'http://localhost:3000',
        q: '',
        page: 1,
        pageSize: 30,
        total: 0,
        items: [],
        durationsSec: {},
        _durToken: 0,
        seenSources: new Map(),
        clientsMetadata: new Map(),
        sourceStates: new Map(),
        current: null,
        funscript: null,
        funscriptDerivatives: null,
        interpolationMode: 'spline',
        funIndex: -1,
        funscriptPointer: -1,
        lastFunscriptValue: 0,
        lastTcodeSentAt: 0,
        lastTcodeSentPos: null,
        drive: false,
        axis: 'L0',
        autoHomeEnabled: false,
        autoHomePosition: 0,
        autoHomeDelay: 2,
        autoHomeTransition: 2000,
        autoHomeTimer: null,
        serialResumeDelayMs: 0,
        serialResumeHoldUntil: 0,
        smoothResumeFunscript: false,
        scheduledPlaySpec: '0.4',
        funscriptStats: null,
        smoothResumeStartAt: 0,
        smoothResumeUntil: 0,
        smoothResumePos: null,
        smoothResumeLastAt: 0,
        serialDriveTimer: null,
        _serialLastPaused: true,
        invertScript: false,
        scriptDelay: 0,
        autoConnectSerial: false,
        lastSerialPort: '',
        lastSerialBaud: 115200,
        axisLimits: {
          L0: { min: 0, max: 100 },
          L1: { min: 0, max: 100 },
          L2: { min: 0, max: 100 },
          L3: { min: 0, max: 100 },
        },
        clientId: 'desktop-' + Math.random().toString(16).slice(2),
        sessionId: 'default',
        ws: null,
        wsConnected: false,
        applyingRemoteUntil: 0,
        lastSyncSentAt: 0,
        lastPlaybackPutAt: 0,
        followRemote: true,
        noVideo: false,
        noVideoBaseTimeMs: 0,
        noVideoAnchorAtMs: 0,
        noVideoPaused: true,
        noVideoScheduledPlayAtLocalMs: 0,
        remoteTimeMs: 0,
        remotePaused: true,
        remoteFps: 30,
        remoteLastUpdateAt: 0,
        remoteProjectedTimeMs: 0,
        remoteProjectedAtMs: 0,
        serverClockOffsetMs: null,
        lastAppliedRemotePaused: null,
        serialConnected: false,
        isApplyingRemoteState: false,

        durationMs: null,
        durationCache: new Map(),
        durationInFlightFor: null,

        followSource: '',
        seenSources: new Map(),
        clientsMetadata: new Map(),

        consoleLogs: [],
        consoleVisible: false,
      };

      // Coordinated start: schedule local play for an exact wall-clock time.
      let _scheduledPlayAtLocalMs = 0;
      function scheduleLocalPlayAt(v, playAtLocalMs) {
        if (!(v instanceof HTMLVideoElement)) return;
        const when = Number(playAtLocalMs) || 0;
        if (!Number.isFinite(when) || when <= 0) return;
        if (Math.abs((Number(_scheduledPlayAtLocalMs) || 0) - when) < 10) return;

        _scheduledPlayAtLocalMs = when;
        const delayMs = Math.max(0, Math.round(when - Date.now()));
        state.applyingRemoteUntil = Math.max(state.applyingRemoteUntil, when + 1000);
        try { v.pause(); } catch {}
        window.setTimeout(() => {
          try { v.play(); } catch {}
        }, delayMs);
      }

      function parseScheduledPlaySpec(spec, clockOffsetMs) {
        const s = String(spec ?? '').trim();
        if (!s) return null;
        if (s.toLowerCase() === 'off' || s.toLowerCase() === 'none' || s === '0') return null;

        const offset = Number(clockOffsetMs) || 0;

        // Relative seconds (e.g. "0.4" or "5")
        if (/^\+?\d+(?:\.\d+)?$/.test(s)) {
          const sec = Number(s);
          if (!Number.isFinite(sec) || sec <= 0) return null;
          const playAtLocalMs = Date.now() + Math.round(sec * 1000);
          const playAtServerMs = playAtLocalMs - offset;
          return { playAt: new Date(playAtServerMs).toISOString(), playAtLocalMs };
        }

        // Fixed local time-of-day (HH:MM[:SS])
        const m = /^(\d{1,2}):(\d{2})(?::(\d{2}))?$/.exec(s);
        if (m) {
          const hh = Math.max(0, Math.min(23, Number(m[1])));
          const mm = Math.max(0, Math.min(59, Number(m[2])));
          const ss = Math.max(0, Math.min(59, Number(m[3] ?? 0)));
          const now = new Date();
          const target = new Date(now);
          target.setHours(hh, mm, ss, 0);
          if (target.getTime() <= now.getTime() + 50) target.setDate(target.getDate() + 1);
          const playAtLocalMs = target.getTime();
          const playAtServerMs = playAtLocalMs - offset;
          return { playAt: new Date(playAtServerMs).toISOString(), playAtLocalMs };
        }

        // Fixed absolute date/time (ISO or anything Date.parse accepts)
        const parsed = Date.parse(s);
        if (!Number.isNaN(parsed)) {
          const playAtLocalMs = parsed;
          if (!Number.isFinite(playAtLocalMs) || playAtLocalMs <= Date.now() + 50) return null;
          const playAtServerMs = playAtLocalMs - offset;
          return { playAt: new Date(playAtServerMs).toISOString(), playAtLocalMs };
        }

        return null;
      }

      function computeFunscriptStatsFromActions(actions) {
        if (!Array.isArray(actions) || actions.length === 0) return null;
        let totalAbsDeltaPos = 0;
        let totalDtMs = 0;
        for (let i = 1; i < actions.length; i++) {
          const a0 = actions[i - 1];
          const a1 = actions[i];
          const t0 = Number(a0?.at);
          const t1 = Number(a1?.at);
          const p0 = Number(a0?.pos);
          const p1 = Number(a1?.pos);
          if (!Number.isFinite(t0) || !Number.isFinite(t1) || !Number.isFinite(p0) || !Number.isFinite(p1)) continue;
          const dt = t1 - t0;
          if (!(dt > 0)) continue;
          totalDtMs += dt;
          totalAbsDeltaPos += Math.abs(p1 - p0);
        }
        const avgSpeed = totalDtMs > 0 ? (totalAbsDeltaPos / totalDtMs) * 1000 : 0;
        return { actionCount: actions.length, avgSpeed };
      }

      function formatFunscriptStats(actionCount, avgSpeed) {
        const count = Number(actionCount);
        if (!Number.isFinite(count) || count <= 0) return null;
        const speed = Number(avgSpeed);
        const speedPart = Number.isFinite(speed) && speed > 0 ? ` · ${speed.toFixed(1)}%/s` : '';
        return `${Math.round(count)} actions${speedPart}`;
      }

      const $ = (id) => document.getElementById(id);
      const statusEl = $('status');
      const wsPill = $('wsPill');
      const serialPill = $('serialPill');
      const drivePill = $('drivePill');
      const fsPill = $('fsPill');
      const progressTimeEl = $('progressTime');
      const funscriptStatusEl = $('funscriptStatus');
      const funscriptMeterEl = $('funscriptMeter');
      const funscriptLabelEl = $('funscriptLabel');

      function getControlTargetClientId() {
        const id = String(state.followSource || '').trim();
        return id ? id : null;
      }

      function logToConsole(level, ...args) {
        const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
        const message = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
        state.consoleLogs.push({ timestamp, level, message });
        if (state.consoleLogs.length > 500) state.consoleLogs.shift();
        updateConsoleView();
        // Also log to browser console
        if (level === 'error') console.error(...args);
        else if (level === 'warn') console.warn(...args);
        else console.log(...args);
      }

      function updateConsoleView() {
        const output = $('consoleOutput');
        if (!output) return;
        const colorMap = { log: '#9ca3af', warn: '#fbbf24', error: '#f87171' };
        output.innerHTML = state.consoleLogs.slice(-100).map(log => 
          `<div style="color: ${colorMap[log.level] || '#9ca3af'}; margin-bottom: 2px;">[${log.timestamp}] ${esc(log.message)}</div>`
        ).join('');
        output.scrollTop = output.scrollHeight;
      }

      async function apiJson(path, opts) {
        const url = new URL(path, state.serverUrl);
        const res = await fetch(url.toString(), opts);
        if (!res.ok) throw new Error(await res.text());
        return res.json();
      }

      async function allowSelfSignedForServer(url) {
        try {
          if (!url) return;
          if (!window.mv || typeof window.mv.allowInsecureCertForUrl !== 'function') return;
          const res = await window.mv.allowInsecureCertForUrl(url);
          if (res && typeof res === 'object' && res.error) {
            logToConsole('warn', `Certificate allow failed for ${url}: ${res.error}`);
          }
        } catch (err) {
          const msg = err instanceof Error ? err.message : String(err);
          logToConsole('warn', `Unable to allow certificate for ${url}: ${msg}`);
        }
      }

      async function ensureDurationMs(mediaId) {
        if (!mediaId) return;
        if (state.durationCache.has(mediaId)) {
          state.durationMs = state.durationCache.get(mediaId);
          return;
        }
        if (state.durationInFlightFor === mediaId) return;
        state.durationInFlightFor = mediaId;
        try {
          const r = await apiJson(`/api/media/${encodeURIComponent(mediaId)}/probe`);
          const ms = typeof r?.durationMs === 'number' && Number.isFinite(r.durationMs) && r.durationMs > 0 ? Math.round(r.durationMs) : null;
          state.durationCache.set(mediaId, ms);
          state.durationMs = ms;
        } catch {
          state.durationCache.set(mediaId, null);
          state.durationMs = null;
        } finally {
          if (state.durationInFlightFor === mediaId) state.durationInFlightFor = null;
        }
      }

      function setStatus(s) { statusEl.textContent = s; }

      function setWsPill(connected) {
        wsPill.textContent = connected ? 'Server: connected' : 'Server: disconnected';
        wsPill.className = connected ? 'pill connected' : 'pill disconnected';
      }

      function setSerialPill(connected) {
        serialPill.textContent = connected ? 'Serial: connected' : 'Serial: disconnected';
        serialPill.className = connected ? 'pill connected' : 'pill disconnected';
      }

      function setDrivePill() {
        drivePill.textContent = state.drive ? 'Drive: ON' : 'Drive: OFF';
        drivePill.className = state.drive ? 'pill connected' : 'pill disconnected';
      }

      function setFsPill() {
        const n = state.funscript?.actions?.length;
        if (typeof n === 'number') {
          const stats = state.funscriptStats;
          if (stats && Number.isFinite(stats.actionCount) && stats.actionCount > 0 && Number.isFinite(stats.avgSpeed) && stats.avgSpeed >= 0) {
            const sp = stats.avgSpeed;
            fsPill.textContent = `Funscript: ${Math.round(stats.actionCount)} actions · ${sp.toFixed(sp >= 10 ? 0 : 1)}%/s`;
          } else {
            fsPill.textContent = 'Funscript: Loaded';
          }
          fsPill.className = 'pill connected';
        } else {
          fsPill.textContent = 'Funscript: Not available';
          fsPill.className = 'pill disconnected';
        }
      }

      function loadPrefs() {
        try {
          const p = JSON.parse(localStorage.getItem('mvDesktopPrefs') || 'null');
          if (p && typeof p === 'object') {
            if (typeof p.serverUrl === 'string') state.serverUrl = p.serverUrl;
            if (typeof p.axis === 'string') state.axis = p.axis;
            if (typeof p.drive === 'boolean') state.drive = p.drive;
            if (typeof p.followRemote === 'boolean') state.followRemote = p.followRemote;
            if (typeof p.noVideo === 'boolean') state.noVideo = p.noVideo;
            if (typeof p.followSource === 'string') state.followSource = p.followSource;
            if (typeof p.autoHomeEnabled === 'boolean') state.autoHomeEnabled = p.autoHomeEnabled;
            if (typeof p.autoHomePosition === 'number') state.autoHomePosition = p.autoHomePosition;
            if (typeof p.autoHomeDelay === 'number') state.autoHomeDelay = p.autoHomeDelay;
            if (typeof p.autoHomeTransition === 'number') state.autoHomeTransition = p.autoHomeTransition;
            if (typeof p.serialResumeDelayMs === 'number') state.serialResumeDelayMs = p.serialResumeDelayMs;
            if (typeof p.smoothResumeFunscript === 'boolean') state.smoothResumeFunscript = p.smoothResumeFunscript;
            if (typeof p.scheduledPlaySpec === 'string') state.scheduledPlaySpec = p.scheduledPlaySpec;
            if (typeof p.invertScript === 'boolean') state.invertScript = p.invertScript;
            if (typeof p.scriptDelay === 'number') state.scriptDelay = p.scriptDelay;
            if (typeof p.interpolationMode === 'string') state.interpolationMode = p.interpolationMode;
            if (typeof p.autoConnectSerial === 'boolean') state.autoConnectSerial = p.autoConnectSerial;
            if (typeof p.lastSerialPort === 'string') state.lastSerialPort = p.lastSerialPort;
            if (typeof p.lastSerialBaud === 'number') state.lastSerialBaud = p.lastSerialBaud;
            if (p.axisLimits && typeof p.axisLimits === 'object') {
              ['L0', 'L1', 'L2', 'L3'].forEach(axis => {
                if (p.axisLimits[axis]) {
                  if (typeof p.axisLimits[axis].min === 'number') state.axisLimits[axis].min = p.axisLimits[axis].min;
                  if (typeof p.axisLimits[axis].max === 'number') state.axisLimits[axis].max = p.axisLimits[axis].max;
                }
              });
            }
          }
        } catch {}
      }

      function savePrefs() {
        localStorage.setItem('mvDesktopPrefs', JSON.stringify({
          serverUrl: state.serverUrl,
          axis: state.axis,
          drive: state.drive,
          followRemote: state.followRemote,
          noVideo: state.noVideo,
          followSource: state.followSource,
          autoHomeEnabled: state.autoHomeEnabled,
          autoHomePosition: state.autoHomePosition,
          autoHomeDelay: state.autoHomeDelay,
          autoHomeTransition: state.autoHomeTransition,
          serialResumeDelayMs: state.serialResumeDelayMs,
          smoothResumeFunscript: state.smoothResumeFunscript,
          scheduledPlaySpec: state.scheduledPlaySpec,
          invertScript: state.invertScript,
          scriptDelay: state.scriptDelay,
          interpolationMode: state.interpolationMode,
          axisLimits: state.axisLimits,
          autoConnectSerial: state.autoConnectSerial,
          lastSerialPort: state.lastSerialPort,
          lastSerialBaud: state.lastSerialBaud,
        }));
      }

      function cancelAutoHome() {
        if (state.autoHomeTimer) {
          clearTimeout(state.autoHomeTimer);
          state.autoHomeTimer = null;
        }
      }

      async function runAutoHomeNow() {
        cancelAutoHome();

        if (!state.autoHomeEnabled) return;
        if (!state.drive) return;
        if (!state.serialConnected) return;
        if (!window.mv) return;

        try {
          const axis = String(state.axis || 'L0').toUpperCase();
          const pos = Math.max(0, Math.min(100, Math.round(state.autoHomePosition)));
          const scaled = Math.round((pos / 100) * 999);
          const vvv = String(scaled).padStart(3, '0');
          const interval = Math.max(100, Math.min(10000, Math.round(state.autoHomeTransition)));
          const iii = String(interval).padStart(5, '0');
          const line = `${axis}${vvv}I${iii}`;
          logToConsole('log', `Auto-home executing (immediate): ${line}`);
          await window.mv.tcodeSend(line);
          state.lastTcodeSentAt = Date.now();
          state.lastTcodeSentPos = pos;
        } catch (err) {
          logToConsole('error', 'Auto-home failed:', err);
        }
      }

      function getNoVideoTimeMsAndPaused() {
        const paused = Boolean(state.remotePaused);
        const base = Number(state.remoteProjectedTimeMs) || Number(state.remoteTimeMs) || 0;
        if (paused) return { timeMs: base, paused: true };
        const anchor = Number(state.remoteProjectedAtMs) || Number(state.remoteLastUpdateAt) || Date.now();
        return { timeMs: base + Math.max(0, Date.now() - anchor), paused: false };
      }

      function getLocalNoVideoTimeMsAndPaused() {
        const now = Date.now();

        const schedAt = Number(state.noVideoScheduledPlayAtLocalMs) || 0;
        if (Number.isFinite(schedAt) && schedAt > now + 10) {
          return { timeMs: Math.max(0, Math.round(Number(state.noVideoBaseTimeMs) || 0)), paused: true };
        }

        // If a scheduled start has passed, transition into playing.
        if (Number.isFinite(schedAt) && schedAt > 0 && schedAt <= now + 10) {
          state.noVideoScheduledPlayAtLocalMs = 0;
          state.noVideoPaused = false;
          state.noVideoAnchorAtMs = now;
        }

        const base = Math.max(0, Math.round(Number(state.noVideoBaseTimeMs) || 0));
        if (state.noVideoPaused) return { timeMs: base, paused: true };

        const anchor = Number(state.noVideoAnchorAtMs) || now;
        return { timeMs: base + Math.max(0, now - anchor), paused: false };
      }

      async function serialDriveTick() {
        if (!state.drive) return;
        if (!state.serialConnected) return;
        if (!state.funscript?.actions?.length) return;

        let timeMs = 0;
        let paused = true;

        const v = $('video');
        if (!state.noVideo && v instanceof HTMLVideoElement) {
          timeMs = Math.round((v.currentTime || 0) * 1000);
          paused = Boolean(v.paused);
        } else if (state.noVideo) {
          const r = state.followRemote ? getNoVideoTimeMsAndPaused() : getLocalNoVideoTimeMsAndPaused();
          timeMs = r.timeMs;
          paused = r.paused;
        }

        // Apply resume delay when transitioning from paused -> playing.
        if (state._serialLastPaused && !paused) {
          const delay = Math.max(0, Math.round(Number(state.serialResumeDelayMs) || 0));
          const startAt = Date.now() + delay;
          state.serialResumeHoldUntil = startAt;
          if (state.smoothResumeFunscript) {
            state.smoothResumeStartAt = startAt;
            state.smoothResumeUntil = startAt + 600;
            state.smoothResumeLastAt = startAt;
            state.smoothResumePos = (typeof state.lastTcodeSentPos === 'number' && Number.isFinite(state.lastTcodeSentPos))
              ? state.lastTcodeSentPos
              : null;
          }
        }
        state._serialLastPaused = paused;

        if (paused) {
          state.smoothResumeStartAt = 0;
          state.smoothResumeUntil = 0;
          state.smoothResumePos = null;
          state.smoothResumeLastAt = 0;
          return;
        }
        if (Date.now() < (Number(state.serialResumeHoldUntil) || 0)) return;

        const actions = state.funscript.actions;
        const adjustedTimeMs = timeMs - state.scriptDelay;
        const itp = interpolatePos(actions, adjustedTimeMs, state.funIndex, state.interpolationMode, state.funscriptDerivatives);
        state.funIndex = itp.idx;

        const axis = String(state.axis || 'L0').toUpperCase();
        let pos = itp.pos;
        if (!Number.isFinite(pos)) pos = 0;
        pos = clamp(pos, 0, 100);

        if (state.invertScript) {
          pos = 100 - pos;
        }

        const limits = state.axisLimits[axis] || { min: 0, max: 100 };
        const range = (limits.max - limits.min);
        pos = limits.min + (pos / 100) * range;
        pos = clamp(pos, 0, 100);

        // Smooth resume ramp: briefly ease into the target position after pause → play.
        const now = Date.now();
        if (state.smoothResumeFunscript && now < (Number(state.smoothResumeUntil) || 0)) {
          if (!(typeof state.smoothResumePos === 'number' && Number.isFinite(state.smoothResumePos))) {
            state.smoothResumePos = pos;
          }
          const last = Number(state.smoothResumeLastAt) || now;
          const dt = Math.max(0, now - last);
          state.smoothResumeLastAt = now;

          const tauMs = 150; // lower = snappier, higher = smoother
          const alpha = 1 - Math.exp(-dt / tauMs);
          state.smoothResumePos = state.smoothResumePos + (pos - state.smoothResumePos) * alpha;
          pos = state.smoothResumePos;
        } else if ((Number(state.smoothResumeUntil) || 0) > 0) {
          state.smoothResumeStartAt = 0;
          state.smoothResumeUntil = 0;
          state.smoothResumePos = null;
          state.smoothResumeLastAt = 0;
        }

        const lastAt = Number(state.lastTcodeSentAt) || 0;
        const lastPos = (typeof state.lastTcodeSentPos === 'number' && Number.isFinite(state.lastTcodeSentPos))
          ? state.lastTcodeSentPos
          : null;

        const shouldSendByTime = (now - lastAt) >= 33; // ~30 Hz
        const shouldSendByDelta = lastPos === null ? true : Math.abs(pos - lastPos) >= 0.5;
        if (shouldSendByTime && shouldSendByDelta) {
          state.lastTcodeSentAt = now;
          state.lastTcodeSentPos = pos;

          const scaled = Math.round((pos / 100) * 999);
          const vvv = String(scaled).padStart(3, '0');
          const line = `${axis}${vvv}`;
          try { await window.mv.tcodeSend(line); } catch {}
        }
      }

      function startSerialDriveLoop() {
        try {
          if (state.serialDriveTimer) {
            clearInterval(state.serialDriveTimer);
            state.serialDriveTimer = null;
          }
        } catch {}

        // Run independent from requestAnimationFrame; rAF can pause when minimized.
        state.serialDriveTimer = setInterval(() => {
          serialDriveTick().catch(() => {});
        }, 33);
      }

      async function triggerAutoHome() {
        cancelAutoHome();
        
        // Check requirements
        if (!state.autoHomeEnabled) {
          logToConsole('log', 'Auto-home skipped: not enabled');
          return;
        }
        if (!state.drive) {
          logToConsole('log', 'Auto-home skipped: drive is off');
          return;
        }
        if (!state.serialConnected) {
          logToConsole('log', 'Auto-home skipped: serial not connected');
          return;
        }
        
        logToConsole('log', `Auto-home scheduled: ${state.autoHomeDelay}s delay to position ${state.autoHomePosition}%`);
        
        state.autoHomeTimer = setTimeout(async () => {
          try {
            const axis = String(state.axis || 'L0').toUpperCase();
            const pos = Math.max(0, Math.min(100, Math.round(state.autoHomePosition)));
            const scaled = Math.round((pos / 100) * 999);
            const vvv = String(scaled).padStart(3, '0');
            const interval = Math.max(100, Math.min(10000, Math.round(state.autoHomeTransition)));
            const iii = String(interval).padStart(5, '0');
            const line = `${axis}${vvv}I${iii}`;
            logToConsole('log', `Auto-home executing: ${line}`);
            if (window.mv) await window.mv.tcodeSend(line);
            state.lastTcodeSentAt = Date.now();
            state.lastTcodeSentPos = pos;
          } catch (err) {
            logToConsole('error', 'Auto-home failed:', err);
          }
        }, state.autoHomeDelay * 1000);
      }

      function labelForSource(id) {
        if (!id) return 'Unknown';
        
        // Check if we have metadata for this client
        const meta = state.clientsMetadata.get(id);
        if (meta) {
          // User requested full browser agent.
          let ua = meta.userAgent || 'Unknown';
          // Clean up common prefix if safe
          if (ua.startsWith('Mozilla/5.0')) {
             ua = ua.replace(/^Mozilla\/5\.0 /, '');
          }
          const ip = (meta.ipAddress || '').replace(/^::ffff:/, '');
          return `${ua} (${ip})`;
        }
        
        // Fallbacks
        if (id.startsWith('vr:deovr')) return 'VR (DeoVR)';
        if (id.startsWith('vr:heresphere')) return 'VR (HereSphere)';
        if (id.startsWith('desktop-')) return 'Desktop Client';
        if (id.startsWith('web-')) return 'Web Browser';
        
        if (id.length > 20) return id.slice(0, 17) + '...';
        return id;
      }
      
      function parseBrowserFromUserAgent(ua) {
        if (!ua || ua === 'Unknown') return 'Unknown Browser';
        
        // Specific VR browsers/agents
        if (ua.includes('DeoVR')) return 'DeoVR';
        if (ua.includes('HereSphere')) return 'HereSphere';
        if (ua.includes('OculusBrowser')) return 'Oculus Browser';
        if (ua.includes('Wolvic')) return 'Wolvic';
        
        // Common desktop
        if (ua.includes('Edg/')) return 'Edge';
        if (ua.includes('Chrome/')) return 'Chrome';
        if (ua.includes('Firefox/')) return 'Firefox';
        if (ua.includes('Safari/') && !ua.includes('Chrome')) return 'Safari';
        if (ua.includes('OPR/') || ua.includes('Opera/')) return 'Opera';
        
        return 'Browser';
      }

      function updateFollowSourceOptions() {
        const sel = $('followSource');
        if (!(sel instanceof HTMLSelectElement)) return;

        // "Any" option removed per user request.
        // List only active sources.
        const activeIds = Array.from(state.seenSources.keys());
        
        // If followSource is not in active list, we might want to add a "Select a source" option
        // or just show the active ones.
        // User said: "If current selected source gets disconnected change follow source to none."
        
        let html = '<option value="">(None)</option>';
        html += activeIds.map((id) => `<option value="${esc(id)}" ${id === state.followSource ? 'selected' : ''}>${esc(labelForSource(id))}</option>`).join('');
        
        sel.innerHTML = html;

        // If currently selected source is no longer valid/active, reset to none.
          if (state.followSource && !state.seenSources.has(state.followSource)) {
           state.followSource = '';
           savePrefs();
           sel.value = '';
           // Source disconnected: Unload the video.
           applyRemoteSyncState({ mediaId: null });
           logToConsole('log', 'Sync WebUI source disconnected - unloading media');
        }
      }

      function setVideoModeUi() {
        $('btnVideo').textContent = state.noVideo ? 'Video: OFF' : 'Video: ON';
        // Even in no-video mode, keep controls enabled so we can drive remote clients.
        $('btnPlayPause').disabled = false;

        const v = $('video');
        if (v instanceof HTMLVideoElement) {
          v.style.display = state.noVideo ? 'none' : '';
        }

        const hint = $('noVideoHint');
        if (hint) hint.style.display = state.noVideo ? '' : 'none';

        if (state.noVideo && v instanceof HTMLVideoElement) {
          // Ensure we don't keep any active stream.
          try {
            v.pause();
            v.removeAttribute('src');
            v.load();
          } catch {}
        }
      }

      function wsUrlFromHttp(httpUrl) {
        const u = new URL(httpUrl);
        u.protocol = u.protocol === 'https:' ? 'wss:' : 'ws:';
        u.pathname = '/ws';
        u.search = '';
        u.hash = '';
        return u.toString();
      }

      function connectWs() {
        if (state.ws && (state.ws.readyState === 0 || state.ws.readyState === 1)) return;
        const ws = new WebSocket(wsUrlFromHttp(state.serverUrl));
        state.ws = ws;

        ws.addEventListener('open', () => {
          state.wsConnected = true;
          setStatus('WS connected');
          setWsPill(true);
          ws.send(JSON.stringify({ type: 'sync:hello', clientId: state.clientId, sessionId: state.sessionId }));
        });

        ws.addEventListener('close', () => {
          state.wsConnected = false;
          setStatus('WS disconnected');
          setWsPill(false);
          window.setTimeout(() => connectWs(), 1000);
        });

        ws.addEventListener('message', (evt) => {
          let msg;
          try { msg = JSON.parse(String(evt.data)); } catch { return; }
          if (!msg || msg.type !== 'sync:state' || !msg.state) return;

          // Update clients metadata if provided
          if (msg.clients && Array.isArray(msg.clients)) {
            state.seenSources.clear();
            state.clientsMetadata.clear();
            for (const client of msg.clients) {
              if (client.clientId && client.clientId !== state.clientId) {
                state.seenSources.set(client.clientId, Date.now());
                state.clientsMetadata.set(client.clientId, {
                  userAgent: client.userAgent || 'Unknown',
                  ipAddress: client.ipAddress || 'Unknown',
                  uiView: typeof client.uiView === 'string' ? client.uiView : undefined,
                  uiMediaId: client.uiMediaId === null ? null : typeof client.uiMediaId === 'string' ? client.uiMediaId : undefined,
                });
              }
            }
            updateFollowSourceOptions();
          }

          const src = String(msg.state.fromClientId || '');
          if (src && src !== state.clientId) {
            state.seenSources.set(src, Date.now());
            // Cache state for this source for instant switching
            state.sourceStates.set(src, msg.state);
            updateFollowSourceOptions();
            
            // Log VR sync events for debugging
            if (src.startsWith('vr:')) {
              logToConsole('log', `VR sync received: ${src} → media ${msg.state.mediaId}`);
            }
          }

          applyRemoteSyncState(msg.state);
        });
      }

      function sendSyncUpdate(update, force = false, toClientId = null) {
        if (!state.wsConnected || !state.ws || state.ws.readyState !== 1) return;
        if (Date.now() < state.applyingRemoteUntil) return;
        const now = Date.now();
        if (!force && now - state.lastSyncSentAt < 200) return;
        state.lastSyncSentAt = now;
        const payload = {
          type: 'sync:update',
          sessionId: state.sessionId,
          clientId: state.clientId,
          ...update,
        };
        const target = typeof toClientId === 'string' ? toClientId.trim() : '';
        if (target) payload.toClientId = target;
        state.ws.send(JSON.stringify(payload));
      }

      async function applyRemoteSyncState(remote) {
        function unloadCurrentMedia(reason) {
          if (!state.current) return;
          state.current = null;
          state.funscript = null;
          state.funscriptPointer = -1;
          state.durationMs = null;
          state.lastAppliedRemotePaused = null;
          $('now').textContent = 'Now: (Nothing)';

          const v = $('video');
          if (v instanceof HTMLVideoElement) {
            try {
              v.pause();
              v.removeAttribute('src');
              v.load();
            } catch {}
          }

          updateFunscriptUi(0);
          renderList();
          if (reason) logToConsole('log', reason);
        }

        // Handle empty/null remote state (deselect current media)
        if (!remote || !remote.mediaId) {
          unloadCurrentMedia('Remote cleared media - resetting player');
          return;
        }

        if (!state.followRemote) return;

        if (remote.fromClientId && remote.fromClientId === state.clientId) return;

        if (state.followSource) {
          // Strict checking if a source is selected
          if (String(remote.fromClientId || '') !== state.followSource) {
             // ... validation
             return; 
          }

          const meta = state.clientsMetadata.get(state.followSource);
          const uiView = meta && typeof meta.uiView === 'string' ? meta.uiView : '';
          const isPlayerView = uiView === 'player' || uiView === 'vr';
          if (uiView && !isPlayerView) {
            // WebUI isn't currently on a play screen; do not auto-load or seek.
            return;
          }
        } else {
           // If followSource is empty ("(None)"), do NOT follow "any".
           // User wants strict following if I removed "any".
           // "Remove the option Any... If current selected source gets disconnected change follow source to none."
           // This implies default behavior is NOT "follow anyone".
           return;
        }

        const id = String(remote.mediaId);

        // Follow remote media selection.
        if (!state.current || state.current.id !== id) {
          // ensure list contains it or fetch minimal info
          const it = state.items.find((x) => x.id === id) || { id, filename: id, mediaType: 'video', hasFunscript: false };
          await openMedia(it.id, { suppressSync: true });
        }

        // Only throttle time updates, not pause state changes
        const now = Date.now();
        const isThrottled = now < state.applyingRemoteUntil;
        
        const prevRemoteTimeMs = Number(state.remoteTimeMs) || 0;

        const nextRemoteTimeMs = Math.max(0, Math.round(Number(remote.timeMs) || 0));
        state.remoteTimeMs = nextRemoteTimeMs;

        // Be strict about paused parsing (handles booleans, 0/1, and 'true'/'false').
        const pausedRaw = remote.paused;
        const paused = pausedRaw === true || pausedRaw === 1 || pausedRaw === '1' || pausedRaw === 'true';
        state.remoteFps = Math.max(1, Math.round(Number(remote.fps) || 30));

        const nowMs = Date.now();
        let updatedAtMs = null;
        if (remote.updatedAt) {
          const parsed = Date.parse(String(remote.updatedAt));
          if (!Number.isNaN(parsed)) updatedAtMs = parsed;
        }

        if (updatedAtMs !== null) {
          const observedOffset = nowMs - updatedAtMs;
          if (typeof state.serverClockOffsetMs !== 'number' || !Number.isFinite(state.serverClockOffsetMs)) {
            state.serverClockOffsetMs = observedOffset;
          } else {
            state.serverClockOffsetMs = state.serverClockOffsetMs * 0.9 + observedOffset * 0.1;
          }
        }

        const clockOffset = typeof state.serverClockOffsetMs === 'number' && Number.isFinite(state.serverClockOffsetMs)
          ? state.serverClockOffsetMs
          : 0;
        const baselineRemoteNow = updatedAtMs !== null ? updatedAtMs + clockOffset : nowMs;

        let playAtLocalMs = null;
        if (!paused && remote.playAt) {
          const t = Date.parse(String(remote.playAt));
          if (!Number.isNaN(t)) playAtLocalMs = t + clockOffset;
        }

        const treatAsPaused = (playAtLocalMs != null && playAtLocalMs > nowMs + 10) ? true : paused;
        const driftMs = treatAsPaused ? 0 : Math.max(0, nowMs - baselineRemoteNow);
        const projectedTimeMs = Math.max(0, nextRemoteTimeMs + driftMs);

        state.remoteProjectedTimeMs = projectedTimeMs;
        state.remoteProjectedAtMs = nowMs;
        state.remoteLastUpdateAt = nowMs;

        const pausedChanged = state.remotePaused !== treatAsPaused;
        state.remotePaused = treatAsPaused;
        if (pausedChanged) {
          logToConsole('log', `Remote pause state changed: ${treatAsPaused ? 'PAUSED' : 'PLAYING'}`);
        }

        // In no-video mode, do not load/control the stream.
        if (state.noVideo) return;

        const v = $('video');
        if (!(v instanceof HTMLVideoElement)) return;

        state.isApplyingRemoteState = true;
        try {
          const targetTimeSeconds = projectedTimeMs / 1000;
          const currentTimeSeconds = Number.isFinite(v.currentTime) ? v.currentTime : 0;
          const seekDiff = Math.abs(currentTimeSeconds - targetTimeSeconds);
          const remoteJumpedBack = nextRemoteTimeMs < prevRemoteTimeMs - 100;
          const remoteJumpedForward = nextRemoteTimeMs - prevRemoteTimeMs > 2000;
          const remoteJumped = remoteJumpedBack || remoteJumpedForward;

          const shouldRetarget = remoteJumped || seekDiff > 0.75;

          if (!isThrottled) {
            if (shouldRetarget) {
              try { v.currentTime = targetTimeSeconds; } catch {}
            }
            state.applyingRemoteUntil = nowMs + 1500;
          } else if (remoteJumped) {
            try { v.currentTime = targetTimeSeconds; } catch {}
            state.applyingRemoteUntil = nowMs + 1500;
          }

          // Always apply pause state changes immediately (not throttled)
          if (state.lastAppliedRemotePaused !== state.remotePaused) {
            state.lastAppliedRemotePaused = state.remotePaused;
            state.applyingRemoteUntil = nowMs + 1500; // Prevent immediate sync back
            if (state.remotePaused) {
              if (playAtLocalMs != null && playAtLocalMs > nowMs + 10) {
                // Scheduled play: keep paused until playAt, without triggering auto-home.
                const startTimeSeconds = (nextRemoteTimeMs + Math.max(0, playAtLocalMs - baselineRemoteNow)) / 1000;
                logToConsole('log', `Scheduling play at ${new Date(playAtLocalMs).toISOString()}`);
                try { v.pause(); } catch {}
                cancelAutoHome();
                try { v.currentTime = startTimeSeconds; } catch {}
                scheduleLocalPlayAt(v, playAtLocalMs);
              } else {
                logToConsole('log', 'Pausing video (remote)');
                try { v.pause(); } catch {}
                triggerAutoHome(); // Trigger auto-home when remotely paused
              }
            } else {
              logToConsole('log', 'Playing video (remote)');
              try { await v.play(); } catch {}
              cancelAutoHome(); // Cancel auto-home when remotely unpaused
            }
          }
        } finally {
          state.isApplyingRemoteState = false;
        }
      }

      function esc(s) {
        return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'",'&#039;');
      }

      async function refresh() {
        setStatus('Loading list...');
        const url = new URL('/api/media', state.serverUrl);
        url.searchParams.set('q', state.q);
        url.searchParams.set('page', String(state.page));
        url.searchParams.set('pageSize', String(state.pageSize));
        const res = await fetch(url.toString());
        if (!res.ok) throw new Error(await res.text());
        const data = await res.json();
        state.total = data.total;
        state.items = data.items;

        // Prefer server-provided durationMs (from DB scan) to avoid client probing.
        try {
          for (const it of state.items) {
            const id = String(it?.id ?? '');
            const ms = typeof it?.durationMs === 'number' && Number.isFinite(it.durationMs) && it.durationMs > 0 ? it.durationMs : null;
            if (!id || ms == null) continue;
            const sec = ms / 1000;
            if (Number.isFinite(sec) && sec > 0) state.durationsSec[id] = sec;
          }
        } catch {}

        renderList();
        renderPager();
        setStatus('Ready');
        prefetchDurations();
      }

      function getDurationSec(id) {
        const v = state.durationsSec[id];
        return Number.isFinite(v) ? v : null;
      }

      function formatDuration(seconds) {
        if (!Number.isFinite(seconds) || seconds <= 0) return '--:--';
        const total = Math.round(seconds);
        const h = Math.floor(total / 3600);
        const m = Math.floor((total % 3600) / 60);
        const s = total % 60;
        if (h > 0) return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        return `${m}:${String(s).padStart(2, '0')}`;
      }

      function renderPager() {
        const maxPage = Math.max(1, Math.ceil(state.total / state.pageSize));
        $('pageLabel').textContent = `Page ${state.page} / ${maxPage} (${state.total})`;
        $('prev').disabled = state.page <= 1;
        $('next').disabled = state.page >= maxPage;
      }

      function renderList() {
        $('list').innerHTML = state.items.map((it) => {
          const fs = it.hasFunscript ? `<span class='pill tag-good'>funscript</span>` : `<span class='pill tag-bad'>no funscript</span>`;
          const fsStatsText = it.hasFunscript ? formatFunscriptStats(it.funscriptActionCount, it.funscriptAvgSpeed) : null;
          const fsStats = fsStatsText ? `<span class='pill tag-muted'>${esc(fsStatsText)}</span>` : '';
          const vr = it.isVr ? `<span class='pill tag-vr'>VR</span>` : '';
          const active = state.current?.id === it.id ? 'active' : '';
          const dur = formatDuration(getDurationSec(it.id) ?? NaN);
          const durTag = dur !== '--:--' ? `<span class='pill tag-muted'>${dur}</span>` : '';
          return `<div class='item ${active}' data-id='${it.id}'>
            <div style="font-weight:500; margin-bottom:4px; word-break:break-all;">${esc(it.filename)}</div>
            <div style="display:flex; flex-wrap:wrap; gap:6px; align-items:center;">
              <span class='pill tag-muted'>${esc(it.mediaType)}</span>
              ${durTag} ${vr} ${fs} ${fsStats}
            </div>
          </div>`;
        }).join('');
        const items = $('list').querySelectorAll('.item');
        for (const div of items) {
          div.addEventListener('click', () => openMedia(div.getAttribute('data-id')));
        }
      }

      async function probeDuration(id) {
        // Desktop version: use hidden video element to probe
        return new Promise((resolve) => {
          const v = document.createElement('video');
          v.preload = 'metadata';
          v.src = new URL(`/api/media/${id}/stream`, state.serverUrl).toString();
          v.onloadedmetadata = () => {
             const d = v.duration;
             v.removeAttribute('src');
             resolve(d);
          };
          v.onerror = () => resolve(null);
          // Timeout
          setTimeout(() => {
             v.removeAttribute('src');
             resolve(null); 
          }, 5000);
        });
      }

      async function prefetchDurations() {
        const token = ++state._durToken;
        const ids = state.items
          .filter(it => it.mediaType === 'video')
          .map(it => it.id)
          .filter(id => getDurationSec(id) === null);
          
        if (!ids.length) return;
        
        // Process sequentially to avoid flooding network/process
        for (const id of ids) {
          if (token !== state._durToken) return;
          const d = await probeDuration(id);
          if (token !== state._durToken) return;
          if (typeof d === 'number' && Number.isFinite(d) && d > 0) {
             state.durationsSec[id] = d;
             // Update UI if item is still visible
             const el = document.querySelector(`.item[data-id="${id}"]`);
             if (el) renderList(); 
          }
        }
      }

      async function openMedia(id, opts = {}) {
        const suppressSync = Boolean(opts.suppressSync);
        const it = state.items.find((x) => x.id === id);
        // When following remote, the media might not be in the currently loaded page.
        // Keep a placeholder so progress/UI can still update.
        state.current = it || { id, filename: id, mediaType: 'video', hasFunscript: false };
        state.funscript = null;
        state.funscriptDerivatives = null;
        state.funscriptStats = null;
        state.funIndex = -1;
        state.funscriptPointer = -1;
        state.lastFunscriptValue = 0;
        state.durationMs = null;
        state.noVideoBaseTimeMs = 0;
        state.noVideoAnchorAtMs = Date.now();
        state.noVideoPaused = true;
        state.noVideoScheduledPlayAtLocalMs = 0;
        // Reset pause tracking so the new video's pause state is applied
        state.lastAppliedRemotePaused = null;
        $('now').textContent = it ? `Now: ${it.filename}` : `Now: ${id}`;
        updateFunscriptUi(0);

        const v = $('video');
        if (v instanceof HTMLVideoElement) {
          if (state.noVideo) {
            try {
              v.pause();
              v.removeAttribute('src');
              v.load();
            } catch {}

            // No-video mode: fetch duration via ffprobe so we can render a real progress bar.
            ensureDurationMs(id);
          } else {
            v.src = new URL(`/api/media/${id}/stream`, state.serverUrl).toString();
          }
        }

        if (!suppressSync && !state.followRemote) {
          sendSyncUpdate({ mediaId: id, timeMs: 0, paused: true, fps: 30, frame: 0 }, false, getControlTargetClientId());
        }

        try {
          state.funscript = await apiJson(`/api/media/${id}/funscript`);
          state.funscript.actions.sort((a,b) => a.at - b.at);
          state.funscriptPointer = -1;
          state.lastFunscriptValue = 0;

          try {
            state.funscriptStats = computeFunscriptStatsFromActions(state.funscript.actions);
          } catch {
            state.funscriptStats = null;
          }

          // Precompute derivatives for interpolation methods that need them.
          try {
            state.funscriptDerivatives = computeFunscriptDerivatives(state.funscript.actions);
          } catch {
            state.funscriptDerivatives = null;
          }
        } catch {
          state.funscript = null;
          state.funscriptDerivatives = null;
          state.funscriptStats = null;
        }

        setFsPill();
        updateFunscriptUi(0);
        renderList();
      }

      function currentFrame(timeSeconds, fps) {
        return Math.max(0, Math.floor(timeSeconds * fps));
      }

      function clamp(n, min, max) {
        return Math.max(min, Math.min(max, n));
      }

      function computeFunscriptDerivatives(actions) {
        const n = actions.length;
        if (!Array.isArray(actions) || n < 2) return { pchip: null, makima: null };

        const t = actions.map(a => Number(a.at) || 0);
        const y = actions.map(a => Number(a.pos) || 0);

        // Ensure strictly increasing time (fallback to linear if not).
        for (let i = 1; i < n; i++) {
          if (!(t[i] > t[i - 1])) {
            return { pchip: null, makima: null };
          }
        }

        return {
          pchip: computePchipDerivatives(t, y),
          makima: computeMakimaDerivatives(t, y),
        };
      }

      function computePchipDerivatives(x, y) {
        const n = x.length;
        if (n < 2) return null;
        if (n === 2) {
          const d = (y[1] - y[0]) / (x[1] - x[0]);
          return [d, d];
        }

        const h = new Array(n - 1);
        const delta = new Array(n - 1);
        for (let i = 0; i < n - 1; i++) {
          h[i] = x[i + 1] - x[i];
          delta[i] = (y[i + 1] - y[i]) / h[i];
        }

        const m = new Array(n).fill(0);

        // Endpoints (Fritsch-Carlson)
        {
          const h0 = h[0], h1 = h[1];
          const d0 = delta[0], d1 = delta[1];
          let m0 = ((2 * h0 + h1) * d0 - h0 * d1) / (h0 + h1);
          if (Math.sign(m0) !== Math.sign(d0)) m0 = 0;
          else if (Math.sign(d0) !== Math.sign(d1) && Math.abs(m0) > 3 * Math.abs(d0)) m0 = 3 * d0;
          m[0] = m0;
        }
        {
          const hn1 = h[n - 2], hn2 = h[n - 3];
          const dn1 = delta[n - 2], dn2 = delta[n - 3];
          let mn = ((2 * hn1 + hn2) * dn1 - hn1 * dn2) / (hn1 + hn2);
          if (Math.sign(mn) !== Math.sign(dn1)) mn = 0;
          else if (Math.sign(dn1) !== Math.sign(dn2) && Math.abs(mn) > 3 * Math.abs(dn1)) mn = 3 * dn1;
          m[n - 1] = mn;
        }

        // Interior
        for (let k = 1; k < n - 1; k++) {
          const dk1 = delta[k - 1];
          const dk = delta[k];
          if (dk1 === 0 || dk === 0 || Math.sign(dk1) !== Math.sign(dk)) {
            m[k] = 0;
          } else {
            const w1 = 2 * h[k] + h[k - 1];
            const w2 = h[k] + 2 * h[k - 1];
            m[k] = (w1 + w2) / (w1 / dk1 + w2 / dk);
          }
        }

        return m;
      }

      function computeMakimaDerivatives(x, y) {
        const n = x.length;
        if (n < 2) return null;
        if (n === 2) {
          const d = (y[1] - y[0]) / (x[1] - x[0]);
          return [d, d];
        }

        const delta = new Array(n - 1);
        for (let i = 0; i < n - 1; i++) {
          const h = x[i + 1] - x[i];
          delta[i] = (y[i + 1] - y[i]) / h;
        }

        const m = new Array(n).fill(0);
        // Simple edge handling (close to common makima behavior)
        m[0] = delta[0];
        m[1] = (delta[0] + delta[1]) / 2;
        m[n - 2] = (delta[n - 3] + delta[n - 2]) / 2;
        m[n - 1] = delta[n - 2];

        for (let i = 2; i <= n - 3; i++) {
          const d_im2 = delta[i - 2];
          const d_im1 = delta[i - 1];
          const d_i = delta[i];
          const d_ip1 = delta[i + 1];

          // Modified Akima weights (MAKIMA)
          const w1 = Math.abs(d_ip1 - d_i) + 0.5 * Math.abs(d_ip1 + d_i);
          const w2 = Math.abs(d_im1 - d_im2) + 0.5 * Math.abs(d_im1 + d_im2);
          const denom = w1 + w2;
          if (denom === 0) {
            m[i] = (d_im1 + d_i) / 2;
          } else {
            m[i] = (w1 * d_im1 + w2 * d_i) / denom;
          }
        }

        return m;
      }

      function findActionIndexAtOrBeforeMs(actions, ms, idxHint) {
        let idx = Number.isInteger(idxHint) ? idxHint : -1;
        if (idx >= actions.length) idx = actions.length - 1;
        if (idx < -1) idx = -1;

        if (idx + 1 < actions.length && actions[idx + 1].at <= ms) {
          while (idx + 1 < actions.length && actions[idx + 1].at <= ms) idx++;
        } else if (idx >= 0 && actions[idx].at > ms) {
          while (idx >= 0 && actions[idx].at > ms) idx--;
        } else if (idx === -1 && actions[0].at <= ms) {
          while (idx + 1 < actions.length && actions[idx + 1].at <= ms) idx++;
        }

        return idx;
      }

      function interpolatePos(actions, ms, idxHint, mode, derivatives) {
        // Returns { pos, idx } where idx is the action index at-or-before ms.
        const idx = findActionIndexAtOrBeforeMs(actions, ms, idxHint);

        const p1 = idx >= 0 ? actions[idx] : null;
        const p2 = idx + 1 < actions.length ? actions[idx + 1] : null;
        if (!p1 && p2) return { pos: Number(p2.pos) || 0, idx };
        if (!p2 && p1) return { pos: Number(p1.pos) || 0, idx };
        if (!p1 || !p2) return { pos: 0, idx };

        const t1 = Number(p1.at) || 0;
        const t2 = Number(p2.at) || (t1 + 1);
        const span = Math.max(1, t2 - t1);
        const u = clamp((ms - t1) / span, 0, 1);

        const y1 = Number(p1.pos) || 0;
        const y2 = Number(p2.pos) || 0;

        const interpMode = String(mode || 'spline').toLowerCase();
        if (interpMode === 'step') {
          return { pos: y1, idx };
        }

        if (interpMode === 'linear') {
          const y = y1 + (y2 - y1) * u;
          return { pos: Number.isFinite(y) ? y : y1, idx };
        }

        // Cubic Hermite with various slope sources
        let d1 = 0;
        let d2 = 0;

        if (interpMode === 'pchip' && derivatives?.pchip && derivatives.pchip.length === actions.length) {
          d1 = Number(derivatives.pchip[idx]) || 0;
          d2 = Number(derivatives.pchip[idx + 1]) || 0;
        } else if (interpMode === 'makima' && derivatives?.makima && derivatives.makima.length === actions.length) {
          d1 = Number(derivatives.makima[idx]) || 0;
          d2 = Number(derivatives.makima[idx + 1]) || 0;
        } else {
          // Default spline: estimate slopes from neighbors (time-aware)
          const p0 = idx - 1 >= 0 ? actions[idx - 1] : p1;
          const p3 = idx + 2 < actions.length ? actions[idx + 2] : p2;
          const t0 = Number(p0.at) || t1;
          const t3 = Number(p3.at) || t2;
          const y0 = Number(p0.pos) || 0;
          const y3 = Number(p3.pos) || 0;
          d1 = (t2 - t0) !== 0 ? (y2 - y0) / (t2 - t0) : 0;
          d2 = (t3 - t1) !== 0 ? (y3 - y1) / (t3 - t1) : 0;
        }

        const m1 = d1 * span;
        const m2 = d2 * span;

        const u2 = u * u;
        const u3 = u2 * u;
        const h00 = 2 * u3 - 3 * u2 + 1;
        const h10 = u3 - 2 * u2 + u;
        const h01 = -2 * u3 + 3 * u2;
        const h11 = u3 - u2;

        let y = h00 * y1 + h10 * m1 + h01 * y2 + h11 * m2;

        // Prevent overshoot between adjacent points (safer for motion control).
        const lo = Math.min(y1, y2);
        const hi = Math.max(y1, y2);
        y = clamp(y, lo, hi);

        if (!Number.isFinite(y)) y = y1;
        return { pos: y, idx };
      }

      function getExampleActions() {
        // Fixed example to highlight differences between interpolators.
        return [
          { at: 0, pos: 10 },
          { at: 500, pos: 95 },
          { at: 1000, pos: 15 },
          { at: 1500, pos: 85 },
          { at: 2000, pos: 30 },
        ];
      }

      function drawInterpolationExample() {
        const canvas = $('interpGraph');
        const legend = $('interpLegend');
        if (!(canvas instanceof HTMLCanvasElement) || !legend) return;

        const actions = getExampleActions();
        const deriv = computeFunscriptDerivatives(actions);

        const dpr = Math.max(1, Math.round(window.devicePixelRatio || 1));
        const cssW = canvas.clientWidth || 640;
        const cssH = canvas.clientHeight || 220;
        canvas.width = Math.round(cssW * dpr);
        canvas.height = Math.round(cssH * dpr);
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        const padL = 40, padR = 12, padT = 10, padB = 26;
        const w = cssW, h = cssH;
        const plotW = w - padL - padR;
        const plotH = h - padT - padB;

        const xMin = actions[0].at;
        const xMax = actions[actions.length - 1].at;
        const yMin = 0;
        const yMax = 100;

        const xToPx = (x) => padL + ((x - xMin) / (xMax - xMin)) * plotW;
        const yToPx = (y) => padT + (1 - (y - yMin) / (yMax - yMin)) * plotH;

        // Background
        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = '#0f1117';
        ctx.fillRect(0, 0, w, h);

        // Grid
        ctx.strokeStyle = '#24272f';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 6]);
        for (let i = 0; i <= 4; i++) {
          const yy = padT + (plotH * i) / 4;
          ctx.beginPath();
          ctx.moveTo(padL, yy);
          ctx.lineTo(w - padR, yy);
          ctx.stroke();
        }
        ctx.setLineDash([]);

        // Axes
        ctx.strokeStyle = '#3a3f4c';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padL, padT);
        ctx.lineTo(padL, h - padB);
        ctx.lineTo(w - padR, h - padB);
        ctx.stroke();

        // Labels
        ctx.fillStyle = '#b7bcc7';
        ctx.font = '11px system-ui, Segoe UI, Arial';
        ctx.fillText('100', 6, yToPx(100) + 4);
        ctx.fillText('0', 16, yToPx(0) + 4);
        ctx.fillText(`${xMin}ms`, padL, h - 8);
        ctx.fillText(`${xMax}ms`, w - padR - 50, h - 8);

        const methods = [
          { key: 'spline', label: 'Spline', color: '#5b8cff', dash: [] },
          { key: 'pchip', label: 'PCHIP', color: '#2cd3a7', dash: [6, 6] },
          { key: 'makima', label: 'MAKIMA', color: '#fbbf24', dash: [2, 6] },
          { key: 'linear', label: 'Linear', color: '#a78bfa', dash: [10, 4] },
          { key: 'step', label: 'Step', color: '#f87171', dash: [] },
        ];

        legend.innerHTML = methods.map(m => {
          return `<span style="display:flex; align-items:center; gap:6px;"><span style="width:18px; height:2px; background:${m.color}; display:inline-block;"></span>${m.label}</span>`;
        }).join('');

        const sampleCount = 240;
        for (const method of methods) {
          ctx.strokeStyle = method.color;
          ctx.lineWidth = method.key === String(state.interpolationMode || '').toLowerCase() ? 2.5 : 1.5;
          ctx.setLineDash(method.dash);

          let pointer = -1;
          ctx.beginPath();
          for (let i = 0; i <= sampleCount; i++) {
            const x = xMin + ((xMax - xMin) * i) / sampleCount;
            const r = interpolatePos(actions, x, pointer, method.key, deriv);
            pointer = r.idx;
            const px = xToPx(x);
            const py = yToPx(clamp(r.pos, 0, 100));
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // Control points
        ctx.fillStyle = '#e6e6e6';
        for (const a of actions) {
          ctx.beginPath();
          ctx.arc(xToPx(a.at), yToPx(a.pos), 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      function clearFunscriptGraph() {
        const canvas = $('funscriptGraph');
        if (!(canvas instanceof HTMLCanvasElement)) return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        const dpr = window.devicePixelRatio || 1;
        const cssW = canvas.clientWidth || 640;
        const cssH = canvas.clientHeight || 140;
        canvas.width = Math.round(cssW * dpr);
        canvas.height = Math.round(cssH * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, cssW, cssH);
      }

      function drawFunscriptGraph(actions, ms) {
        const canvas = $('funscriptGraph');
        if (!(canvas instanceof HTMLCanvasElement)) return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        // Throttle redraw
        const now = Date.now();
        if (!state._lastFsGraphDrawAt) state._lastFsGraphDrawAt = 0;
        if (now - state._lastFsGraphDrawAt < 80) return;
        state._lastFsGraphDrawAt = now;

        const dpr = window.devicePixelRatio || 1;
        const cssW = canvas.clientWidth || 640;
        const cssH = canvas.clientHeight || 140;
        canvas.width = Math.round(cssW * dpr);
        canvas.height = Math.round(cssH * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        ctx.clearRect(0, 0, cssW, cssH);

        // Background
        ctx.fillStyle = '#0f1117';
        ctx.fillRect(0, 0, cssW, cssH);

        // Grid
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 1;
        for (let i = 1; i < 5; i++) {
          const y = (cssH * i) / 5;
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(cssW, y);
          ctx.stroke();
        }

        const windowMs = 10_000;
        const half = windowMs / 2;
        const maxAt = Number(actions[actions.length - 1]?.at) || 0;
        const xMin = Math.max(0, ms - half);
        const xMax = Math.max(xMin + 1, Math.min(maxAt, ms + half));

        const pad = 8;
        const w = cssW - pad * 2;
        const h = cssH - pad * 2;
        const xToPx = (t) => pad + ((t - xMin) / (xMax - xMin)) * w;
        const yToPx = (p) => pad + (1 - p / 100) * h;

        // Sample curve
        const sampleCount = 160;
        let pointer = 0;
        let prev = null;

        for (let i = 0; i <= sampleCount; i++) {
          const t = xMin + ((xMax - xMin) * i) / sampleCount;
          const r = interpolatePos(actions, t, pointer, state.interpolationMode, state.funscriptDerivatives);
          pointer = r.idx;
          const pos = clamp(Number(r.pos) || 0, 0, 100);
          const pt = { t, pos, x: xToPx(t), y: yToPx(pos) };
          if (prev) {
            const dt = Math.max(1, pt.t - prev.t);
            const v = Math.abs(pt.pos - prev.pos) / dt; // pos per ms
            const vNorm = Math.min(1, v * 300); // heuristic
            const hue = Math.round(200 - 200 * vNorm); // slow=blue-ish, fast=red
            ctx.strokeStyle = `hsl(${hue}, 90%, 60%)`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(prev.x, prev.y);
            ctx.lineTo(pt.x, pt.y);
            ctx.stroke();
          }
          prev = pt;
        }

        // Current time marker
        const cx = xToPx(Math.max(xMin, Math.min(xMax, ms)));
        ctx.strokeStyle = 'rgba(255,255,255,0.45)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cx, pad);
        ctx.lineTo(cx, pad + h);
        ctx.stroke();

        // Current position marker
        const itp = interpolatePos(actions, ms, state.funscriptPointer, state.interpolationMode, state.funscriptDerivatives);
        const curPos = clamp(Number(itp.pos) || 0, 0, 100);
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.arc(cx, yToPx(curPos), 3.5, 0, Math.PI * 2);
        ctx.fill();
      }

      function updateFunscriptUi(timeMs) {
        if (!funscriptStatusEl || !funscriptMeterEl || !funscriptLabelEl) return;

        // (Graph drawing is handled by clearFunscriptGraph/drawFunscriptGraph)

        const actions = state.funscript?.actions;
        if (!actions || !Array.isArray(actions) || actions.length === 0) {
          funscriptStatusEl.textContent = 'Funscript: not loaded';
          funscriptMeterEl.style.transform = 'scaleX(0)';
          const axis = String(state.axis || 'L0').toUpperCase();
          funscriptLabelEl.textContent = `${axis}: 0% (000)`;
          state.funscriptPointer = -1;
          state.lastFunscriptValue = 0;
          clearFunscriptGraph();
          return;
        }

        const driveStatus = state.drive ? 'Drive: ON' : 'Drive: OFF';
        const stats = state.funscriptStats;
        const spTxt = (stats && Number.isFinite(stats.avgSpeed) && stats.avgSpeed >= 0)
          ? ` · ${stats.avgSpeed.toFixed(stats.avgSpeed >= 10 ? 0 : 1)}%/s`
          : '';
        funscriptStatusEl.textContent = `Funscript: loaded (${actions.length} actions${spTxt}) - ${driveStatus}`;

        const ms = Number.isFinite(timeMs) ? Math.max(0, timeMs) : 0;
        const itp = interpolatePos(actions, ms, state.funscriptPointer, state.interpolationMode, state.funscriptDerivatives);
        state.funscriptPointer = itp.idx;
        let pos = itp.pos;
        if (!Number.isFinite(pos)) pos = 0;

        state.lastFunscriptValue = pos;
        const pct = Math.max(0, Math.min(100, pos));
        funscriptMeterEl.style.transform = `scaleX(${pct / 100})`;
        const tcodeVal = String(Math.round((pct / 100) * 999)).padStart(3, '0');
        const axis = String(state.axis || 'L0').toUpperCase();
        funscriptLabelEl.textContent = `${axis}: ${Math.round(pct)}% (${tcodeVal})`;

        drawFunscriptGraph(actions, ms);
      }

      function formatTime(ms) {
        if (!Number.isFinite(ms) || ms < 0) return '--:--';
        const totalSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        const mm = String(minutes).padStart(2, '0');
        const ss = String(seconds).padStart(2, '0');
        if (hours > 0) {
          return `${hours}:${mm}:${ss}`;
        }
        return `${minutes}:${ss}`;
      }

      async function tick() {
        const v = $('video');
        const fps = state.noVideo ? (state.remoteFps || 30) : 30;

        let timeMs = 0;
        let paused = true;

        if (!state.noVideo && v instanceof HTMLVideoElement) {
          timeMs = Math.round((v.currentTime || 0) * 1000);
          paused = Boolean(v.paused);
        } else if (state.noVideo) {
          const r = state.followRemote ? getNoVideoTimeMsAndPaused() : getLocalNoVideoTimeMsAndPaused();
          timeMs = r.timeMs;
          paused = r.paused;
        }

        const frame = currentFrame(timeMs / 1000, fps);

        // Update progress bar and time display.
        const progress = $('progress');
        let durationMs = state.durationMs;
        if (!state.noVideo && v instanceof HTMLVideoElement) {
          const d = Number(v.duration);
          if (Number.isFinite(d) && d > 0) durationMs = Math.round(d * 1000);
        }

        if (progress instanceof HTMLInputElement) {
          if (durationMs && durationMs > 0) {
            progress.max = String(durationMs);
            progress.value = String(Math.max(0, Math.min(durationMs, timeMs)));
            progress.disabled = false;
          } else {
            // Unknown duration yet; keep a stable bar until ffprobe/video metadata arrives.
            progress.max = '1';
            progress.value = '0';
            progress.disabled = true;
          }
        }

        if (progressTimeEl) {
          progressTimeEl.textContent = `${formatTime(timeMs)} / ${formatTime(durationMs)}`;
        }

        updateFunscriptUi(timeMs);

        const canReport = Boolean(state.current) && (!state.noVideo ? (v instanceof HTMLVideoElement && Number.isFinite(v.currentTime)) : true);

        if (canReport) {
          $('playback').textContent = `t=${timeMs}ms frame=${frame} fps=${fps}`;
          // Persist playback state only when playing the stream locally.
          if (!state.noVideo) {
            if (Date.now() - state.lastPlaybackPutAt > 1000) {
              state.lastPlaybackPutAt = Date.now();
              try {
                await apiJson('/api/playback', {
                  method: 'PUT',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    clientId: state.clientId,
                    mediaId: state.current.id,
                    timeMs,
                    fps,
                    frame
                  })
                });
              } catch {}
            }
          }

          // Publish sync state only when we're the "driver".
          // If followRemote is ON, we shouldn't send updates.
          // Throttle automatic updates to prevent feedback loops.
          if (!state.followRemote) {
            if (Date.now() >= state.applyingRemoteUntil) {
              sendSyncUpdate({ mediaId: state.current.id, timeMs, paused, fps, frame }, false, getControlTargetClientId());
            }
          }
        }

        window.requestAnimationFrame(tick);
      }

      async function listPorts() {
        try {
          if (!window.mv || typeof window.mv.listSerialPorts !== 'function') {
            logToConsole('error', 'Serial API not available - preload script may not have loaded correctly');
            const sel = $('port');
            sel.innerHTML = '<option value="">Serial API not available</option>';
            return;
          }
          logToConsole('log', 'Listing serial ports...');
          const ports = await window.mv.listSerialPorts();
          logToConsole('log', `Found ${ports.length} serial port(s):`, ports.map(p => p.path).join(', ') || 'none');
          const sel = $('port');
          if (ports.length === 0) {
            sel.innerHTML = '<option value="">No serial ports found</option>';
          } else {
            sel.innerHTML = ports.map((p) => `<option value='${esc(p.path)}'>${esc(p.path)}</option>`).join('');
          }
        } catch (err) {
          const errMsg = err instanceof Error ? err.message : String(err);
          logToConsole('error', 'Failed to list serial ports:', errMsg);
          const sel = $('port');
          sel.innerHTML = '<option value="">Error loading ports</option>';
        }
      }

      $('serverUrl').addEventListener('change', (e) => {
        state.serverUrl = e.target.value;
        void allowSelfSignedForServer(state.serverUrl);
      });
      $('applyServer').addEventListener('click', async () => {
        state.serverUrl = $('serverUrl').value.trim() || state.serverUrl;
        await allowSelfSignedForServer(state.serverUrl);
        savePrefs();
        try { if (state.ws) state.ws.close(); } catch {}
        connectWs();
        state.page = 1;
        await refresh();
      });
      $('q').addEventListener('input', (e) => {
        state.q = e.target.value;
        state.page = 1;
        window.clearTimeout(window.__qt);
        window.__qt = window.setTimeout(() => refresh(), 200);
      });

      $('refresh').addEventListener('click', () => refresh());
      $('prev').addEventListener('click', async () => { state.page = Math.max(1, state.page - 1); await refresh(); });
      $('next').addEventListener('click', async () => {
        const maxPage = Math.max(1, Math.ceil(state.total / state.pageSize));
        state.page = Math.min(maxPage, state.page + 1);
        await refresh();
      });

      $('ports').addEventListener('click', () => listPorts());
      $('connect').addEventListener('click', async () => {
        const portPath = $('port').value;
        const baudRate = Number($('baud').value || 115200);
        await window.mv.serialConnect({ path: portPath, baudRate });
        setStatus('Serial connected');
        state.serialConnected = true;
        state.lastSerialPort = portPath;
        state.lastSerialBaud = baudRate;
        setSerialPill(true);
        savePrefs();
      });
      $('disconnect').addEventListener('click', async () => {
        await window.mv.serialDisconnect();
        setStatus('Serial disconnected');
        state.serialConnected = false;
        setSerialPill(false);
      });

      $('autoConnectSerial').addEventListener('change', () => {
        state.autoConnectSerial = $('autoConnectSerial').checked;
        savePrefs();
      });

      function setAxis(val) {
        state.axis = String(val || 'L0').toUpperCase();
        savePrefs();
      }

      $('axisSelect').addEventListener('change', () => {
        const sel = $('axisSelect').value;
        if (sel === 'CUSTOM') {
          $('axisCustom').style.display = '';
          $('axisCustom').focus();
          setAxis($('axisCustom').value);
        } else {
          $('axisCustom').style.display = 'none';
          $('axisCustom').value = sel;
          setAxis(sel);
        }
      });

      $('axisCustom').addEventListener('input', () => setAxis($('axisCustom').value));

      $('toggleDrive').addEventListener('click', () => {
        state.drive = !state.drive;
        $('toggleDrive').textContent = state.drive ? 'Drive: ON' : 'Drive: OFF';
        setDrivePill();
        savePrefs();
        state.funIndex = -1;
        updateFunscriptUi(state.lastFunscriptValue);

        try {
          if (window.mv && typeof window.mv.setKeepAwake === 'function') {
            window.mv.setKeepAwake(state.drive);
          }
        } catch {}
      });

      $('autoHomeEnabled').addEventListener('change', () => {
        state.autoHomeEnabled = $('autoHomeEnabled').checked;
        savePrefs();
        if (!state.autoHomeEnabled) cancelAutoHome();
      });

      $('btnToggleAutoHomeSettings').addEventListener('click', () => {
        const el = $('autoHomeSettings');
        const isHidden = el.style.display === 'none';
        el.style.display = isHidden ? '' : 'none';
        $('btnToggleAutoHomeSettings').textContent = isHidden ? 'Hide' : 'Show';
      });

      $('autoHomePosition').addEventListener('input', () => {
        state.autoHomePosition = Number($('autoHomePosition').value) || 0;
        savePrefs();

        // If paused and auto-home is enabled, apply the new home position immediately.
        let paused = true;
        const v = $('video');
        if (!state.noVideo && v instanceof HTMLVideoElement) paused = Boolean(v.paused);
        else if (state.noVideo && state.followRemote) paused = Boolean(state.remotePaused);

        if (paused && state.autoHomeEnabled) {
          runAutoHomeNow();
        }
      });

      $('autoHomeDelay').addEventListener('input', () => {
        state.autoHomeDelay = Number($('autoHomeDelay').value) || 0;
        savePrefs();
      });

      $('autoHomeTransition').addEventListener('input', () => {
        state.autoHomeTransition = Number($('autoHomeTransition').value) || 1000;
        savePrefs();
      });

      $('serialResumeDelay').addEventListener('input', () => {
        state.serialResumeDelayMs = Number($('serialResumeDelay').value) || 0;
        savePrefs();
      });

      // Settings modal
      $('btnSettings').addEventListener('click', () => {
        // Update UI from state
        $('invertScriptCheck').checked = state.invertScript;
        $('smoothResumeCheck').checked = state.smoothResumeFunscript;
        const schedInput = $('scheduledPlaySpecInput');
        if (schedInput) schedInput.value = String(state.scheduledPlaySpec ?? '');
        $('scriptDelayInput').value = state.scriptDelay;
        const interpSel = $('interpModeSelect');
        if (interpSel) interpSel.value = state.interpolationMode || 'spline';
        
        // Update axis sliders
        ['L0', 'L1', 'L2', 'L3'].forEach(axis => {
          $(`${axis}MinSlider`).value = state.axisLimits[axis].min;
          $(`${axis}MaxSlider`).value = state.axisLimits[axis].max;
          $(`${axis}MinLabel`).textContent = state.axisLimits[axis].min;
          $(`${axis}MaxLabel`).textContent = state.axisLimits[axis].max;
        });
        
        $('settingsModal').style.display = '';
        drawInterpolationExample();
      });

      $('btnCloseSettings').addEventListener('click', () => {
        $('settingsModal').style.display = 'none';
      });

      $('btnResetSettings').addEventListener('click', () => {
        state.invertScript = false;
        state.smoothResumeFunscript = false;
        state.scheduledPlaySpec = '0.4';
        state.scriptDelay = 0;
        state.interpolationMode = 'spline';
        state.axisLimits = {
          L0: { min: 0, max: 100 },
          L1: { min: 0, max: 100 },
          L2: { min: 0, max: 100 },
          L3: { min: 0, max: 100 },
        };
        savePrefs();
        
        // Update UI
        $('invertScriptCheck').checked = false;
        $('smoothResumeCheck').checked = false;
        const schedInput = $('scheduledPlaySpecInput');
        if (schedInput) schedInput.value = String(state.scheduledPlaySpec ?? '');
        $('scriptDelayInput').value = 0;
        const interpSel = $('interpModeSelect');
        if (interpSel) interpSel.value = 'spline';
        ['L0', 'L1', 'L2', 'L3'].forEach(axis => {
          $(`${axis}MinSlider`).value = 0;
          $(`${axis}MaxSlider`).value = 100;
          $(`${axis}MinLabel`).textContent = 0;
          $(`${axis}MaxLabel`).textContent = 100;
        });

        drawInterpolationExample();
      });

      $('invertScriptCheck').addEventListener('change', () => {
        state.invertScript = $('invertScriptCheck').checked;
        savePrefs();
      });

      $('smoothResumeCheck').addEventListener('change', () => {
        state.smoothResumeFunscript = $('smoothResumeCheck').checked;
        savePrefs();
      });

      const scheduledPlaySpecInput = $('scheduledPlaySpecInput');
      if (scheduledPlaySpecInput) {
        scheduledPlaySpecInput.addEventListener('input', () => {
          state.scheduledPlaySpec = String(scheduledPlaySpecInput.value || '').trim();
          savePrefs();
        });
      }

      $('scriptDelayInput').addEventListener('input', () => {
        state.scriptDelay = Number($('scriptDelayInput').value) || 0;
        savePrefs();
      });

      const interpModeSelect = $('interpModeSelect');
      if (interpModeSelect) {
        interpModeSelect.addEventListener('change', () => {
          state.interpolationMode = String(interpModeSelect.value || 'spline');
          savePrefs();
          drawInterpolationExample();
        });
      }

      // Axis sliders
      ['L0', 'L1', 'L2', 'L3'].forEach(axis => {
        $(`${axis}MinSlider`).addEventListener('input', (e) => {
          const minVal = Number(e.target.value);
          const maxVal = state.axisLimits[axis].max;
          if (minVal > maxVal) {
            e.target.value = maxVal;
            return;
          }
          state.axisLimits[axis].min = minVal;
          $(`${axis}MinLabel`).textContent = minVal;
          savePrefs();
        });

        $(`${axis}MaxSlider`).addEventListener('input', (e) => {
          const maxVal = Number(e.target.value);
          const minVal = state.axisLimits[axis].min;
          if (maxVal < minVal) {
            e.target.value = minVal;
            return;
          }
          state.axisLimits[axis].max = maxVal;
          $(`${axis}MaxLabel`).textContent = maxVal;
          savePrefs();
        });
      });

      $('btnPlayPause').addEventListener('click', async () => {
        const v = $('video');
        if (!(v instanceof HTMLVideoElement)) return;

        if (state.noVideo) {
          if (!state.current) return;

          const now = Date.now();
          const r = getLocalNoVideoTimeMsAndPaused();
          const timeMs = Math.max(0, Math.round(r.timeMs || 0));
          const fps = 30;
          const frame = currentFrame(timeMs / 1000, fps);

          if (state.noVideoPaused) {
            const clockOffset = typeof state.serverClockOffsetMs === 'number' && Number.isFinite(state.serverClockOffsetMs)
              ? state.serverClockOffsetMs
              : 0;
            const sched = parseScheduledPlaySpec(state.scheduledPlaySpec, clockOffset);

            if (sched) {
              sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: false, fps, frame, playAt: sched.playAt }, true, getControlTargetClientId());
              state.noVideoBaseTimeMs = timeMs;
              state.noVideoPaused = true;
              state.noVideoAnchorAtMs = now;
              state.noVideoScheduledPlayAtLocalMs = sched.playAtLocalMs;
              cancelAutoHome();
              return;
            }

            sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: false, fps, frame }, true, getControlTargetClientId());
            state.noVideoBaseTimeMs = timeMs;
            state.noVideoAnchorAtMs = now;
            state.noVideoPaused = false;
            state.noVideoScheduledPlayAtLocalMs = 0;
            cancelAutoHome();
            return;
          }

          // Pausing
          state.noVideoBaseTimeMs = timeMs;
          state.noVideoPaused = true;
          state.noVideoScheduledPlayAtLocalMs = 0;
          triggerAutoHome();
          sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: true, fps, frame, playAt: null }, true, getControlTargetClientId());
          return;
        }

        if (v.paused) {
          const clockOffset = typeof state.serverClockOffsetMs === 'number' && Number.isFinite(state.serverClockOffsetMs)
            ? state.serverClockOffsetMs
            : 0;
          const sched = parseScheduledPlaySpec(state.scheduledPlaySpec, clockOffset);

          if (state.current) {
            const fps = 30;
            const timeMs = Math.round((v.currentTime || 0) * 1000);
            const frame = currentFrame(v.currentTime || 0, fps);
            if (sched) {
              sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: false, fps, frame, playAt: sched.playAt }, true, getControlTargetClientId());
            } else {
              sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: false, fps, frame }, true, getControlTargetClientId());
            }
          }

          cancelAutoHome();
          if (sched) {
            try { v.pause(); } catch {}
            scheduleLocalPlayAt(v, sched.playAtLocalMs);
            return;
          }

          try { await v.play(); } catch {}
          return;
        } else {
          try { v.pause(); } catch {}
          triggerAutoHome(); // Trigger auto-home when pausing
        }
        // Sync the play/pause state to web UI
        if (state.current) {
          const fps = 30;
          const timeMs = Math.round((v.currentTime || 0) * 1000);
          const frame = currentFrame(v.currentTime || 0, fps);
          sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: v.paused, fps, frame, playAt: v.paused ? null : undefined }, true, getControlTargetClientId());
        }
      });

      $('btnVideo').addEventListener('click', () => {
        state.noVideo = !state.noVideo;
        savePrefs();
        setVideoModeUi();
        
        // When toggling video mode, we try to preserve playback state as much as possible
        const v = $('video');
        if (!state.noVideo) {
          // Turning Video ON
          if (state.current?.id && v instanceof HTMLVideoElement) {
             const wasPaused = state.followRemote ? (state.remotePaused ?? true) : Boolean(state.noVideoPaused);
             const seekToMs = state.followRemote
               ? (Number(state.remoteTimeMs) || 0)
               : (Number(getLocalNoVideoTimeMsAndPaused().timeMs) || 0);
             
             // Reload stream but try to seek to where we were
             // openMedia is too destructive (resets funscript state), so we manually set src
             v.src = new URL(`/api/media/${state.current.id}/stream`, state.serverUrl).toString();
             v.currentTime = seekToMs > 0 ? (seekToMs / 1000) : 0;
             if (!wasPaused) {
                 v.play().catch(()=>{});
             }
          }
        } else {
           // Turning Video OFF
           if (v instanceof HTMLVideoElement) {
             const timeMs = Math.round((v.currentTime || 0) * 1000);
             const d = Number(v.duration);
             if (Number.isFinite(d) && d > 0) {
               state.durationMs = Math.round(d * 1000);
             }
             v.pause();
             v.removeAttribute('src');
             v.load();

             // Seed local no-video clock from the last known playback position.
             state.noVideoBaseTimeMs = Math.max(0, timeMs);
             state.noVideoAnchorAtMs = Date.now();
             state.noVideoPaused = true;
             state.noVideoScheduledPlayAtLocalMs = 0;
           }
        }
      });

      $('btnFollow').addEventListener('click', () => {
        state.followRemote = !state.followRemote;
        $('btnFollow').textContent = state.followRemote ? 'Follow remote: ON' : 'Follow remote: OFF';
        savePrefs();

        // If we just became the driver, immediately publish our current state.
        if (!state.followRemote) {
          const v = $('video');
          if (!state.current) return;
          const fps = 30;
          if (state.noVideo) {
            const r = getLocalNoVideoTimeMsAndPaused();
            const timeMs = Math.max(0, Math.round(r.timeMs || 0));
            const frame = currentFrame(timeMs / 1000, fps);
            sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: Boolean(r.paused), fps, frame }, false, getControlTargetClientId());
            return;
          }
          if (v instanceof HTMLVideoElement) {
            const timeMs = Math.round((v.currentTime || 0) * 1000);
            const frame = currentFrame(v.currentTime || 0, fps);
            sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: v.paused, fps, frame }, false, getControlTargetClientId());
          }
        }
      });

      $('followSource').addEventListener('change', () => {
        const val = String($('followSource').value || '');
        state.followSource = val;
        savePrefs();

        // If changed to None, unload immediately.
        if (!val) {
          applyRemoteSyncState({ mediaId: null }); // Passing null mediaId triggers unload
          logToConsole('log', 'Sync WebUI set to None - unloading media');
          return;
        }

        // If changed to a specific source, check if we have cached state.
        const cached = state.sourceStates.get(val);
        if (cached) {
          const meta = state.clientsMetadata.get(val);
          const uiView = meta && typeof meta.uiView === 'string' ? meta.uiView : '';
          const isPlayerView = uiView === 'player' || uiView === 'vr';

          if (uiView && !isPlayerView) {
            // User requested: don't auto-load media when the WebUI isn't on a play screen.
            logToConsole('log', `Sync WebUI changed to ${val} - source is in ${uiView} view; waiting for player update`);
            return;
          }

          logToConsole('log', `Sync WebUI changed to ${val} - applying cached state`);
          applyRemoteSyncState(cached);
        } else {
             logToConsole('log', `Sync WebUI changed to ${val} - waiting for next update`);
        }
      });

      loadPrefs();
      $('serverUrl').value = state.serverUrl;
      await allowSelfSignedForServer(state.serverUrl);

      try {
        if (window.mv && typeof window.mv.setKeepAwake === 'function') {
          window.mv.setKeepAwake(state.drive);
        }
      } catch {}

      // Init axis dropdown
      const common = ['L0','L1','L2','L3'];
      if (common.includes(state.axis)) {
        $('axisSelect').value = state.axis;
        $('axisCustom').value = state.axis;
        $('axisCustom').style.display = 'none';
      } else {
        $('axisSelect').value = 'CUSTOM';
        $('axisCustom').value = state.axis;
        $('axisCustom').style.display = '';
      }

      $('toggleDrive').textContent = state.drive ? 'Drive: ON' : 'Drive: OFF';
      $('btnFollow').textContent = state.followRemote ? 'Follow remote: ON' : 'Follow remote: OFF';

      // Auto-home UI initialization
      $('autoHomeEnabled').checked = state.autoHomeEnabled;
      $('autoHomePosition').value = state.autoHomePosition;
      $('autoHomeDelay').value = state.autoHomeDelay;
      $('autoHomeTransition').value = state.autoHomeTransition;
      $('serialResumeDelay').value = state.serialResumeDelayMs;
      $('autoHomeSettings').style.display = 'none'; // always start hidden unless manually toggled
      $('btnToggleAutoHomeSettings').textContent = 'Show';

      // Auto-connect serial UI initialization
      $('autoConnectSerial').checked = state.autoConnectSerial;
      if (state.lastSerialBaud) $('baud').value = state.lastSerialBaud;

      setVideoModeUi();
      updateFollowSourceOptions();

      setWsPill(false);
      setSerialPill(false);
      setDrivePill();
      setFsPill();

      setStatus('Ready');
      connectWs();
      await listPorts();
      
      // Auto-connect to serial if enabled
      if (state.autoConnectSerial && state.lastSerialPort) {
        // Wait a bit for port list to be ready
        setTimeout(async () => {
          try {
            // Check if the last used port is still available
            const select = $('port');
            const options = Array.from(select.options).map(opt => opt.value);
            if (options.includes(state.lastSerialPort)) {
              select.value = state.lastSerialPort;
              logToConsole('log', `Auto-connecting to ${state.lastSerialPort}...`);
              await window.mv.serialConnect({ path: state.lastSerialPort, baudRate: state.lastSerialBaud });
              state.serialConnected = true;
              setSerialPill(true);
              setStatus('Serial auto-connected');
              logToConsole('log', 'Serial auto-connect successful');
            } else {
              logToConsole('warn', `Auto-connect failed: ${state.lastSerialPort} not found`);
            }
          } catch (err) {
            logToConsole('error', 'Auto-connect failed:', err);
          }
        }, 500);
      }
      
      await refresh();

      const v = $('video');
      if (v instanceof HTMLVideoElement) {
        const fps = 30;
        const push = (e) => {
          // Don't send sync updates if we're currently applying remote state (prevent feedback loop)
          if (state.isApplyingRemoteState) return;
          if (!state.current) return;
          const timeMs = Math.round((v.currentTime || 0) * 1000);
          const frame = currentFrame(v.currentTime || 0, fps);
          logToConsole('log', `Manual video ${v.paused ? 'pause' : 'play'} - syncing to remote`);
          // Auto-home should also respond to manual pauses triggered via native video controls.
          if (v.paused) triggerAutoHome();
          else cancelAutoHome();
          // Coordinated start when user hits play.
          if (e && e.type === 'play') {
            const clockOffset = typeof state.serverClockOffsetMs === 'number' && Number.isFinite(state.serverClockOffsetMs)
              ? state.serverClockOffsetMs
              : 0;
            const sched = parseScheduledPlaySpec(state.scheduledPlaySpec, clockOffset);
            if (sched) {
              sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: false, fps, frame, playAt: sched.playAt }, true, getControlTargetClientId());
              try { v.pause(); } catch {}
              scheduleLocalPlayAt(v, sched.playAtLocalMs);
              return;
            }
            sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: false, fps, frame }, true, getControlTargetClientId());
            return;
          }

          // Manual user interactions always sync (force=true), regardless of follow-remote state
          sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: v.paused, fps, frame, playAt: v.paused ? null : undefined }, true, getControlTargetClientId());
        };
        v.addEventListener('play', push);
        v.addEventListener('pause', push);
        v.addEventListener('seeked', push);
      }

      // Progress bar seeking
      const progressBar = $('progress');
      if (progressBar instanceof HTMLInputElement) {
        progressBar.addEventListener('input', () => {
          const seekMs = Number(progressBar.value);
          if (!Number.isFinite(seekMs)) return;
          try {
            if (!state.current) return;

            if (state.noVideo) {
              // Don't fight the remote driver.
              if (state.followRemote) return;

              state.noVideoBaseTimeMs = Math.max(0, Math.round(seekMs));
              state.noVideoAnchorAtMs = Date.now();
              state.noVideoScheduledPlayAtLocalMs = 0;

              const fps = 30;
              const frame = currentFrame(seekMs / 1000, fps);
              sendSyncUpdate({ mediaId: state.current.id, timeMs: seekMs, paused: Boolean(state.noVideoPaused), fps, frame }, true, getControlTargetClientId());
              return;
            }

            const v = $('video');
            if (!(v instanceof HTMLVideoElement)) return;
            v.currentTime = seekMs / 1000;
            // Immediately sync the seek to web UI
            const fps = 30;
            const frame = currentFrame(seekMs / 1000, fps);
            sendSyncUpdate({ mediaId: state.current.id, timeMs: seekMs, paused: v.paused, fps, frame }, true, getControlTargetClientId());
          } catch {}
        });
      }

      // Console view
      $('btnClearConsole').addEventListener('click', () => {
        state.consoleLogs = [];
        updateConsoleView();
        logToConsole('log', 'Console cleared');
      });

      logToConsole('log', 'Desktop client initialized');
      
      // Check if preload API is available
      if (window.mv) {
        logToConsole('log', 'Preload API available:', Object.keys(window.mv).join(', '));
      } else {
        logToConsole('error', 'Preload API (window.mv) not available! Check that preload.js is loaded correctly.');
      }

      startSerialDriveLoop();

      tick();
    </script>
  </body>
</html>
