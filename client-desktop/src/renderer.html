<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <!-- CSP is injected at build time (scripts/copy-assets.mjs) -->
    <title>MediaViewer Desktop</title>
    <style>
      :root { color-scheme: dark; }
      *, *::before, *::after { box-sizing: border-box; }
      body { margin: 0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; background: #0b0c0f; color: #e6e6e6; }
      header { padding: 12px 16px; border-bottom: 1px solid #222; display: flex; gap: 12px; align-items: center; justify-content: space-between; }
      header h1 { font-size: 14px; margin: 0; }
      .wrap { display: grid; grid-template-columns: minmax(320px, 1fr) minmax(320px, 1fr) minmax(0, 50vw); height: calc(100vh - 50px); }
      .left { border-right: 1px solid #222; padding: 12px; overflow-y: auto; display: grid; gap: 12px; grid-template-rows: auto auto auto 1fr; align-content: start; }
      .middle { border-right: 1px solid #222; padding: 12px; overflow: auto; display: grid; gap: 12px; }
      .right { padding: 12px; overflow: auto; display: grid; gap: 10px; }
      .row { display: flex; gap: 8px; align-items: center; }
      input, select { width: 100%; padding: 10px 12px; border-radius: 8px; border: 1px solid #2a2f3a; background: #11131a; color: #e6e6e6; }
      button { padding: 10px 12px; border-radius: 8px; border: 1px solid #2a2f3a; background: #11131a; color: #e6e6e6; cursor: pointer; }
      button:disabled { opacity: 0.6; cursor: not-allowed; }
      /* Desktop list: match WebUI card design, but always one column */
      .list { margin-top: 12px; display: grid; gap: 12px; grid-template-columns: 1fr; }
      .mvCard { border: 1px solid #222; border-radius: 10px; overflow: hidden; background: #0f1117; display: flex; flex-direction: column; cursor: pointer; }
      .mvCard:hover { border-color: #2a2f3a; }
      .mvCard.active { outline: 2px solid #2a2f3a; outline-offset: 2px; }
      .mvThumb { position: relative; background: #0b0c0f; border-bottom: 1px solid #222; overflow: hidden; }
      .mvThumb::before { content: ""; display: block; padding-top: 56.25%; }
      .mvThumbMedia { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; display: block; background: #000; }
      .mvThumbStatus { position: absolute; inset: 0; display: grid; place-items: center; font-size: 12px; opacity: 0.85; background: linear-gradient(to bottom, rgba(0,0,0,0.25), rgba(0,0,0,0.45)); }
      .mvThumbStatus.hidden { display: none; }
      .mvMeta { padding: 10px; display: flex; flex-direction: column; gap: 6px; flex: 1; min-height: 92px; }
      .mvName { font-size: 12px; line-height: 1.2; word-break: break-word; }
      .mvTags { display: flex; gap: 6px; flex-wrap: wrap; align-content: flex-start; }
      .mvTagBreak { flex-basis: 100%; height: 0; }
      .mvTag { font-size: 11px; padding: 2px 6px; border-radius: 999px; border: 1px solid #2a2f3a; background: #11131a; }
      .mvTag--good { border-color: #14532d; background: rgba(20,83,45,0.35); color: #86efac; }
      .mvTag--bad { border-color: #7f1d1d; background: rgba(127,29,29,0.35); color: #fecaca; }
      .mvTag--vr { border-color: #8b5cf6; background: rgba(139,92,246,0.35); color: #fff; }
      .mvTag--muted { border-color: #374151; background: rgba(55,65,81,0.35); color: #d1d5db; }
      video { width: 100%; aspect-ratio: 16 / 9; height: auto; max-height: 70vh; background: #000; object-fit: contain; }
      input[type="range"] { width: 100%; max-width: 100%; padding: 0; border: 0; background: transparent; }
      .small { font-size: 12px; opacity: 0.85; }
      .pill { display: inline-block; padding: 2px 8px; border: 1px solid #2a2f3a; border-radius: 999px; font-size: 11px; margin-left: 6px; }
      .pill.connected { background: #10b981; color: #fff; border-color: #059669; }
      .pill.disconnected { background: #ef4444; color: #fff; border-color: #dc2626; }
      .statusBtn { padding: 6px 10px; border-radius: 999px; font-size: 11px; line-height: 1; border: 1px solid #2a2f3a; background: #11131a; color: #e6e6e6; }
      .statusBtn.connected { background: #10b981; color: #fff; border-color: #059669; }
      .statusBtn.disconnected { background: #ef4444; color: #fff; border-color: #dc2626; }
      .statusBtn:focus { outline: 2px solid #2a2f3a; outline-offset: 2px; }
      .pill.tag-good { border-color: #14532d; background: rgba(20,83,45,0.35); color: #86efac; }
      .pill.tag-bad { border-color: #7f1d1d; background: rgba(127,29,29,0.35); color: #fecaca; }
      .pill.tag-vr { border-color: #8b5cf6; background: rgba(139,92,246,0.35); color: #fff; }
      .pill.tag-muted { border-color: #374151; background: rgba(55,65,81,0.35); color: #d1d5db; }
      .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
      .card { border: 1px solid #222; border-radius: 12px; padding: 12px; background: #0f1117; }
      .card.console-card { display: flex; flex-direction: column; min-height: 150px; overflow: hidden; }
      .card h2 { margin: 0 0 10px 0; font-size: 12px; font-weight: 600; opacity: 0.9; }
      .kpi { display: flex; gap: 8px; flex-wrap: wrap; justify-content: flex-end; }
      .kpi .pill { margin-left: 0; }
      .mvStatusRow { display: flex; align-items: baseline; justify-content: space-between; gap: 10px; flex-wrap: nowrap; }
      .mvStatusRow > * { min-width: 0; }
      #funscriptStatus { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      #funscriptLabel { white-space: nowrap; margin-top: 0; }
      .stack { display: grid; gap: 8px; }
      .meter { position: relative; height: 14px; border-radius: 999px; background: #1a1c24; border: 1px solid #2a2f3a; overflow: hidden; }
      .meter-fill { position: absolute; inset: 0; background: linear-gradient(90deg, #5b8cff, #2cd3a7); transform-origin: left center; transform: scaleX(0); transition: transform 0.12s ease-out; }
      .meter-label { font-size: 11px; opacity: 0.8; margin-top: 4px; text-align: right; }
      .console-view { border: 1px solid #222; border-radius: 8px; padding: 8px; background: #000; overflow-y: auto; font-family: monospace; font-size: 11px; flex: 1; min-height: 100px; }
    </style>
  </head>
  <body>
    <header>
      <h1>MediaViewer Desktop</h1>
      <div class="kpi">
        <button class="statusBtn disconnected" id="wsBtn" type="button">Server: Connect</button>
        <button class="statusBtn disconnected" id="serialBtn" type="button">Serial: Connect</button>
        <button class="statusBtn disconnected" id="driveBtn" type="button">Drive: OFF</button>
        <span class="pill" id="fsPill">Funscript: —</span>
      </div>
    </header>

    <div class="wrap">
      <div class="left">
        <div class="card">
          <h2>Server</h2>
          <div class="stack">
            <div>
              <div class="small">Server URL</div>
              <div class="row">
                <input id="serverUrl" value="http://localhost:3000" />
                <button id="applyServer" style="max-width: 120px;">Apply</button>
              </div>
            </div>
          </div>
        </div>

        <div class="card">
          <h2>Serial</h2>
          <div class="stack">
            <div class="row">
              <select id="port"></select>
              <input id="baud" value="115200" style="max-width: 120px;" />
            </div>
            <div class="row">
              <button id="ports">Refresh</button>
              <button id="connect">Connect</button>
              <button id="disconnect">Disconnect</button>
            </div>
            <div class="row">
              <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                <input type="checkbox" id="autoConnectSerial" />
                <span class="small">Auto-connect on startup</span>
              </label>
            </div>
            <div class="row"><div class="small" id="status"></div></div>
          </div>
        </div>

        <div class="card">
          <h2>Funscript → TCode</h2>
          <div class="stack">
            <div class="row">
              <select id="axisSelect" style="max-width: 220px;">
                <!-- options are populated dynamically in JS (enabled axes + Custom…) -->
              </select>
              <input id="axisCustom" value="L0" style="max-width: 120px; display:none;" />
              <button id="btnAxis0" style="max-width: 70px;">0%</button>
              <button id="btnAxis50" style="max-width: 70px;">50%</button>
              <button id="btnAxis100" style="max-width: 70px;">100%</button>
              <button id="toggleDrive" style="max-width: 140px;">Drive: OFF</button>
              <button id="btnSettings" style="max-width: 140px;">⚙️ Settings</button>
            </div>
            <div class="row" style="gap: 10px; align-items: center;">
              <div class="small" style="min-width: 110px;">Axis position</div>
              <input type="range" id="axisPosSlider" min="0" max="100" step="1" value="0" style="flex: 1;" />
              <div class="small" id="axisPosLabel" style="min-width: 90px; text-align: right;">0% (000)</div>
            </div>
            <div class="small">Sends TCode lines based on the funscript actions while playing.</div>
            
            <div style="border-top: 1px solid #222; padding-top: 8px; margin-top: 4px;">
              <div class="row" style="justify-content:space-between;">
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                  <input type="checkbox" id="autoHomeEnabled" />
                  <span class="small">Auto-home on pause/stop</span>
                </label>
                <button id="btnToggleAutoHomeSettings" style="max-width: 140px;">Show</button>
              </div>
              <div id="autoHomeSettings" style="display: none; margin-top: 8px;">
                <div class="small" style="margin-bottom: 4px;">Home position (%):</div>
                <input type="number" id="autoHomePosition" min="0" max="100" step="1" value="0" style="margin-bottom: 8px;" />
                <div class="small" style="margin-bottom: 4px;">Delay (seconds):</div>
                <input type="number" id="autoHomeDelay" min="0" max="60" step="0.5" value="2" style="margin-bottom: 8px;" />
                <div class="small" style="margin-bottom: 4px;">Transition time (ms):</div>
                <input type="number" id="autoHomeTransition" min="100" max="10000" step="100" value="2000" />
                <div class="small" style="margin-top: 10px; margin-bottom: 4px;">Resume delay (ms):</div>
                <input type="number" id="serialResumeDelay" min="0" max="10000" step="50" value="0" />
              </div>
            </div>
          </div>
        </div>

        <div class="card console-card">
          <h2>Console Log</h2>
          <div id="consoleView" class="console-view">
            <div style="margin-bottom: 6px; display: flex; justify-content: space-between;">
              <span style="opacity: 0.7;">Debug Output</span>
              <button id="btnClearConsole" style="padding: 2px 8px; font-size: 10px;">Clear</button>
            </div>
            <div id="consoleOutput"></div>
          </div>
        </div>
      </div>

      <div class="middle">
        <div class="card">
          <h2>Media</h2>
          <div class="stack">
            <div class="grid2">
              <div>
                <div class="small">Search</div>
                <input id="q" placeholder="filename" />
              </div>
              <div>
                <div class="small">Paging</div>
                <div class="row">
                  <button id="prev" style="max-width: 90px;">Prev</button>
                  <button id="next" style="max-width: 90px;">Next</button>
                  <div class="small" id="pageLabel" style="white-space: nowrap;"></div>
                </div>
              </div>
              <div>
                <div class="small">Funscript</div>
                <select id="funscriptFilter" style="max-width: 220px;">
                  <option value="any">Any</option>
                  <option value="1">Has funscript</option>
                  <option value="0">No funscript</option>
                </select>
              </div>
              <div>
                <div class="small">VR</div>
                <select id="vrFilter" style="max-width: 220px;">
                  <option value="any">Any</option>
                  <option value="1">VR only</option>
                  <option value="0">Non-VR only</option>
                </select>
              </div>
            </div>
            <div class="row">
              <button id="refresh" style="max-width: 120px;">Refresh</button>
              <div class="small"></div>
            </div>
            <div class="list" id="list"></div>
          </div>
        </div>
      </div>

      <div class="right">
        <div class="column" style="margin-top: 2px;">
          <div class="small" style="white-space: nowrap; margin-bottom: 4px;">Sync Source</div>
          <select id="followSource" style="width: 100%;"></select>
        </div>

        <div class="row" style="justify-content: space-between; gap: 12px; flex-wrap: wrap;">
          <div class="small" id="now"></div>
          <div class="row" style="gap: 8px;">
            <button id="btnPlayPause" style="max-width: 140px;">Play/Pause</button>
            <select id="mediaMode" style="max-width: 180px;">
              <option value="video">Video/Audio</option>
              <option value="audio">Only Audio</option>
              <option value="none">No Video/Audio</option>
            </select>
            <button id="btnFollow" style="max-width: 220px;">Sync: OFF</button>
          </div>
        </div>

        <video id="video" controls></video>
        <input id="progress" type="range" min="0" max="1" value="0" step="1" />
        <div class="small" id="progressTime">--:-- / --:--</div>
        <div class="mvStatusRow">
          <div class="small" id="funscriptStatus">Funscript: not loaded</div>
          <div class="meter-label" id="funscriptLabel">Value: 0% (000)</div>
        </div>
        <div class="meter" aria-hidden="true">
          <div class="meter-fill" id="funscriptMeter"></div>
        </div>
        <canvas id="funscriptGraph" width="640" height="140" style="width:100%; height:140px; border:1px solid #333; border-radius:8px; background:#0f1117;"></canvas>
        <canvas id="funscriptOverviewGraph" width="640" height="90" style="width:100%; height:90px; border:1px solid #333; border-radius:8px; background:#0f1117; margin-top:8px; cursor: pointer;"></canvas>
        <div class="small" id="noVideoHint" style="display:none;">No media mode: using sync playback time only (no /stream requests).</div>
        <div class="small" id="playback"></div>
      </div>
    </div>

    <div id="settingsModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); z-index:1000; overflow:auto;">
      <div style="max-width:700px; margin:40px auto; background:#1e1e1e; border:1px solid #333; border-radius:8px; padding:30px;">
        <h2 style="margin-top:0; color:#fff;">Script & Axis Settings</h2>
        
        <div style="margin-bottom:30px;">
          <h3 style="color:#fff;">Script Transformations</h3>
          <div style="margin-bottom:15px;">
            <label style="display:flex; align-items:center; color:#fff; cursor:pointer;">
              <input type="checkbox" id="invertScriptCheck" style="margin-right:10px;">
              <span>Invert Script Positions (0↔100)</span>
            </label>
          </div>
          <div style="margin-bottom:15px;">
            <label style="display:flex; align-items:center; color:#fff; cursor:pointer;">
              <input type="checkbox" id="halfScriptCheck" style="margin-right:10px;">
              <span>Half script (drop every other full stroke)</span>
            </label>
            <div style="color:#888; font-size:0.9em; margin-left:26px; margin-top:4px;">Keeps one full stroke and stretches it to cover the next stroke’s time (reduces repetition without speeding the script up).</div>
          </div>
          <div style="margin-bottom:15px;">
            <label style="display:flex; align-items:center; color:#fff; cursor:pointer;">
              <input type="checkbox" id="smoothResumeCheck" style="margin-right:10px;">
              <span>Smooth resume funscript on play</span>
            </label>
            <div style="color:#888; font-size:0.9em; margin-left:26px; margin-top:4px;">Ramps device output briefly after pause → play.</div>
          </div>

          <div style="margin-bottom:15px;">
            <label style="display:block; color:#fff; margin-bottom:5px;">Scheduled play (sync)</label>
            <input type="text" id="scheduledPlaySpecInput" style="width:260px; padding:5px;" placeholder="off | seconds | HH:MM | ISO" />
            <div style="color:#888; font-size:0.9em; margin-top:4px;">When set, Play sends a scheduled start time so synced clients can start together.</div>
          </div>
          <div style="margin-bottom:15px;">
            <label style="display:block; color:#fff; margin-bottom:5px;">Script Delay (ms)</label>
            <input type="number" id="scriptDelayInput" step="10" style="width:150px; padding:5px;">
            <span style="color:#888; font-size:0.9em; margin-left:10px;">Negative = earlier, Positive = later</span>
          </div>

          <div style="margin-top:20px; padding-top:15px; border-top:1px solid #333;">
            <label style="display:block; color:#fff; margin-bottom:5px;">Interpolation</label>
            <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
              <select id="interpModeSelect" style="width:220px; padding:5px;">
                <option value="spline">Spline (cubic Hermite)</option>
                <option value="pchip">PCHIP (shape-preserving cubic)</option>
                <option value="makima">MAKIMA (modified Akima)</option>
                <option value="linear">Linear</option>
                <option value="step">Step (hold)</option>
              </select>
              <span style="color:#888; font-size:0.9em;">Applies to the meter and the TCode drive output</span>
            </div>

            <div style="margin-top:12px;">
              <div style="color:#bbb; font-size:0.9em; margin-bottom:6px;">Example comparison</div>
              <canvas id="interpGraph" width="640" height="220" style="width:100%; height:220px; border:1px solid #333; border-radius:8px; background:#0f1117;"></canvas>
              <div id="interpLegend" style="margin-top:6px; color:#aaa; font-size:0.85em; display:flex; gap:12px; flex-wrap:wrap;"></div>
            </div>
          </div>
        </div>

        <div style="margin-bottom:30px;">
          <h3 style="color:#fff;">Enabled Axes</h3>
          <div id="axisEnabledContainer" style="display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap:10px;"></div>
          <div style="color:#888; font-size:0.9em; margin-top:6px;">Disabled axes are hidden from the axis dropdown and won’t send output.</div>
        </div>

        <div style="margin-bottom:30px;">
          <h3 style="color:#fff;">Axis Position Limits</h3>
          <div id="axisLimitsContainer"></div>
        </div>

        <div style="display:flex; gap:10px; justify-content:flex-end;">
          <button id="btnResetSettings" style="padding:8px 16px;">Reset to Defaults</button>
          <button id="btnCloseSettings" style="padding:8px 16px; background:#007acc; color:#fff; border:none; border-radius:4px;">Close</button>
        </div>
      </div>
    </div>

    <script type="module">
      const AXIS_CATALOG = [
        { code: 'L0', label: 'Up' },
        { code: 'L1', label: 'Forward' },
        { code: 'L2', label: 'Left' },
        { code: 'R0', label: 'Twist' },
        { code: 'R1', label: 'Roll' },
        { code: 'R2', label: 'Pitch' },
        { code: 'V0', label: 'Vibe1' },
        { code: 'V1', label: 'Vibe2' },
        { code: 'A0', label: 'Valve' },
        { code: 'A1', label: 'Suck' },
        { code: 'A2', label: 'Lube' },
      ];

      const AXIS_LABEL_BY_CODE = Object.fromEntries(AXIS_CATALOG.map(a => [a.code, a.label]));
      const LEGACY_AXIS_MAP = { L1: 'R0', L2: 'R1', L3: 'R2' }; // older UI used L1/L2/L3 for twist/roll/pitch

      function normalizeAxisCode(axis) {
        return String(axis || '').trim().toUpperCase();
      }

      function isCatalogAxis(axis) {
        const a = normalizeAxisCode(axis);
        return AXIS_LABEL_BY_CODE[a] != null;
      }

      function axisLabel(axis) {
        const a = normalizeAxisCode(axis);
        return AXIS_LABEL_BY_CODE[a] || a || 'Unknown';
      }

      function allAxisCodes() {
        return AXIS_CATALOG.map(a => a.code);
      }

      function enabledAxisCodes() {
        const enabled = [];
        for (const a of AXIS_CATALOG) {
          if (state.axisEnabled?.[a.code]) enabled.push(a.code);
        }
        return enabled;
      }

      function ensureAxisStateDefaults() {
        if (!state.axisEnabled || typeof state.axisEnabled !== 'object') state.axisEnabled = {};
        if (!state.axisLimits || typeof state.axisLimits !== 'object') state.axisLimits = {};

        for (const code of allAxisCodes()) {
          if (typeof state.axisEnabled[code] !== 'boolean') state.axisEnabled[code] = true;
          if (!state.axisLimits[code] || typeof state.axisLimits[code] !== 'object') state.axisLimits[code] = { min: 0, max: 100 };
          if (typeof state.axisLimits[code].min !== 'number') state.axisLimits[code].min = 0;
          if (typeof state.axisLimits[code].max !== 'number') state.axisLimits[code].max = 100;
        }
      }

      function coerceSelectedAxisToEnabled() {
        const current = normalizeAxisCode(state.axis || 'L0');
        if (isCatalogAxis(current) && !state.axisEnabled[current]) {
          const first = enabledAxisCodes()[0] || 'L0';
          state.axis = first;
          return true;
        }
        return false;
      }

      function renderAxisSelectOptions() {
        const sel = $('axisSelect');
        const custom = $('axisCustom');
        if (!sel) return;

        const current = normalizeAxisCode(state.axis || 'L0');
        const enabled = enabledAxisCodes();

        sel.innerHTML = [
          ...enabled.map(code => `<option value="${code}">${code} (${axisLabel(code)})</option>`),
          `<option value="CUSTOM">Custom…</option>`,
        ].join('');

        if (enabled.includes(current)) {
          sel.value = current;
          if (custom) {
            custom.value = current;
            custom.style.display = 'none';
          }
        } else {
          sel.value = 'CUSTOM';
          if (custom) {
            custom.value = current || 'L0';
            custom.style.display = '';
          }
        }
      }

      function renderAxisSettingsUi() {
        ensureAxisStateDefaults();

        const enabledContainer = $('axisEnabledContainer');
        const limitsContainer = $('axisLimitsContainer');
        if (enabledContainer) {
          enabledContainer.innerHTML = AXIS_CATALOG.map(a => {
            const checked = state.axisEnabled[a.code] ? 'checked' : '';
            return `
              <label style="display:flex; align-items:center; gap:8px; color:#fff; cursor:pointer; user-select:none;">
                <input type="checkbox" data-axis-enabled="${a.code}" ${checked} />
                <span>${a.code} (${a.label})</span>
              </label>
            `;
          }).join('');

          enabledContainer.querySelectorAll('input[data-axis-enabled]').forEach(el => {
            el.addEventListener('change', () => {
              const code = normalizeAxisCode(el.getAttribute('data-axis-enabled'));
              state.axisEnabled[code] = Boolean(el.checked);
              savePrefs();

              // If user disabled the currently-selected axis, switch to the first enabled.
              if (coerceSelectedAxisToEnabled()) {
                savePrefs();
                updateAxisQuickUi();
              }

              renderAxisSelectOptions();
              renderAxisLimitsUi();
            });
          });
        }

        function renderAxisLimitsUi() {
          if (!limitsContainer) return;
          const enabled = enabledAxisCodes();
          limitsContainer.innerHTML = enabled.map(code => {
            const limits = state.axisLimits[code] || { min: 0, max: 100 };
            const minVal = clamp(Number(limits.min) || 0, 0, 100);
            const maxVal = clamp(Number(limits.max) || 100, 0, 100);
            const label = axisLabel(code);
            return `
              <div style="margin-bottom:20px;">
                <label style="display:block; color:#fff; margin-bottom:5px;">${code} (${label}) - Min: <span id="${code}MinLabel">${minVal}</span>% | Max: <span id="${code}MaxLabel">${maxVal}</span>%</label>
                <div style="display:flex; gap:15px; align-items:center;">
                  <input type="range" data-axis-min="${code}" min="0" max="100" value="${minVal}" style="flex:1;">
                  <input type="range" data-axis-max="${code}" min="0" max="100" value="${maxVal}" style="flex:1;">
                </div>
              </div>
            `;
          }).join('');

          limitsContainer.querySelectorAll('input[data-axis-min]').forEach(el => {
            el.addEventListener('input', () => {
              const code = normalizeAxisCode(el.getAttribute('data-axis-min'));
              const minVal = clamp(Number(el.value) || 0, 0, 100);
              const maxVal = clamp(Number(state.axisLimits[code]?.max) || 100, 0, 100);
              if (minVal > maxVal) {
                el.value = String(maxVal);
                return;
              }
              state.axisLimits[code].min = minVal;
              const minLabel = $(`${code}MinLabel`);
              if (minLabel) minLabel.textContent = String(minVal);
              savePrefs();
            });
          });

          limitsContainer.querySelectorAll('input[data-axis-max]').forEach(el => {
            el.addEventListener('input', () => {
              const code = normalizeAxisCode(el.getAttribute('data-axis-max'));
              const maxVal = clamp(Number(el.value) || 100, 0, 100);
              const minVal = clamp(Number(state.axisLimits[code]?.min) || 0, 0, 100);
              if (maxVal < minVal) {
                el.value = String(minVal);
                return;
              }
              state.axisLimits[code].max = maxVal;
              const maxLabel = $(`${code}MaxLabel`);
              if (maxLabel) maxLabel.textContent = String(maxVal);
              savePrefs();
            });
          });
        }

        renderAxisLimitsUi();
      }

      const state = {
        serverUrl: 'http://localhost:3000',
        q: '',
        funscriptFilter: 'any', // 'any' | '1' | '0'
        vrFilter: 'any', // 'any' | '1' | '0'
        page: 1,
        pageSize: 30,
        total: 0,
        items: [],
        durationsSec: {},
        _durToken: 0,
        _openMediaToken: 0,
        seenSources: new Map(),
        clientsMetadata: new Map(),
        sourceStates: new Map(),
        current: null,
        funscript: null,
        funscriptDerivatives: null,
        interpolationMode: 'spline',
        funIndex: -1,
        funscriptPointer: -1,
        lastFunscriptValue: 0,
        lastTcodeSentAt: 0,
        lastTcodeSentPos: null,
        axisQuickPct: 0,
        axisQuickSendTimer: null,
        drive: false,
        axis: 'L0',
        axisEnabled: {
          L0: true,
          L1: true,
          L2: true,
          R0: true,
          R1: true,
          R2: true,
          V0: true,
          V1: true,
          A0: true,
          A1: true,
          A2: true,
        },
        autoHomeEnabled: false,
        autoHomePosition: 0,
        autoHomeDelay: 2,
        autoHomeTransition: 2000,
        autoHomeTimer: null,
        serialResumeDelayMs: 0,
        serialResumeHoldUntil: 0,
        smoothResumeFunscript: false,
        scheduledPlaySpec: '0.4',
        funscriptStats: null,
        funscriptHalfActions: null,
        funscriptHalfDerivatives: null,
        funscriptHalfStats: null,
        smoothResumeStartAt: 0,
        smoothResumeUntil: 0,
        smoothResumePos: null,
        smoothResumeLastAt: 0,
        serialDriveTimer: null,
        _serialLastPaused: true,
        invertScript: false,
        halfScript: false,
        scriptDelay: 0,
        autoConnectSerial: false,
        lastSerialPort: '',
        lastSerialBaud: 115200,
        axisLimits: {
          L0: { min: 0, max: 100 },
          L1: { min: 0, max: 100 },
          L2: { min: 0, max: 100 },
          R0: { min: 0, max: 100 },
          R1: { min: 0, max: 100 },
          R2: { min: 0, max: 100 },
          V0: { min: 0, max: 100 },
          V1: { min: 0, max: 100 },
          A0: { min: 0, max: 100 },
          A1: { min: 0, max: 100 },
          A2: { min: 0, max: 100 },
        },
        clientId: 'desktop-' + Math.random().toString(16).slice(2),
        sessionId: 'default',
        ws: null,
        wsConnected: false,
        wsAutoConnect: true,
        wsPingTimer: null,
        wsLastPingNonce: null,
        wsLastPingSentAtMs: 0,
        wsLastPongAtMs: 0,
        wsRttMs: null,
        wsRttEmaMs: null,
        applyingRemoteUntil: 0,
        lastSyncSentAt: 0,
        lastPlaybackPutAt: 0,
        followRemote: false,
        noVideo: false,
        audioOnly: false,
        noVideoBaseTimeMs: 0,
        noVideoAnchorAtMs: 0,
        noVideoPaused: true,
        noVideoScheduledPlayAtLocalMs: 0,
        remoteTimeMs: 0,
        remotePaused: true,
        remoteFps: 30,
        remoteLastUpdateAt: 0,
        remoteProjectedTimeMs: 0,
        remoteProjectedAtMs: 0,
        serverClockOffsetMs: null,
        lastAppliedRemotePaused: null,
        serialConnected: false,
        isApplyingRemoteState: false,

        durationMs: null,
        durationCache: new Map(),
        durationInFlightFor: null,

        followSource: '',
        seenSources: new Map(),
        clientsMetadata: new Map(),

        consoleLogs: [],
        consoleVisible: false,

        _suppressLocalVideoEventsUntil: 0,
        _pendingSeekSync: null,

        _deoVrHost: null,
        _deoVrSourceId: null,
        _deoVrReconnectAt: 0,
        _deoVrReconnectDelayMs: 1000,
        _lastDeoVrSyncSentAt: 0,
        _deoVrSuppressIncomingUntil: 0,

        _av1FallbackTriedFor: null,
      };

      function parseDeoVrHostFromSourceId(sourceId) {
        const id = String(sourceId || '').trim();
        const prefix = 'vr:deovr:';
        if (!id.startsWith(prefix)) return null;
        const host = id.slice(prefix.length).trim();
        return host ? host : null;
      }

      function isVrSourceId(sourceId) {
        const id = String(sourceId || '').trim();
        return id.startsWith('vr:');
      }

      function isHereSphereSourceId(sourceId) {
        const id = String(sourceId || '').trim();
        return id.startsWith('vr:heresphere');
      }

      function isHereSphereFollowLockActive() {
        // Requirement: disable local playback/media switching when synchronised with HereSphere.
        // Interpreted as: Sync is ON (following) and HereSphere is the selected source.
        return Boolean(state.followRemote && isHereSphereSourceId(state.followSource));
      }

      function updateHereSphereFollowLockUi() {
        const locked = isHereSphereFollowLockActive();

        const v = $('video');
        if (v instanceof HTMLVideoElement) {
          v.controls = !locked;
          v.style.pointerEvents = locked ? 'none' : 'auto';
        }

        const progressBar = $('progress');
        if (progressBar instanceof HTMLInputElement) {
          progressBar.disabled = locked;
          progressBar.title = locked ? 'Locked while following HereSphere (Sync ON)' : '';
        }

        const q = $('q');
        if (q instanceof HTMLInputElement) {
          q.disabled = locked;
          q.title = locked ? 'Locked while following HereSphere (Sync ON)' : '';
        }
      }

      function isDrivingDeoVr() {
        // Desktop is the leader when followRemote is OFF.
        if (state.followRemote) return false;
        const src = String(state.followSource || '').trim();
        if (!src || !src.startsWith('vr:deovr:')) return false;
        try {
          if (!(window.mv && typeof window.mv.deoVrGetConnectionInfo === 'function')) return false;
          const info = window.mv.deoVrGetConnectionInfo();
          return Boolean(info && info.ok);
        } catch {
          return false;
        }
      }

      function buildDeoVrStreamUrl(mediaId) {
        if (!mediaId) return null;
        try {
          const u = new URL(`/api/media/${encodeURIComponent(String(mediaId))}/stream`, state.serverUrl);
          // Keep the session attribution.
          u.searchParams.set('sessionId', String(state.sessionId || 'default'));
          // Mark this stream as desktop-initiated so the server doesn't infer DeoVR as the leader.
          u.searchParams.set('mvFrom', 'desktop');
          return u.toString();
        } catch {
          return null;
        }
      }

      function maybeWarnIfServerUrlLikelyUnreachableFromHeadset() {
        try {
          const u = new URL(state.serverUrl);
          const host = String(u.hostname || '').toLowerCase();
          if (host === 'localhost' || host === '127.0.0.1') {
            logToConsole('warn', 'DeoVR remote: serverUrl is localhost; headset likely cannot reach the stream URL. Set serverUrl to your LAN IP.');
          }
        } catch {}
      }

      function sendDeoVrCommandFromSyncUpdate(update) {
        if (!isDrivingDeoVr()) return;
        if (!(window.mv && typeof window.mv.deoVrSend === 'function')) return;

        const mediaId = update && update.mediaId ? String(update.mediaId) : '';
        if (!mediaId) return;
        const path = buildDeoVrStreamUrl(mediaId);
        if (!path) return;

        const timeMs = typeof update.timeMs === 'number' && Number.isFinite(update.timeMs) ? update.timeMs : 0;
        const paused = Boolean(update.paused);
        const currentTime = Math.max(0, timeMs / 1000);
        const playerState = paused ? 1 : 0;

        // When we issue commands, ignore DeoVR's immediate 1Hz status echo for a short window
        // to prevent it from stealing leadership / causing jitter.
        state._deoVrSuppressIncomingUntil = Date.now() + 1500;

        maybeWarnIfServerUrlLikelyUnreachableFromHeadset();

        try {
          window.mv.deoVrSend({ path, currentTime, playerState });
        } catch {}
      }

      function tryParseMediaIdFromDeoVrPath(p) {
        const raw = String(p || '').trim();
        if (!raw) return null;
        try {
          // Prefer URL parsing (expected when DeoVR plays our HTTP stream URL)
          const u = new URL(raw);
          const m = String(u.pathname || '').match(/\/api\/media\/([^/]+)\/stream/i);
          if (!m) return null;
          return decodeURIComponent(m[1]);
        } catch {
          // Fallback: try simple match on raw string
          const m = raw.match(/\/api\/media\/([^/]+)\/stream/i);
          return m ? decodeURIComponent(m[1]) : null;
        }
      }

      function sendSyncUpdateAs(clientIdOverride, update, force = false, toClientId = null) {
        if (!state.wsConnected || !state.ws || state.ws.readyState !== 1) return;
        const cid = String(clientIdOverride || '').trim();
        if (!cid) return;
        const now = Date.now();
        if (!force && now - (Number(state._lastDeoVrSyncSentAt) || 0) < 200) return;
        state._lastDeoVrSyncSentAt = now;
        const payload = {
          type: 'sync:update',
          sessionId: state.sessionId,
          clientId: cid,
          ...update,
        };
        const target = typeof toClientId === 'string' ? toClientId.trim() : '';
        if (target) payload.toClientId = target;
        state.ws.send(JSON.stringify(payload));
      }

      async function updateDeoVrRemoteControlConnection() {
        const desiredSourceId = String(state.followSource || '').trim();
        const desiredHost = parseDeoVrHostFromSourceId(desiredSourceId);

        // Connect whenever a DeoVR source is selected.
        if (!desiredHost) {
          if (state._deoVrHost && window.mv && typeof window.mv.deoVrDisconnect === 'function') {
            try { window.mv.deoVrDisconnect(); } catch {}
          }
          state._deoVrHost = null;
          state._deoVrSourceId = null;
          state._deoVrReconnectAt = 0;
          state._deoVrReconnectDelayMs = 1000;
          return;
        }

        // Already on desired host
        if (String(state._deoVrHost || '') === desiredHost && String(state._deoVrSourceId || '') === desiredSourceId) return;

        state._deoVrHost = desiredHost;
        state._deoVrSourceId = desiredSourceId;
        state._deoVrReconnectAt = 0;
        state._deoVrReconnectDelayMs = 1000;

        if (!(window.mv && typeof window.mv.deoVrConnect === 'function')) {
          logToConsole('error', 'DeoVR remote control API not available (preload)');
          return;
        }

        logToConsole('log', `DeoVR remote: connecting to ${desiredHost}:23554 ...`);
        try {
          const r = await window.mv.deoVrConnect(desiredHost);
          if (!r || r.ok !== true) {
            logToConsole('error', `DeoVR remote: connect failed (${(r && r.error) ? r.error : 'unknown error'})`);
          }
        } catch (err) {
          logToConsole('error', `DeoVR remote: connect failed (${String(err && err.message ? err.message : err)})`);
        }
      }

      function updateFollowButtonUi() {
        const btn = $('btnFollow');
        if (!(btn instanceof HTMLButtonElement)) return;

        const hasSource = Boolean(String(state.followSource || '').trim());
        if (!hasSource) {
          state.followRemote = false;
          btn.disabled = true;
          btn.textContent = 'Sync: OFF';
          return;
        }

        btn.disabled = false;
        btn.textContent = state.followRemote ? 'Sync: ON' : 'Sync: OFF';
      }

      function suppressLocalVideoEventsUntil(untilMs) {
        const t = Number(untilMs) || 0;
        if (!Number.isFinite(t) || t <= 0) return;
        state._suppressLocalVideoEventsUntil = Math.max(Number(state._suppressLocalVideoEventsUntil) || 0, t);
      }

      function isLocalVideoEventSuppressed() {
        return Date.now() < (Number(state._suppressLocalVideoEventsUntil) || 0);
      }

      function ingestServerClockFromState(remote) {
        try {
          if (!remote || !remote.updatedAt) return;
          const nowMs = Date.now();
          const parsed = Date.parse(String(remote.updatedAt));
          if (Number.isNaN(parsed)) return;
          const observedOffset = nowMs - parsed;
          if (typeof state.serverClockOffsetMs !== 'number' || !Number.isFinite(state.serverClockOffsetMs)) {
            state.serverClockOffsetMs = observedOffset;
          } else {
            state.serverClockOffsetMs = state.serverClockOffsetMs * 0.9 + observedOffset * 0.1;
          }
        } catch {}
      }

      function waitForVideoReadyAt(v, targetTimeSeconds, timeoutMs = 6000) {
        if (!(v instanceof HTMLVideoElement)) return Promise.resolve(false);
        const target = Number(targetTimeSeconds) || 0;
        const start = Date.now();
        return new Promise((resolve) => {
          let done = false;
          const finish = (ok) => {
            if (done) return;
            done = true;
            cleanup();
            resolve(Boolean(ok));
          };
          const check = () => {
            if (done) return;
            const now = Date.now();
            if (now - start > timeoutMs) return finish(false);
            const ct = Number.isFinite(v.currentTime) ? v.currentTime : NaN;
            const near = Number.isFinite(ct) ? Math.abs(ct - target) < 0.25 : false;
            const ready = (v.readyState || 0) >= 3; // HAVE_FUTURE_DATA
            if (!v.seeking && near && ready) return finish(true);
          };
          const onEvt = () => check();
          const timer = window.setInterval(check, 100);
          function cleanup() {
            try { window.clearInterval(timer); } catch {}
            try { v.removeEventListener('seeked', onEvt); } catch {}
            try { v.removeEventListener('canplay', onEvt); } catch {}
            try { v.removeEventListener('loadeddata', onEvt); } catch {}
            try { v.removeEventListener('stalled', onEvt); } catch {}
          }
          v.addEventListener('seeked', onEvt);
          v.addEventListener('canplay', onEvt);
          v.addEventListener('loadeddata', onEvt);
          v.addEventListener('stalled', onEvt);
          check();
        });
      }

      async function startSeekSyncAsLeader(v, timeMs) {
        if (!(v instanceof HTMLVideoElement)) return;
        if (!state.current) return;
        const peerId = getControlTargetClientId();
        if (!peerId) return;

        const seekMs = Math.max(0, Math.round(Number(timeMs) || 0));
        const token = `${state.clientId}:${Date.now()}:${Math.random().toString(16).slice(2)}`;

        state._pendingSeekSync = {
          token,
          peerId,
          mediaId: state.current.id,
          timeMs: seekMs,
          selfReady: false,
          peerReady: false,
        };

        // Prevent our own programmatic pause/play from generating forced sync events.
        suppressLocalVideoEventsUntil(Date.now() + 7000);

        try { v.pause(); } catch {}
        try { v.currentTime = seekMs / 1000; } catch {}

        sendSyncUpdate({
          mediaId: state.current.id,
          timeMs: seekMs,
          paused: true,
          fps: 30,
          frame: currentFrame(seekMs / 1000, 30),
          seekToken: token,
          seekPhase: 'request',
          seekWantPlay: true,
          seekTargetClientId: peerId,
        }, true, peerId);

        const okSelf = await waitForVideoReadyAt(v, seekMs / 1000, 6000);
        if (state._pendingSeekSync && state._pendingSeekSync.token === token) {
          state._pendingSeekSync.selfReady = okSelf;
        }

        // Wait for peer ready (or timeout).
        const startWait = Date.now();
        while (state._pendingSeekSync && state._pendingSeekSync.token === token) {
          const p = state._pendingSeekSync;
          if (p.selfReady && p.peerReady) break;
          if (Date.now() - startWait > 6500) break;
          await new Promise(r => setTimeout(r, 60));
        }

        const p = state._pendingSeekSync;
        if (!p || p.token !== token) return;

        const playAtLocalMs = Date.now() + 650;
        const offset = (typeof state.serverClockOffsetMs === 'number' && Number.isFinite(state.serverClockOffsetMs)) ? state.serverClockOffsetMs : 0;
        const playAtServerMs = playAtLocalMs - offset;
        const playAtIso = new Date(playAtServerMs).toISOString();

        sendSyncUpdate({
          mediaId: p.mediaId,
          timeMs: p.timeMs,
          paused: false,
          fps: 30,
          frame: currentFrame(p.timeMs / 1000, 30),
          playAt: playAtIso,
          playAtLocalMs: playAtLocalMs,
          seekToken: token,
          seekPhase: 'commit',
          seekTargetClientId: p.peerId,
        }, true, p.peerId);

        try { v.pause(); } catch {}
        try { v.currentTime = p.timeMs / 1000; } catch {}
        scheduleLocalPlayAt(v, playAtLocalMs);

        state._pendingSeekSync = null;
      }

      // Coordinated start: schedule local play for an exact wall-clock time.
      let _scheduledPlayAtLocalMs = 0;
      let _scheduledPlayTimerId = 0;
      function cancelScheduledPlay() {
        if (_scheduledPlayTimerId) {
          try { window.clearTimeout(_scheduledPlayTimerId); } catch {}
          _scheduledPlayTimerId = 0;
        }
        _scheduledPlayAtLocalMs = 0;
      }
      function scheduleLocalPlayAt(v, playAtLocalMs) {
        if (!(v instanceof HTMLVideoElement)) return;
        const when = Number(playAtLocalMs) || 0;
        if (!Number.isFinite(when) || when <= 0) return;
        if (Math.abs((Number(_scheduledPlayAtLocalMs) || 0) - when) < 10) return;

        // Replace any prior scheduled play.
        cancelScheduledPlay();

        _scheduledPlayAtLocalMs = when;
        const delayMs = Math.max(0, Math.round(when - Date.now()));
        state.applyingRemoteUntil = Math.max(state.applyingRemoteUntil, when + 1000);

        // Prevent programmatic pause/play from emitting local forced sync events.
        suppressLocalVideoEventsUntil(when + 1200);
        try { v.pause(); } catch {}
        _scheduledPlayTimerId = window.setTimeout(() => {
          // If we were paused/cancelled after scheduling, do nothing.
          if (_scheduledPlayAtLocalMs !== when) return;
          if (state.followRemote && state.remotePaused) return;
          try { v.play(); } catch {}
        }, delayMs);
      }

      function parseScheduledPlaySpec(spec, clockOffsetMs) {
        const s = String(spec ?? '').trim();
        if (!s) return null;
        if (s.toLowerCase() === 'off' || s.toLowerCase() === 'none' || s === '0') return null;

        const offset = Number(clockOffsetMs) || 0;

        // Relative seconds (e.g. "0.4" or "5")
        if (/^\+?\d+(?:\.\d+)?$/.test(s)) {
          const sec = Number(s);
          if (!Number.isFinite(sec) || sec <= 0) return null;
          const playAtLocalMs = Date.now() + Math.round(sec * 1000);
          const playAtServerMs = playAtLocalMs - offset;
          return { playAt: new Date(playAtServerMs).toISOString(), playAtLocalMs };
        }

        // Fixed local time-of-day (HH:MM[:SS])
        const m = /^(\d{1,2}):(\d{2})(?::(\d{2}))?$/.exec(s);
        if (m) {
          const hh = Math.max(0, Math.min(23, Number(m[1])));
          const mm = Math.max(0, Math.min(59, Number(m[2])));
          const ss = Math.max(0, Math.min(59, Number(m[3] ?? 0)));
          const now = new Date();
          const target = new Date(now);
          target.setHours(hh, mm, ss, 0);
          if (target.getTime() <= now.getTime() + 50) target.setDate(target.getDate() + 1);
          const playAtLocalMs = target.getTime();
          const playAtServerMs = playAtLocalMs - offset;
          return { playAt: new Date(playAtServerMs).toISOString(), playAtLocalMs };
        }

        // Fixed absolute date/time (ISO or anything Date.parse accepts)
        const parsed = Date.parse(s);
        if (!Number.isNaN(parsed)) {
          const playAtLocalMs = parsed;
          if (!Number.isFinite(playAtLocalMs) || playAtLocalMs <= Date.now() + 50) return null;
          const playAtServerMs = playAtLocalMs - offset;
          return { playAt: new Date(playAtServerMs).toISOString(), playAtLocalMs };
        }

        return null;
      }

      function computeFunscriptStatsFromActions(actions) {
        if (!Array.isArray(actions) || actions.length === 0) return null;
        let totalAbsDeltaPos = 0;
        let totalDtMs = 0;
        for (let i = 1; i < actions.length; i++) {
          const a0 = actions[i - 1];
          const a1 = actions[i];
          const t0 = Number(a0?.at);
          const t1 = Number(a1?.at);
          const p0 = Number(a0?.pos);
          const p1 = Number(a1?.pos);
          if (!Number.isFinite(t0) || !Number.isFinite(t1) || !Number.isFinite(p0) || !Number.isFinite(p1)) continue;
          const dt = t1 - t0;
          if (!(dt > 0)) continue;
          totalDtMs += dt;
          totalAbsDeltaPos += Math.abs(p1 - p0);
        }
        const avgSpeed = totalDtMs > 0 ? (totalAbsDeltaPos / totalDtMs) * 1000 : 0;
        return { actionCount: actions.length, avgSpeed };
      }

      function formatFunscriptStats(actionCount, avgSpeed) {
        const count = Number(actionCount);
        if (!Number.isFinite(count) || count <= 0) return null;
        const speed = Number(avgSpeed);
        const speedPart = Number.isFinite(speed) && speed > 0 ? ` · ${speed.toFixed(1)}%/s` : '';
        return `${Math.round(count)} actions${speedPart}`;
      }

      const $ = (id) => document.getElementById(id);
      const statusEl = $('status');
      const wsBtn = $('wsBtn');
      const serialBtn = $('serialBtn');
      const driveBtn = $('driveBtn');
      const fsPill = $('fsPill');
      const progressTimeEl = $('progressTime');
      const funscriptStatusEl = $('funscriptStatus');
      const funscriptMeterEl = $('funscriptMeter');
      const funscriptLabelEl = $('funscriptLabel');

      function getControlTargetClientId() {
        const id = String(state.followSource || '').trim();
        // VR integrations are not WS clients, so targeted control doesn't apply.
        // Returning null makes the update broadcast to the whole session.
        if (id && isVrSourceId(id)) return null;
        return id ? id : null;
      }

      function logToConsole(level, ...args) {
        const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
        const message = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
        state.consoleLogs.push({ timestamp, level, message });
        if (state.consoleLogs.length > 500) state.consoleLogs.shift();
        updateConsoleView();
        // Also log to browser console
        if (level === 'error') console.error(...args);
        else if (level === 'warn') console.warn(...args);
        else console.log(...args);
      }

      function updateConsoleView() {
        const output = $('consoleOutput');
        if (!output) return;
        const colorMap = { log: '#9ca3af', warn: '#fbbf24', error: '#f87171' };
        output.innerHTML = state.consoleLogs.slice(-100).map(log => 
          `<div style="color: ${colorMap[log.level] || '#9ca3af'}; margin-bottom: 2px;">[${log.timestamp}] ${esc(log.message)}</div>`
        ).join('');
        output.scrollTop = output.scrollHeight;
      }

      async function apiJson(path, opts) {
        const url = new URL(path, state.serverUrl);
        const res = await fetch(url.toString(), opts);
        if (!res.ok) throw new Error(await res.text());
        return res.json();
      }

      async function allowSelfSignedForServer(url) {
        try {
          if (!url) return;
          if (!window.mv || typeof window.mv.allowInsecureCertForUrl !== 'function') return;
          const res = await window.mv.allowInsecureCertForUrl(url);
          if (res && typeof res === 'object' && res.error) {
            logToConsole('warn', `Certificate allow failed for ${url}: ${res.error}`);
          }
        } catch (err) {
          const msg = err instanceof Error ? err.message : String(err);
          logToConsole('warn', `Unable to allow certificate for ${url}: ${msg}`);
        }
      }

      async function ensureDurationMs(mediaId) {
        if (!mediaId) return;
        if (state.durationCache.has(mediaId)) {
          if (state.current && state.current.id === mediaId) {
            state.durationMs = state.durationCache.get(mediaId);
          }
          return;
        }
        if (state.durationInFlightFor === mediaId) return;
        state.durationInFlightFor = mediaId;
        try {
          const r = await apiJson(`/api/media/${encodeURIComponent(mediaId)}/probe`);
          const ms = typeof r?.durationMs === 'number' && Number.isFinite(r.durationMs) && r.durationMs > 0 ? Math.round(r.durationMs) : null;
          state.durationCache.set(mediaId, ms);
          if (state.current && state.current.id === mediaId) {
            state.durationMs = ms;
          }
        } catch {
          state.durationCache.set(mediaId, null);
          if (state.current && state.current.id === mediaId) {
            state.durationMs = null;
          }
        } finally {
          if (state.durationInFlightFor === mediaId) state.durationInFlightFor = null;
        }
      }

      function setStatus(s) { statusEl.textContent = s; }

      function setStatusReady() {
        // Status line lives in the Serial card; avoid showing a misleading "Ready" when no device is connected.
        if (state.serialConnected) setStatus('Ready');
        else setStatus('');
      }

      function setWsPill(connected) {
        let suffix = '';
        if (connected) {
          const now = Date.now();
          const rtt = typeof state.wsRttEmaMs === 'number' && Number.isFinite(state.wsRttEmaMs) ? Math.round(state.wsRttEmaMs) : null;
          const isFresh = typeof state.wsLastPongAtMs === 'number' && state.wsLastPongAtMs > 0 && now - state.wsLastPongAtMs <= 5000;
          if (rtt !== null && isFresh) suffix = ` · RTT ${rtt}ms`;
        }

        if (!wsBtn) return;
        wsBtn.textContent = connected ? `Server: Disconnect${suffix}` : 'Server: Connect';
        wsBtn.className = connected ? 'statusBtn connected' : 'statusBtn disconnected';
      }

      function setSerialPill(connected) {
        if (!serialBtn) return;
        serialBtn.textContent = connected ? 'Serial: Disconnect' : 'Serial: Connect';
        serialBtn.className = connected ? 'statusBtn connected' : 'statusBtn disconnected';
      }

      function setDrivePill() {
        if (!driveBtn) return;
        driveBtn.textContent = state.drive ? 'Drive: ON' : 'Drive: OFF';
        driveBtn.className = state.drive ? 'statusBtn connected' : 'statusBtn disconnected';
      }

      function requestWsConnect() {
        state.wsAutoConnect = true;
        void allowSelfSignedForServer(state.serverUrl);

        const ws = state.ws;
        if (ws && (ws.readyState === 0 || ws.readyState === 1)) {
          // Force reconnect to the latest serverUrl by closing and reopening.
          ws.addEventListener('close', () => connectWs(), { once: true });
          try { ws.close(); } catch {}
          return;
        }
        connectWs();
      }

      function requestWsDisconnect() {
        state.wsAutoConnect = false;
        const ws = state.ws;
        if (ws && (ws.readyState === 0 || ws.readyState === 1)) {
          try { ws.close(); } catch {}
        }
      }

      async function serialConnectFromUi() {
        const portSel = $('port');
        const baudSel = $('baud');
        const portPath = String((portSel && 'value' in portSel ? portSel.value : '') || state.lastSerialPort || '').trim();
        const baudRate = Number((baudSel && 'value' in baudSel ? baudSel.value : '') || state.lastSerialBaud || 115200);

        if (!portPath) {
          logToConsole('warn', 'No serial port selected');
          return;
        }

        await window.mv.serialConnect({ path: portPath, baudRate });
        setStatus('Serial connected');
        state.serialConnected = true;
        state.lastSerialPort = portPath;
        state.lastSerialBaud = baudRate;
        setSerialPill(true);
        updateAxisQuickUi();
        savePrefs();
      }

      async function serialDisconnectFromUi() {
        await window.mv.serialDisconnect();
        setStatus('Serial disconnected');
        state.serialConnected = false;
        setSerialPill(false);
        updateAxisQuickUi();
      }

      function toggleDriveFromUi() {
        state.drive = !state.drive;
        const toggleDriveBtn = $('toggleDrive');
        if (toggleDriveBtn) toggleDriveBtn.textContent = state.drive ? 'Drive: ON' : 'Drive: OFF';
        setDrivePill();
        savePrefs();
        state.funIndex = -1;
        updateFunscriptUi(state.lastFunscriptValue);

        try {
          if (window.mv && typeof window.mv.setKeepAwake === 'function') {
            window.mv.setKeepAwake(state.drive);
          }
        } catch {}
      }

      if (wsBtn) {
        wsBtn.addEventListener('click', () => {
          const ws = state.ws;
          const active = Boolean(ws) && (ws.readyState === 0 || ws.readyState === 1);
          if (active) requestWsDisconnect();
          else requestWsConnect();
        });
      }

      if (serialBtn) {
        serialBtn.addEventListener('click', async () => {
          try {
            if (state.serialConnected) await serialDisconnectFromUi();
            else await serialConnectFromUi();
          } catch (err) {
            const msg = err instanceof Error ? err.message : String(err);
            logToConsole('error', 'Serial action failed:', msg);
          }
        });
      }

      if (driveBtn) {
        driveBtn.addEventListener('click', () => {
          toggleDriveFromUi();
        });
      }

      function setFsPill() {
        const actions = getActiveFunscriptActions();
        const n = actions?.length;
        if (typeof n === 'number') {
          const stats = getActiveFunscriptStats();
          if (stats && Number.isFinite(stats.actionCount) && stats.actionCount > 0 && Number.isFinite(stats.avgSpeed) && stats.avgSpeed >= 0) {
            const sp = stats.avgSpeed;
            fsPill.textContent = `Funscript: ${Math.round(stats.actionCount)} actions · ${sp.toFixed(sp >= 10 ? 0 : 1)}%/s`;
          } else {
            fsPill.textContent = 'Funscript: Loaded';
          }
          fsPill.className = 'pill connected';
        } else {
          fsPill.textContent = 'Funscript: Not available';
          fsPill.className = 'pill disconnected';
        }
      }

      function loadPrefs() {
        try {
          const p = JSON.parse(localStorage.getItem('mvDesktopPrefs') || 'null');
          if (p && typeof p === 'object') {
            if (typeof p.serverUrl === 'string') state.serverUrl = p.serverUrl;
            if (typeof p.axis === 'string') {
              const raw = normalizeAxisCode(p.axis);
              // Migrate older axis naming (L1/L2/L3 used for twist/roll/pitch in the old UI).
              state.axis = LEGACY_AXIS_MAP[raw] || raw;
            }
            if (typeof p.drive === 'boolean') state.drive = p.drive;
            if (typeof p.funscriptFilter === 'string') {
              const v = String(p.funscriptFilter || 'any');
              state.funscriptFilter = (v === '1' || v === '0' || v === 'any') ? v : 'any';
            }
            if (typeof p.vrFilter === 'string') {
              const v = String(p.vrFilter || 'any');
              state.vrFilter = (v === '1' || v === '0' || v === 'any') ? v : 'any';
            }
            if (typeof p.followRemote === 'boolean') state.followRemote = p.followRemote;
            if (typeof p.mediaMode === 'string') {
              const m = String(p.mediaMode || 'video');
              if (m === 'none') { state.noVideo = true; state.audioOnly = false; }
              else if (m === 'audio') { state.noVideo = false; state.audioOnly = true; }
              else { state.noVideo = false; state.audioOnly = false; }
            } else if (typeof p.noVideo === 'boolean') {
              state.noVideo = p.noVideo;
              state.audioOnly = false;
            }
            if (typeof p.followSource === 'string') state.followSource = p.followSource;
            if (typeof p.autoHomeEnabled === 'boolean') state.autoHomeEnabled = p.autoHomeEnabled;
            if (typeof p.autoHomePosition === 'number') state.autoHomePosition = p.autoHomePosition;
            if (typeof p.autoHomeDelay === 'number') state.autoHomeDelay = p.autoHomeDelay;
            if (typeof p.autoHomeTransition === 'number') state.autoHomeTransition = p.autoHomeTransition;
            if (typeof p.serialResumeDelayMs === 'number') state.serialResumeDelayMs = p.serialResumeDelayMs;
            if (typeof p.smoothResumeFunscript === 'boolean') state.smoothResumeFunscript = p.smoothResumeFunscript;
            if (typeof p.scheduledPlaySpec === 'string') state.scheduledPlaySpec = p.scheduledPlaySpec;
            if (typeof p.invertScript === 'boolean') state.invertScript = p.invertScript;
            if (typeof p.halfScript === 'boolean') state.halfScript = p.halfScript;
            if (typeof p.scriptDelay === 'number') state.scriptDelay = p.scriptDelay;
            if (typeof p.interpolationMode === 'string') state.interpolationMode = p.interpolationMode;
            if (typeof p.autoConnectSerial === 'boolean') state.autoConnectSerial = p.autoConnectSerial;
            if (typeof p.lastSerialPort === 'string') state.lastSerialPort = p.lastSerialPort;
            if (typeof p.lastSerialBaud === 'number') state.lastSerialBaud = p.lastSerialBaud;
            if (typeof p.axisQuickPct === 'number') state.axisQuickPct = p.axisQuickPct;

            ensureAxisStateDefaults();

            if (p.axisEnabled && typeof p.axisEnabled === 'object') {
              for (const code of allAxisCodes()) {
                if (typeof p.axisEnabled[code] === 'boolean') state.axisEnabled[code] = p.axisEnabled[code];
              }
            }

            if (p.axisLimits && typeof p.axisLimits === 'object') {
              // First, migrate any legacy limits for L1/L2/L3 -> R0/R1/R2.
              for (const legacyCode of Object.keys(LEGACY_AXIS_MAP)) {
                const mapped = LEGACY_AXIS_MAP[legacyCode];
                const src = p.axisLimits[legacyCode];
                if (src && typeof src === 'object') {
                  if (typeof src.min === 'number') state.axisLimits[mapped].min = src.min;
                  if (typeof src.max === 'number') state.axisLimits[mapped].max = src.max;
                }
              }

              // Then apply non-legacy codes directly.
              for (const code of allAxisCodes()) {
                const src = p.axisLimits[code];
                if (src && typeof src === 'object') {
                  if (typeof src.min === 'number') state.axisLimits[code].min = src.min;
                  if (typeof src.max === 'number') state.axisLimits[code].max = src.max;
                }
              }
            }

            coerceSelectedAxisToEnabled();
          }
        } catch {}
      }

      function savePrefs() {
        const mediaMode = state.noVideo ? 'none' : (state.audioOnly ? 'audio' : 'video');
        localStorage.setItem('mvDesktopPrefs', JSON.stringify({
          serverUrl: state.serverUrl,
          axis: state.axis,
          drive: state.drive,
          funscriptFilter: state.funscriptFilter,
          vrFilter: state.vrFilter,
          followRemote: state.followRemote,
          noVideo: state.noVideo,
          mediaMode,
          followSource: state.followSource,
          autoHomeEnabled: state.autoHomeEnabled,
          autoHomePosition: state.autoHomePosition,
          autoHomeDelay: state.autoHomeDelay,
          autoHomeTransition: state.autoHomeTransition,
          serialResumeDelayMs: state.serialResumeDelayMs,
          smoothResumeFunscript: state.smoothResumeFunscript,
          scheduledPlaySpec: state.scheduledPlaySpec,
          invertScript: state.invertScript,
          halfScript: state.halfScript,
          scriptDelay: state.scriptDelay,
          interpolationMode: state.interpolationMode,
          axisEnabled: state.axisEnabled,
          axisLimits: state.axisLimits,
          autoConnectSerial: state.autoConnectSerial,
          lastSerialPort: state.lastSerialPort,
          lastSerialBaud: state.lastSerialBaud,
          axisQuickPct: state.axisQuickPct,
        }));
      }

      function funscriptTimeMsForPlaybackTimeMs(playbackTimeMs) {
        // Apply delay only. Half-script is implemented by transforming the actions, not by time scaling.
        return (Number(playbackTimeMs) || 0) - (Number(state.scriptDelay) || 0);
      }

      function getActiveFunscriptActions() {
        if (!state.funscript?.actions?.length) return null;
        if (state.halfScript && Array.isArray(state.funscriptHalfActions) && state.funscriptHalfActions.length) return state.funscriptHalfActions;
        return state.funscript.actions;
      }

      function getActiveFunscriptDerivatives() {
        if (!state.funscript?.actions?.length) return null;
        if (state.halfScript && state.funscriptHalfDerivatives) return state.funscriptHalfDerivatives;
        return state.funscriptDerivatives;
      }

      function getActiveFunscriptStats() {
        if (!state.funscript?.actions?.length) return null;
        if (state.halfScript && state.funscriptHalfStats) return state.funscriptHalfStats;
        return state.funscriptStats;
      }

      function recomputeHalfScriptTransform() {
        state.funscriptHalfActions = null;
        state.funscriptHalfDerivatives = null;
        state.funscriptHalfStats = null;
        if (!state.halfScript) return;
        if (!state.funscript?.actions?.length) return;

        const half = computeHalfScriptActionsFromActions(state.funscript.actions);
        if (!half || !Array.isArray(half) || half.length < 2) return;

        state.funscriptHalfActions = half;
        try {
          state.funscriptHalfStats = computeFunscriptStatsFromActions(half);
        } catch {
          state.funscriptHalfStats = null;
        }
        try {
          state.funscriptHalfDerivatives = computeFunscriptDerivatives(half);
        } catch {
          state.funscriptHalfDerivatives = null;
        }
      }

      function computeHalfScriptActionsFromActions(actions) {
        // Keep one full stroke (two segments) and stretch it to fill the next stroke's time.
        // Full stroke is defined by 3 consecutive extrema (peak/trough) points.
        if (!Array.isArray(actions) || actions.length < 3) return null;

        const extrema = [];
        extrema.push(0);

        let lastDir = 0;
        const eps = 1e-6;
        for (let i = 1; i < actions.length; i++) {
          const p0 = Number(actions[i - 1]?.pos);
          const p1 = Number(actions[i]?.pos);
          const dp = p1 - p0;
          if (!Number.isFinite(dp) || Math.abs(dp) < eps) continue;
          const dir = dp > 0 ? 1 : -1;
          if (lastDir === 0) {
            lastDir = dir;
            continue;
          }
          if (dir !== lastDir) {
            const idx = i - 1;
            if (idx > extrema[extrema.length - 1]) extrema.push(idx);
            lastDir = dir;
          }
        }

        const lastIdx = actions.length - 1;
        if (extrema[extrema.length - 1] !== lastIdx) extrema.push(lastIdx);
        if (extrema.length < 3) return null;

        const fullStrokes = [];
        for (let i = 0; i + 2 < extrema.length; i += 2) {
          const a0 = actions[extrema[i]];
          const a2 = actions[extrema[i + 2]];
          const start = Math.max(0, Math.round(Number(a0?.at) || 0));
          const end = Math.max(start, Math.round(Number(a2?.at) || 0));
          if (end > start) fullStrokes.push({ start, end });
        }
        if (fullStrokes.length === 0) return null;

        const out = [];
        let lastOutAt = -Infinity;

        for (let i = 0; i < fullStrokes.length; i += 2) {
          const keep = fullStrokes[i];
          const drop = fullStrokes[i + 1] || null;

          const windowStart = keep.start;
          const windowEnd = drop ? drop.end : keep.end;
          const keepStart = keep.start;
          const keepEnd = keep.end;

          const keepLen = keepEnd - keepStart;
          const windowLen = windowEnd - windowStart;
          if (!(keepLen > 0) || !(windowLen > 0)) continue;

          const scale = windowLen / keepLen;

          // Include actions within the kept stroke interval.
          for (let ai = 0; ai < actions.length; ai++) {
            const a = actions[ai];
            const at = Math.round(Number(a?.at) || 0);
            if (at < keepStart) continue;
            if (at > keepEnd) break;
            const pos = Number(a?.pos);
            if (!Number.isFinite(pos)) continue;

            const mappedAt = windowStart + (at - keepStart) * scale;
            const newAt = Math.round(mappedAt);
            if (newAt < 0) continue;

            if (newAt === lastOutAt) {
              // Prefer the latest value for duplicate timestamps.
              out[out.length - 1] = { at: newAt, pos: pos };
            } else if (newAt > lastOutAt) {
              out.push({ at: newAt, pos: pos });
              lastOutAt = newAt;
            }
          }
        }

        if (out.length < 2) return null;
        return out;
      }

      function cancelAutoHome() {
        if (state.autoHomeTimer) {
          clearTimeout(state.autoHomeTimer);
          state.autoHomeTimer = null;
        }
      }

      async function runAutoHomeNow() {
        cancelAutoHome();

        if (!state.autoHomeEnabled) return;
        if (!state.drive) return;
        if (!state.serialConnected) return;
        if (!window.mv) return;

        try {
          ensureAxisStateDefaults();
          const axis = normalizeAxisCode(state.axis || 'L0');
          if (isCatalogAxis(axis) && !state.axisEnabled[axis]) {
            logToConsole('warn', `Auto-home skipped: axis ${axis} is disabled`);
            return;
          }
          const pos = Math.max(0, Math.min(100, Math.round(state.autoHomePosition)));
          const scaled = Math.round((pos / 100) * 999);
          const vvv = String(scaled).padStart(3, '0');
          const interval = Math.max(100, Math.min(10000, Math.round(state.autoHomeTransition)));
          const iii = String(interval).padStart(5, '0');
          const line = `${axis}${vvv}I${iii}`;
          logToConsole('log', `Auto-home executing (immediate): ${line}`);
          await window.mv.tcodeSend(line);
          state.lastTcodeSentAt = Date.now();
          state.lastTcodeSentPos = pos;
        } catch (err) {
          logToConsole('error', 'Auto-home failed:', err);
        }
      }

      function getNoVideoTimeMsAndPaused() {
        const paused = Boolean(state.remotePaused);
        const base = Number(state.remoteProjectedTimeMs) || Number(state.remoteTimeMs) || 0;
        if (paused) return { timeMs: base, paused: true };
        const anchor = Number(state.remoteProjectedAtMs) || Number(state.remoteLastUpdateAt) || Date.now();
        return { timeMs: base + Math.max(0, Date.now() - anchor), paused: false };
      }

      function getLocalNoVideoTimeMsAndPaused() {
        const now = Date.now();

        const schedAt = Number(state.noVideoScheduledPlayAtLocalMs) || 0;
        if (Number.isFinite(schedAt) && schedAt > now + 10) {
          return { timeMs: Math.max(0, Math.round(Number(state.noVideoBaseTimeMs) || 0)), paused: true };
        }

        // If a scheduled start has passed, transition into playing.
        if (Number.isFinite(schedAt) && schedAt > 0 && schedAt <= now + 10) {
          state.noVideoScheduledPlayAtLocalMs = 0;
          state.noVideoPaused = false;
          state.noVideoAnchorAtMs = now;
        }

        const base = Math.max(0, Math.round(Number(state.noVideoBaseTimeMs) || 0));
        if (state.noVideoPaused) return { timeMs: base, paused: true };

        const anchor = Number(state.noVideoAnchorAtMs) || now;
        return { timeMs: base + Math.max(0, now - anchor), paused: false };
      }

      async function serialDriveTick() {
        if (!state.drive) return;
        if (!state.serialConnected) return;
        if (!state.funscript?.actions?.length) return;

        let timeMs = 0;
        let paused = true;

        const v = $('video');
        if (!state.noVideo && v instanceof HTMLVideoElement) {
          timeMs = Math.round((v.currentTime || 0) * 1000);
          paused = Boolean(v.paused);
        } else if (state.noVideo) {
          const r = state.followRemote ? getNoVideoTimeMsAndPaused() : getLocalNoVideoTimeMsAndPaused();
          timeMs = r.timeMs;
          paused = r.paused;
        }

        // Apply resume delay when transitioning from paused -> playing.
        if (state._serialLastPaused && !paused) {
          const delay = Math.max(0, Math.round(Number(state.serialResumeDelayMs) || 0));
          const startAt = Date.now() + delay;
          state.serialResumeHoldUntil = startAt;
          if (state.smoothResumeFunscript) {
            state.smoothResumeStartAt = startAt;
            state.smoothResumeUntil = startAt + 600;
            state.smoothResumeLastAt = startAt;
            state.smoothResumePos = (typeof state.lastTcodeSentPos === 'number' && Number.isFinite(state.lastTcodeSentPos))
              ? state.lastTcodeSentPos
              : null;
          }
        }
        state._serialLastPaused = paused;

        if (paused) {
          state.smoothResumeStartAt = 0;
          state.smoothResumeUntil = 0;
          state.smoothResumePos = null;
          state.smoothResumeLastAt = 0;
          return;
        }
        if (Date.now() < (Number(state.serialResumeHoldUntil) || 0)) return;

        const actions = getActiveFunscriptActions() || state.funscript.actions;
        const deriv = getActiveFunscriptDerivatives();
        const scriptTimeMs = funscriptTimeMsForPlaybackTimeMs(timeMs);
        const itp = interpolatePos(actions, scriptTimeMs, state.funIndex, state.interpolationMode, deriv);
        state.funIndex = itp.idx;

        ensureAxisStateDefaults();
        const axis = normalizeAxisCode(state.axis || 'L0');
        if (isCatalogAxis(axis) && !state.axisEnabled[axis]) return;
        let pos = itp.pos;
        if (!Number.isFinite(pos)) pos = 0;
        pos = clamp(pos, 0, 100);

        if (state.invertScript) {
          pos = 100 - pos;
        }

        const limits = state.axisLimits[axis] || { min: 0, max: 100 };
        const range = (limits.max - limits.min);
        pos = limits.min + (pos / 100) * range;
        pos = clamp(pos, 0, 100);

        // Smooth resume ramp: briefly ease into the target position after pause → play.
        const now = Date.now();
        if (state.smoothResumeFunscript && now < (Number(state.smoothResumeUntil) || 0)) {
          if (!(typeof state.smoothResumePos === 'number' && Number.isFinite(state.smoothResumePos))) {
            state.smoothResumePos = pos;
          }
          const last = Number(state.smoothResumeLastAt) || now;
          const dt = Math.max(0, now - last);
          state.smoothResumeLastAt = now;

          const tauMs = 150; // lower = snappier, higher = smoother
          const alpha = 1 - Math.exp(-dt / tauMs);
          state.smoothResumePos = state.smoothResumePos + (pos - state.smoothResumePos) * alpha;
          pos = state.smoothResumePos;
        } else if ((Number(state.smoothResumeUntil) || 0) > 0) {
          state.smoothResumeStartAt = 0;
          state.smoothResumeUntil = 0;
          state.smoothResumePos = null;
          state.smoothResumeLastAt = 0;
        }

        const lastAt = Number(state.lastTcodeSentAt) || 0;
        const lastPos = (typeof state.lastTcodeSentPos === 'number' && Number.isFinite(state.lastTcodeSentPos))
          ? state.lastTcodeSentPos
          : null;

        const shouldSendByTime = (now - lastAt) >= 33; // ~30 Hz
        const shouldSendByDelta = lastPos === null ? true : Math.abs(pos - lastPos) >= 0.5;
        if (shouldSendByTime && shouldSendByDelta) {
          state.lastTcodeSentAt = now;
          state.lastTcodeSentPos = pos;

          const scaled = Math.round((pos / 100) * 999);
          const vvv = String(scaled).padStart(3, '0');
          const line = `${axis}${vvv}`;
          try { await window.mv.tcodeSend(line); } catch {}
        }
      }

      function startSerialDriveLoop() {
        try {
          if (state.serialDriveTimer) {
            clearInterval(state.serialDriveTimer);
            state.serialDriveTimer = null;
          }
        } catch {}

        // Run independent from requestAnimationFrame; rAF can pause when minimized.
        state.serialDriveTimer = setInterval(() => {
          serialDriveTick().catch(() => {});
        }, 33);
      }

      async function triggerAutoHome() {
        cancelAutoHome();
        
        // Check requirements
        if (!state.autoHomeEnabled) {
          return;
        }
        if (!state.drive) {
          return;
        }
        if (!state.serialConnected) {
          return;
        }
        
        logToConsole('log', `Auto-home scheduled: ${state.autoHomeDelay}s delay to position ${state.autoHomePosition}%`);
        
        state.autoHomeTimer = setTimeout(async () => {
          try {
            ensureAxisStateDefaults();
            const axis = normalizeAxisCode(state.axis || 'L0');
            if (isCatalogAxis(axis) && !state.axisEnabled[axis]) {
              logToConsole('warn', `Auto-home skipped: axis ${axis} is disabled`);
              return;
            }
            const pos = Math.max(0, Math.min(100, Math.round(state.autoHomePosition)));
            const scaled = Math.round((pos / 100) * 999);
            const vvv = String(scaled).padStart(3, '0');
            const interval = Math.max(100, Math.min(10000, Math.round(state.autoHomeTransition)));
            const iii = String(interval).padStart(5, '0');
            const line = `${axis}${vvv}I${iii}`;
            logToConsole('log', `Auto-home executing: ${line}`);
            if (window.mv) await window.mv.tcodeSend(line);
            state.lastTcodeSentAt = Date.now();
            state.lastTcodeSentPos = pos;
          } catch (err) {
            logToConsole('error', 'Auto-home failed:', err);
          }
        }, state.autoHomeDelay * 1000);
      }

      function labelForSource(id) {
        if (!id) return 'Unknown';
        
        // Check if we have metadata for this client
        const meta = state.clientsMetadata.get(id);
        if (meta) {
          // User requested full browser agent.
          let ua = meta.userAgent || 'Unknown';
          // Clean up common prefix if safe
          if (ua.startsWith('Mozilla/5.0')) {
             ua = ua.replace(/^Mozilla\/5\.0 /, '');
          }
          const ip = (meta.ipAddress || '').replace(/^::ffff:/, '');
          return `${ua} (${ip})`;
        }
        
        // Fallbacks
        if (id.startsWith('vr:deovr:')) {
          const host = parseDeoVrHostFromSourceId(id);
          return host ? `VR (DeoVR) (${host})` : 'VR (DeoVR)';
        }
        if (id.startsWith('vr:heresphere:')) {
          // Expected: vr:heresphere:<ip> or vr:heresphere:<ip>:<connectionKey>
          const parts = String(id).split(':');
          const ip = parts.length >= 3 ? String(parts[2] || '').trim() : '';
          return ip ? `VR (HereSphere) (${ip})` : 'VR (HereSphere)';
        }
        if (id.startsWith('vr:deovr')) return 'VR (DeoVR)';
        if (id.startsWith('vr:heresphere')) return 'VR (HereSphere)';
        if (id.startsWith('desktop-')) return 'Desktop Client';
        if (id.startsWith('web-')) return 'Web Browser';
        
        if (id.length > 20) return id.slice(0, 17) + '...';
        return id;
      }
      
      function parseBrowserFromUserAgent(ua) {
        if (!ua || ua === 'Unknown') return 'Unknown Browser';
        
        // Specific VR browsers/agents
        if (ua.includes('DeoVR')) return 'DeoVR';
        if (ua.includes('HereSphere')) return 'HereSphere';
        if (ua.includes('OculusBrowser')) return 'Oculus Browser';
        if (ua.includes('Wolvic')) return 'Wolvic';
        
        // Common desktop
        if (ua.includes('Edg/')) return 'Edge';
        if (ua.includes('Chrome/')) return 'Chrome';
        if (ua.includes('Firefox/')) return 'Firefox';
        if (ua.includes('Safari/') && !ua.includes('Chrome')) return 'Safari';
        if (ua.includes('OPR/') || ua.includes('Opera/')) return 'Opera';
        
        return 'Browser';
      }

      function updateFollowSourceOptions() {
        const sel = $('followSource');
        if (!(sel instanceof HTMLSelectElement)) return;

        // "Any" option removed per user request.
        // List only active sources.
        const activeIds = Array.from(state.seenSources.keys());
        
        // If followSource is not in active list, we might want to add a "Select a source" option
        // or just show the active ones.
        // User said: "If current selected source gets disconnected change follow source to none."
        
        let html = '<option value="">(None)</option>';
        html += activeIds.map((id) => `<option value="${esc(id)}" ${id === state.followSource ? 'selected' : ''}>${esc(labelForSource(id))}</option>`).join('');
        
        sel.innerHTML = html;

        // If currently selected source is no longer valid/active, reset to none.
        if (state.followSource && !state.seenSources.has(state.followSource)) {
          state.followSource = '';
          state.followRemote = false;
          savePrefs();
          sel.value = '';
          unloadCurrentMedia('Sync source disconnected - set to None - unloading');
        }

        updateFollowButtonUi();
      }

      function setVideoModeUi() {
        // Even in no-media mode, keep controls enabled so we can drive remote clients.
        $('btnPlayPause').disabled = false;

        const mode = state.noVideo ? 'none' : (state.audioOnly ? 'audio' : 'video');

        const sel = $('mediaMode');
        if (sel instanceof HTMLSelectElement) {
          sel.value = mode;
        }

        const v = $('video');
        const showVideo = mode === 'video';
        if (v instanceof HTMLVideoElement) {
          v.style.display = showVideo ? '' : 'none';
        }

        const playPauseBtn = $('btnPlayPause');
        if (playPauseBtn) playPauseBtn.style.display = showVideo ? 'none' : '';

        // Hide custom seek UI when the native video player is visible.
        const progress = $('progress');
        const progressTime = $('progressTime');
        if (progress) progress.style.display = showVideo ? 'none' : '';
        if (progressTime) progressTime.style.display = showVideo ? 'none' : '';

        const hint = $('noVideoHint');
        if (hint) hint.style.display = mode === 'none' ? '' : 'none';

        if (mode === 'none' && v instanceof HTMLVideoElement) {
          // Ensure we don't keep any active stream.
          try {
            v.pause();
            v.removeAttribute('src');
            v.load();
          } catch {}
        }
      }

      function applyDefaultMuteForSync() {
        // When Sync is ON (following a source), mute local audio by default
        // to avoid duplicate audio on the same machine.
        const v = $('video');
        if (!(v instanceof HTMLVideoElement)) return;
        if (state.followRemote && !state.noVideo) {
          if (!v.muted) v.muted = true;
        }
      }

      function wsUrlFromHttp(httpUrl) {
        const u = new URL(httpUrl);
        u.protocol = u.protocol === 'https:' ? 'wss:' : 'ws:';
        u.pathname = '/ws';
        u.search = '';
        u.hash = '';
        return u.toString();
      }

      function connectWs() {
        if (state.ws && (state.ws.readyState === 0 || state.ws.readyState === 1)) return;
        const ws = new WebSocket(wsUrlFromHttp(state.serverUrl));
        state.ws = ws;

        const stopPing = () => {
          if (state.wsPingTimer) {
            window.clearInterval(state.wsPingTimer);
            state.wsPingTimer = null;
          }
        };

        const startPing = () => {
          stopPing();
          state.wsPingTimer = window.setInterval(() => {
            if (!state.wsConnected || !state.ws || state.ws.readyState !== 1) return;
            const nonce = Math.random().toString(16).slice(2);
            state.wsLastPingNonce = nonce;
            state.wsLastPingSentAtMs = Date.now();
            state.ws.send(JSON.stringify({ type: 'ws:ping', nonce, clientSentAt: state.wsLastPingSentAtMs }));
          }, 1000);
        };

        ws.addEventListener('open', () => {
          state.wsConnected = true;
          setStatus('WS connected');
          setWsPill(true);
          ws.send(JSON.stringify({ type: 'sync:hello', clientId: state.clientId, sessionId: state.sessionId }));
          startPing();
        });

        ws.addEventListener('close', () => {
          state.wsConnected = false;
          stopPing();
          setStatus('WS disconnected');
          setWsPill(false);
          if (state.wsAutoConnect !== false) {
            window.setTimeout(() => connectWs(), 1000);
          }
        });

        ws.addEventListener('message', (evt) => {
          let msg;
          try { msg = JSON.parse(String(evt.data)); } catch { return; }

          if (msg && msg.type === 'ws:pong') {
            const nonce = typeof msg.nonce === 'string' ? msg.nonce : null;
            const sentAt = typeof msg.clientSentAt === 'number' ? msg.clientSentAt : NaN;
            if (nonce && state.wsLastPingNonce && nonce !== state.wsLastPingNonce) return;
            if (!Number.isFinite(sentAt) || sentAt <= 0) return;

            const rtt = Date.now() - sentAt;
            if (Number.isFinite(rtt) && rtt >= 0 && rtt <= 60_000) {
              state.wsRttMs = rtt;
              const alpha = 0.2;
              state.wsRttEmaMs = typeof state.wsRttEmaMs === 'number' && Number.isFinite(state.wsRttEmaMs)
                ? state.wsRttEmaMs * (1 - alpha) + rtt * alpha
                : rtt;
              state.wsLastPongAtMs = Date.now();
              setWsPill(true);
            }
            return;
          }

          if (!msg || msg.type !== 'sync:state' || !msg.state) return;

          // Keep an estimate of server clock offset even when we're not actively following.
          ingestServerClockFromState(msg.state);

          // Update clients metadata if provided
          if (msg.clients && Array.isArray(msg.clients)) {
            // Important: VR integrations like HereSphere are not WS clients, but we still want to be
            // able to follow them. Preserve any `vr:*` sources we've seen from sync events.
            const now = Date.now();
            const nextClientIds = new Set();

            state.clientsMetadata.clear();
            for (const client of msg.clients) {
              if (client.clientId && client.clientId !== state.clientId) {
                const id = String(client.clientId);
                nextClientIds.add(id);
                state.seenSources.set(id, now);
                state.clientsMetadata.set(id, {
                  userAgent: client.userAgent || 'Unknown',
                  ipAddress: client.ipAddress || 'Unknown',
                  uiView: typeof client.uiView === 'string' ? client.uiView : undefined,
                  uiMediaId: client.uiMediaId === null ? null : typeof client.uiMediaId === 'string' ? client.uiMediaId : undefined,
                });
              }
            }

            // Remove disconnected non-VR sources.
            for (const id of Array.from(state.seenSources.keys())) {
              if (!String(id).startsWith('vr:') && !nextClientIds.has(id)) {
                state.seenSources.delete(id);
              }
            }

            // Prune stale VR sources (HereSphere/DeoVR) so the dropdown doesn't grow forever.
            const vrTtlMs = 60_000;
            for (const [id, lastSeen] of Array.from(state.seenSources.entries())) {
              if (String(id).startsWith('vr:') && typeof lastSeen === 'number' && now - lastSeen > vrTtlMs) {
                state.seenSources.delete(id);
              }
            }

            updateFollowSourceOptions();
            maybeUnloadIfSelectedSourceNotInPlayerView('Sync source is not in player view');
          }

          const src = String(msg.state.fromClientId || '');
          if (src && src !== state.clientId) {
            // Only bump "last seen" when this source actually produced a new update.
            // Otherwise, periodic sync:state broadcasts (triggered by other clients' status)
            // can keep a VR source (e.g. HereSphere) "alive" forever after it closes.
            const prev = state.sourceStates.get(src);
            const prevUpdatedAt = prev && typeof prev.updatedAt === 'string' ? prev.updatedAt : null;
            const nextUpdatedAt = typeof msg.state.updatedAt === 'string' ? msg.state.updatedAt : null;
            const isNewUpdate = !prevUpdatedAt || !nextUpdatedAt || nextUpdatedAt !== prevUpdatedAt;
            if (isNewUpdate || !state.seenSources.has(src)) {
              state.seenSources.set(src, Date.now());
            }

            // Cache state for this source for instant switching
            state.sourceStates.set(src, msg.state);
            updateFollowSourceOptions();
            maybeUnloadIfSelectedSourceNotInPlayerView('Sync source is not in player view');
            
            // Log VR sync events for debugging
            if (src.startsWith('vr:')) {
              logToConsole('log', `VR sync received: ${src} → media ${msg.state.mediaId}`);
            }
          }

          applyRemoteSyncState(msg.state);
        });
      }

      function sendSyncUpdate(update, force = false, toClientId = null) {
        if (!state.wsConnected || !state.ws || state.ws.readyState !== 1) return;
        if (!force && Date.now() < state.applyingRemoteUntil) return;
        const now = Date.now();
        if (!force && now - state.lastSyncSentAt < 200) return;
        state.lastSyncSentAt = now;
        const payload = {
          type: 'sync:update',
          sessionId: state.sessionId,
          clientId: state.clientId,
          ...update,
          capturedAtLocalMs: (update && update.capturedAtLocalMs != null) ? update.capturedAtLocalMs : Date.now(),
        };
        const target = typeof toClientId === 'string' ? toClientId.trim() : '';
        if (target) payload.toClientId = target;
        state.ws.send(JSON.stringify(payload));

        // Two-way control: when Desktop is the leader and DeoVR is the selected source,
        // push remote-control commands to DeoVR to follow our state.
        if (!state.followRemote) {
          sendDeoVrCommandFromSyncUpdate(update);
        }
      }

      function unloadCurrentMedia(reason) {
        if (!state.current) return;
        cancelScheduledPlay();
        state.current = null;
        state.funscript = null;
        state.funscriptPointer = -1;
        state.durationMs = null;
        state.lastAppliedRemotePaused = null;
        $('now').textContent = 'Now: (Nothing)';

        const v = $('video');
        if (v instanceof HTMLVideoElement) {
          try {
            v.pause();
            v.removeAttribute('src');
            v.load();
          } catch {}
        }

        updateFunscriptUi(0);
        renderList();
        if (reason) logToConsole('log', reason);
      }

      function maybeUnloadIfSelectedSourceNotInPlayerView(reasonPrefix) {
        if (!state.followRemote) return;
        const src = String(state.followSource || '');
        if (!src) return;
        const meta = state.clientsMetadata.get(src);
        const uiView = meta && typeof meta.uiView === 'string' ? meta.uiView : '';
        const isPlayerView = uiView === 'player' || uiView === 'vr';
        if (uiView && !isPlayerView) {
          unloadCurrentMedia(`${reasonPrefix} (${uiView}) - unloading`);
        }
      }

      async function applyRemoteSyncState(remote) {
        // Seek-sync handshake messages (request/ready/commit)
        if (remote && remote.seekToken && remote.seekPhase) {
          // If targeted and not for us, ignore.
          const target = String(remote.seekTargetClientId || '');
          if (target && target !== state.clientId) return;

          // Leader: accept ready acknowledgements.
          if (String(remote.seekPhase) === 'ready') {
            const pending = state._pendingSeekSync;
            if (pending && pending.token === remote.seekToken && String(remote.fromClientId || '') === String(pending.peerId || '')) {
              pending.peerReady = true;
            }
            return;
          }
        }

        // If we're not following, never apply remote state.
        if (!state.followRemote) return;

        // If followSource is empty ("(None)"), do NOT follow anyone.
        // Also ignore remote unload/time updates so local playback isn't disrupted.
        if (!state.followSource) return;

        if (remote && remote.fromClientId && remote.fromClientId === state.clientId) return;

        // Strict checking if a source is selected
        if (String(remote?.fromClientId || '') !== state.followSource) {
          return;
        }

        const meta = state.clientsMetadata.get(state.followSource);
        const uiView = meta && typeof meta.uiView === 'string' ? meta.uiView : '';
        const isPlayerView = uiView === 'player' || uiView === 'vr';
        if (uiView && !isPlayerView) {
          // If we're following this source and it leaves the play screen (e.g. back to overview),
          // mirror that by unloading locally.
          unloadCurrentMedia(`Sync source left player view (${uiView}) - unloading`);
          return;
        }

        // Seek-sync request from followed source: pause + seek + buffer + respond ready.
        if (remote && remote.seekToken && String(remote.seekPhase) === 'request') {
          const wantPlay = Boolean(remote.seekWantPlay);
          const seekMs = Math.max(0, Math.round(Number(remote.timeMs) || 0));
          const id = String(remote.mediaId || '');

          // Ensure media is loaded.
          if (id && (!state.current || state.current.id !== id)) {
            const it = state.items.find((x) => x.id === id) || { id, filename: id, mediaType: 'video', hasFunscript: false };
            await openMedia(it.id, { suppressSync: true, fromRemote: true });
          }

          if (!state.noVideo) {
            const v = $('video');
            if (v instanceof HTMLVideoElement) {
              suppressLocalVideoEventsUntil(Date.now() + 7000);
              try { v.pause(); } catch {}
              try { v.currentTime = seekMs / 1000; } catch {}
              await waitForVideoReadyAt(v, seekMs / 1000, 6000);
            }
          }

          // Always acknowledge readiness; leader will decide whether/when to play.
          sendSyncUpdate({
            mediaId: id,
            timeMs: seekMs,
            paused: true,
            fps: 30,
            frame: currentFrame(seekMs / 1000, 30),
            seekToken: String(remote.seekToken),
            seekPhase: 'ready',
            seekWantPlay: wantPlay,
            seekTargetClientId: String(remote.fromClientId || ''),
          }, true, String(remote.fromClientId || '') || null);
          return;
        }

        // Handle empty/null remote state (deselect current media) only when following the selected source.
        if (!remote || !remote.mediaId) {
          unloadCurrentMedia('Remote cleared media - resetting player');
          return;
        }

        const id = String(remote.mediaId);

        // Follow remote media selection.
        if (!state.current || state.current.id !== id) {
          // ensure list contains it or fetch minimal info
          const it = state.items.find((x) => x.id === id) || { id, filename: id, mediaType: 'video', hasFunscript: false };
          await openMedia(it.id, { suppressSync: true, fromRemote: true });
        }

        // Only throttle time updates, not pause state changes
        const now = Date.now();
        const isThrottled = now < state.applyingRemoteUntil;
        
        const prevRemoteTimeMs = Number(state.remoteTimeMs) || 0;

        const nextRemoteTimeMs = Math.max(0, Math.round(Number(remote.timeMs) || 0));
        state.remoteTimeMs = nextRemoteTimeMs;

        // Be strict about paused parsing (handles booleans, 0/1, and 'true'/'false').
        const pausedRaw = remote.paused;
        const paused = pausedRaw === true || pausedRaw === 1 || pausedRaw === '1' || pausedRaw === 'true';
        state.remoteFps = Math.max(1, Math.round(Number(remote.fps) || 30));

        const nowMs = Date.now();
        let updatedAtMs = null;
        if (remote.updatedAt) {
          const parsed = Date.parse(String(remote.updatedAt));
          if (!Number.isNaN(parsed)) updatedAtMs = parsed;
        }

        if (updatedAtMs !== null) {
          const observedOffset = nowMs - updatedAtMs;
          if (typeof state.serverClockOffsetMs !== 'number' || !Number.isFinite(state.serverClockOffsetMs)) {
            state.serverClockOffsetMs = observedOffset;
          } else {
            state.serverClockOffsetMs = state.serverClockOffsetMs * 0.9 + observedOffset * 0.1;
          }
        }

        const clockOffset = typeof state.serverClockOffsetMs === 'number' && Number.isFinite(state.serverClockOffsetMs)
          ? state.serverClockOffsetMs
          : 0;
        const baselineFromServer = updatedAtMs !== null ? updatedAtMs + clockOffset : nowMs;
        let baselineRemoteNow = baselineFromServer;
        const capRaw = remote.capturedAtLocalMs;
        const cap = typeof capRaw === 'number' ? capRaw : (typeof capRaw === 'string' ? Number(capRaw) : NaN);
        if (Number.isFinite(cap) && cap > 0 && cap <= nowMs + 50) {
          const delta = Math.abs(cap - baselineFromServer);
          if (delta <= 500) {
            baselineRemoteNow = cap;
          }
        }

        let playAtLocalMs = null;
        if (!paused && remote.playAt) {
          const t = Date.parse(String(remote.playAt));
          const fromServer = (!Number.isNaN(t)) ? (t + clockOffset) : null;
          const fromSender = (typeof remote.playAtLocalMs === 'number' && Number.isFinite(remote.playAtLocalMs))
            ? Number(remote.playAtLocalMs)
            : (typeof remote.playAtLocalMs === 'string' ? Number(remote.playAtLocalMs) : NaN);
          if (Number.isFinite(fromSender) && fromSender > 0 && fromServer != null && Math.abs(fromSender - fromServer) <= 50) {
            playAtLocalMs = fromSender;
          } else {
            playAtLocalMs = fromServer;
          }
        }

        const treatAsPaused = (playAtLocalMs != null && playAtLocalMs > nowMs + 10) ? true : paused;
        const driftMs = treatAsPaused ? 0 : Math.max(0, nowMs - baselineRemoteNow);
        const projectedTimeMs = Math.max(0, nextRemoteTimeMs + driftMs);

        state.remoteProjectedTimeMs = projectedTimeMs;
        state.remoteProjectedAtMs = nowMs;
        state.remoteLastUpdateAt = nowMs;

        const pausedChanged = state.remotePaused !== treatAsPaused;
        state.remotePaused = treatAsPaused;
        if (pausedChanged) {
          logToConsole('log', `Remote pause state changed: ${treatAsPaused ? 'PAUSED' : 'PLAYING'}`);
        }

        // In no-video mode, do not load/control the stream.
        if (state.noVideo) return;

        const v = $('video');
        if (!(v instanceof HTMLVideoElement)) return;

        state.isApplyingRemoteState = true;
        try {
          const targetTimeSeconds = projectedTimeMs / 1000;
          const currentTimeSeconds = Number.isFinite(v.currentTime) ? v.currentTime : 0;
          const seekDiff = Math.abs(currentTimeSeconds - targetTimeSeconds);
          const remoteJumpedBack = nextRemoteTimeMs < prevRemoteTimeMs - 100;
          const remoteJumpedForward = nextRemoteTimeMs - prevRemoteTimeMs > 2000;
          const remoteJumped = remoteJumpedBack || remoteJumpedForward;

          const shouldRetarget = remoteJumped || seekDiff > 0.75;

          if (!isThrottled) {
            if (shouldRetarget) {
              try { v.currentTime = targetTimeSeconds; } catch {}
            }
            state.applyingRemoteUntil = nowMs + 1500;
          } else if (remoteJumped) {
            try { v.currentTime = targetTimeSeconds; } catch {}
            state.applyingRemoteUntil = nowMs + 1500;
          }

          // Always apply pause state changes immediately (not throttled)
          if (state.lastAppliedRemotePaused !== state.remotePaused) {
            state.lastAppliedRemotePaused = state.remotePaused;
            state.applyingRemoteUntil = nowMs + 1500; // Prevent immediate sync back
            if (state.remotePaused) {
              if (playAtLocalMs != null && playAtLocalMs > nowMs + 10) {
                // Scheduled play: keep paused until playAt, without triggering auto-home.
                const startTimeSeconds = (nextRemoteTimeMs + Math.max(0, playAtLocalMs - baselineRemoteNow)) / 1000;
                logToConsole('log', `Scheduling play at ${new Date(playAtLocalMs).toISOString()}`);
                try { v.pause(); } catch {}
                cancelAutoHome();
                try { v.currentTime = startTimeSeconds; } catch {}
                suppressLocalVideoEventsUntil(playAtLocalMs + 1200);
                scheduleLocalPlayAt(v, playAtLocalMs);
              } else {
                logToConsole('log', 'Pausing video (remote)');
                cancelScheduledPlay();
                try { v.pause(); } catch {}
                triggerAutoHome(); // Trigger auto-home when remotely paused
              }
            } else {
              logToConsole('log', 'Playing video (remote)');
                cancelScheduledPlay();
              // When resuming, even small network/broadcast delays can leave us slightly behind.
              // Always jump forward to the projected remote time (within a small threshold)
              // so we start in sync without waiting for the next periodic update.
              try {
                const desired = projectedTimeMs / 1000;
                const cur = Number.isFinite(v.currentTime) ? v.currentTime : 0;
                if (Number.isFinite(desired) && Math.abs(cur - desired) > 0.02) {
                  v.currentTime = desired;
                }
              } catch {}
              suppressLocalVideoEventsUntil(Date.now() + 1500);
              try { await v.play(); } catch {}
              cancelAutoHome(); // Cancel auto-home when remotely unpaused
            }
          }
        } finally {
          state.isApplyingRemoteState = false;
        }
      }

      function esc(s) {
        return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'",'&#039;');
      }

      async function refresh() {
        setStatus('Loading list...');
        const url = new URL('/api/media', state.serverUrl);
        url.searchParams.set('q', state.q);
        url.searchParams.set('page', String(state.page));
        url.searchParams.set('pageSize', String(state.pageSize));
        if (state.funscriptFilter === '1' || state.funscriptFilter === '0') {
          url.searchParams.set('hasFunscript', state.funscriptFilter);
        }
        if (state.vrFilter === '1' || state.vrFilter === '0') {
          url.searchParams.set('isVr', state.vrFilter);
        }
        const res = await fetch(url.toString());
        if (!res.ok) throw new Error(await res.text());
        const data = await res.json();
        state.total = data.total;
        state.items = data.items;

        // Prefer server-provided durationMs (from DB scan) to avoid client probing.
        try {
          for (const it of state.items) {
            const id = String(it?.id ?? '');
            const ms = typeof it?.durationMs === 'number' && Number.isFinite(it.durationMs) && it.durationMs > 0 ? it.durationMs : null;
            if (!id || ms == null) continue;
            const sec = ms / 1000;
            if (Number.isFinite(sec) && sec > 0) state.durationsSec[id] = sec;
          }
        } catch {}

        renderList();
        renderPager();
        setStatusReady();
        prefetchDurations();
      }

      function getDurationSec(id) {
        const v = state.durationsSec[id];
        return Number.isFinite(v) ? v : null;
      }

      function formatDuration(seconds) {
        if (!Number.isFinite(seconds) || seconds <= 0) return '--:--';
        const total = Math.round(seconds);
        const h = Math.floor(total / 3600);
        const m = Math.floor((total % 3600) / 60);
        const s = total % 60;
        if (h > 0) return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        return `${m}:${String(s).padStart(2, '0')}`;
      }

      function renderPager() {
        const maxPage = Math.max(1, Math.ceil(state.total / state.pageSize));
        $('pageLabel').textContent = `Page ${state.page} / ${maxPage} (${state.total})`;
        $('prev').disabled = state.page <= 1;
        $('next').disabled = state.page >= maxPage;
      }

      function renderList() {
        $('list').innerHTML = state.items.map((it) => {
          const active = state.current?.id === it.id ? 'active' : '';

          const dur = formatDuration(getDurationSec(it.id) ?? NaN);
          const durationTag = it.mediaType === 'video'
            ? `<span class="mvTag mvLen" data-id="${esc(it.id)}">${esc(dur)}</span>`
            : '';

          const resTag = it.mediaType === 'video'
            ? (() => {
                const w = Number(it.width);
                const h = Number(it.height);
                if (Number.isFinite(w) && Number.isFinite(h) && w > 0 && h > 0) {
                  return `<span class="mvTag mvRes" data-id="${esc(it.id)}">${Math.round(w)}x${Math.round(h)}</span>`;
                }
                return `<span class="mvTag mvRes mvTag--muted" data-id="${esc(it.id)}">?x?</span>`;
              })()
            : '';

          const vr = it.isVr ? `<span class="mvTag mvTag--vr">VR</span>` : '';
          const fs = it.hasFunscript ? `<span class="mvTag mvTag--good">funscript</span>` : `<span class="mvTag mvTag--bad">no funscript</span>`;

          const sp = Number(it.funscriptAvgSpeed);
          const fsSpeedTag = it.hasFunscript
            ? (Number.isFinite(sp) && sp >= 0
                ? `<span class="mvTag">${sp.toFixed(sp >= 10 ? 0 : 1)}%/s</span>`
                : `<span class="mvTag">?%/s</span>`)
            : '';

          const cnt = Number(it.funscriptActionCount);
          const fsCntTag = it.hasFunscript
            ? (Number.isFinite(cnt) && cnt > 0
                ? `<span class="mvTag">${Math.round(cnt)} actions</span>`
                : `<span class="mvTag">? actions</span>`)
            : '';

          const thumbUrl = it.mediaType === 'image'
            ? new URL(`/api/media/${it.id}/stream`, state.serverUrl).toString()
            : new URL(`/api/media/${it.id}/thumb`, state.serverUrl).toString();

          return `
            <div class="mvCard ${active}" role="button" tabindex="0" data-id="${esc(it.id)}" aria-label="Open: ${esc(it.filename)}">
              <div class="mvThumb">
                <img class="mvThumbMedia" loading="lazy" src="${thumbUrl}" alt="${esc(it.filename)}" />
                <div class="mvThumbStatus">Loading…</div>
              </div>
              <div class="mvMeta">
                <div class="mvName">${esc(it.filename)}</div>
                <div class="mvTags">
                  <span class="mvTag">${esc(it.mediaType)}</span>
                  ${vr}
                  ${durationTag}
                  ${resTag}
                  <span class="mvTagBreak"></span>
                  ${fs}
                  ${fsSpeedTag}
                  ${fsCntTag}
                </div>
              </div>
            </div>
          `;
        }).join('');

        const cards = $('list').querySelectorAll('.mvCard');
        for (const c of cards) {
          const id = c.getAttribute('data-id');
          c.addEventListener('click', () => openMedia(id));
          c.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              openMedia(id);
            }
          });
        }

        const imgs = $('list').querySelectorAll('img.mvThumbMedia');
        for (const img of imgs) {
          const status = img.parentElement?.querySelector('.mvThumbStatus');
          if (!status) continue;
          const hide = () => status.classList.add('hidden');
          img.addEventListener('load', hide, { once: true });
          img.addEventListener('error', hide, { once: true });
          if (img.complete) hide();
        }
      }

      async function probeDuration(id) {
        // Desktop version: use hidden video element to probe duration + resolution
        return new Promise((resolve) => {
          const v = document.createElement('video');
          v.preload = 'metadata';
          v.muted = true;
          v.playsInline = true;
          v.src = new URL(`/api/media/${id}/stream`, state.serverUrl).toString();

          const done = (val) => {
            try {
              v.removeAttribute('src');
              v.load();
            } catch {}
            resolve(val);
          };

          v.onloadedmetadata = () => {
            const durationSec = Number.isFinite(v.duration) ? v.duration : null;
            const width = Number.isFinite(v.videoWidth) ? v.videoWidth : null;
            const height = Number.isFinite(v.videoHeight) ? v.videoHeight : null;
            done({ durationSec, width, height });
          };
          v.onerror = () => done(null);
          // Timeout
          setTimeout(() => done(null), 5000);
        });
      }

      async function prefetchDurations() {
        const token = ++state._durToken;
        const ids = state.items
          .filter(it => it.mediaType === 'video')
          .map(it => it.id)
          .filter(id => getDurationSec(id) === null);
          
        if (!ids.length) return;
        
        // Process sequentially to avoid flooding network/process
        for (const id of ids) {
          if (token !== state._durToken) return;
          const meta = await probeDuration(id);
          if (token !== state._durToken) return;
          const d = Number(meta?.durationSec);
          if (Number.isFinite(d) && d > 0) {
            state.durationsSec[id] = d;
            // Update any rendered duration tag(s) for this id
            const tags = document.querySelectorAll(`.mvLen[data-id="${CSS.escape(String(id))}"]`);
            for (const tag of tags) tag.textContent = formatDuration(d);
          }

          const w = Number(meta?.width);
          const h = Number(meta?.height);
          if (Number.isFinite(w) && Number.isFinite(h) && w > 0 && h > 0) {
            const item = state.items.find((x) => String(x.id) === String(id));
            if (item) {
              item.width = w;
              item.height = h;
            }

            const tags = document.querySelectorAll(`.mvRes[data-id="${CSS.escape(String(id))}"]`);
            for (const tag of tags) tag.textContent = `${Math.round(w)}x${Math.round(h)}`;
          }
        }
      }

      async function openMedia(id, opts = {}) {
        id = String(id || '').trim();
        if (!id) {
          logToConsole('warn', 'openMedia called with empty id');
          return;
        }
        const allowWhileLocked = Boolean(opts && (opts.allowWhileLocked || opts.fromRemote));
        if (isHereSphereFollowLockActive() && !allowWhileLocked) {
          logToConsole('warn', 'Blocked local media switch while following HereSphere (Sync ON)');
          return;
        }
        const openToken = ++state._openMediaToken;
        const suppressSync = Boolean(opts.suppressSync);
        const it = state.items.find((x) => x.id === id);
        // When following remote, the media might not be in the currently loaded page.
        // Keep a placeholder so progress/UI can still update.
        state.current = it || { id, filename: id, mediaType: 'video', hasFunscript: false };
        state.funscript = null;
        state.funscriptDerivatives = null;
        state.funscriptStats = null;
        state.funscriptHalfActions = null;
        state.funscriptHalfDerivatives = null;
        state.funscriptHalfStats = null;
        state.funIndex = -1;
        state.funscriptPointer = -1;
        state.lastFunscriptValue = 0;
        state.durationMs = null;
        state.noVideoBaseTimeMs = 0;
        state.noVideoAnchorAtMs = Date.now();
        state.noVideoPaused = true;
        state.noVideoScheduledPlayAtLocalMs = 0;
        // Reset pause tracking so the new video's pause state is applied
        state.lastAppliedRemotePaused = null;
        $('now').textContent = it ? `Now: ${it.filename}` : `Now: ${id}`;
        updateFunscriptUi(0);

        const v = $('video');
        if (v instanceof HTMLVideoElement) {
          if (state.noVideo) {
            try {
              v.pause();
              v.removeAttribute('src');
              v.load();
            } catch {}

            // No-video mode: fetch duration via ffprobe so we can render a real progress bar.
            ensureDurationMs(id);
          } else {
            // Force a clean reload even if the browser thinks it can reuse state.
            try { v.pause(); } catch {}
            try { v.removeAttribute('src'); v.load(); } catch {}
            v.src = new URL(`/api/media/${encodeURIComponent(String(id))}/stream`, state.serverUrl).toString();
            try { v.load(); } catch {}
            applyDefaultMuteForSync();
          }
        }

        if (!suppressSync) {
          const targetId = getControlTargetClientId();
          const shouldOpenInUi = Boolean(targetId && String(targetId).startsWith('web-'));
          // If Sync is ON and we're connected to a WebUI target, also open the media in that WebUI.
          if (state.followRemote && state.wsConnected && targetId) {
            sendSyncUpdate({ mediaId: id, timeMs: 0, paused: true, fps: 30, frame: 0, openInUi: true }, true, targetId);
          } else if (!state.followRemote) {
            // Normal desktop-driver behavior: publish selection to the selected target (if any).
            // When targeting WebUI, include openInUi so it exits the grid view.
            sendSyncUpdate({ mediaId: id, timeMs: 0, paused: true, fps: 30, frame: 0, ...(shouldOpenInUi ? { openInUi: true } : {}) }, true, targetId);
          }
        }

        try {
          const fs = await apiJson(`/api/media/${id}/funscript`);
          if (openToken !== state._openMediaToken) return;
          if (!state.current || state.current.id !== id) return;

          state.funscript = fs;
          state.funscript.actions.sort((a,b) => a.at - b.at);
          state.funscriptPointer = -1;
          state.lastFunscriptValue = 0;
          state._halfScriptCache = null;
          state._halfScriptWindowIdx = 0;

          try {
            state.funscriptStats = computeFunscriptStatsFromActions(state.funscript.actions);
          } catch {
            state.funscriptStats = null;
          }

          // Precompute derivatives for interpolation methods that need them.
          try {
            state.funscriptDerivatives = computeFunscriptDerivatives(state.funscript.actions);
          } catch {
            state.funscriptDerivatives = null;
          }

          // If half-script is enabled, precompute the transformed action list too.
          recomputeHalfScriptTransform();
        } catch {
          if (openToken !== state._openMediaToken) return;
          if (!state.current || state.current.id !== id) return;
          state.funscript = null;
          state.funscriptDerivatives = null;
          state.funscriptStats = null;
          state.funscriptHalfActions = null;
          state.funscriptHalfDerivatives = null;
          state.funscriptHalfStats = null;
        }

        if (openToken !== state._openMediaToken) return;
        if (!state.current || state.current.id !== id) return;
        setFsPill();
        updateFunscriptUi(0);
        renderList();
      }

      function currentFrame(timeSeconds, fps) {
        return Math.max(0, Math.floor(timeSeconds * fps));
      }

      function clamp(n, min, max) {
        return Math.max(min, Math.min(max, n));
      }

      function computeFunscriptDerivatives(actions) {
        const n = actions.length;
        if (!Array.isArray(actions) || n < 2) return { pchip: null, makima: null };

        const t = actions.map(a => Number(a.at) || 0);
        const y = actions.map(a => Number(a.pos) || 0);

        // Ensure strictly increasing time (fallback to linear if not).
        for (let i = 1; i < n; i++) {
          if (!(t[i] > t[i - 1])) {
            return { pchip: null, makima: null };
          }
        }

        return {
          pchip: computePchipDerivatives(t, y),
          makima: computeMakimaDerivatives(t, y),
        };
      }

      function computePchipDerivatives(x, y) {
        const n = x.length;
        if (n < 2) return null;
        if (n === 2) {
          const d = (y[1] - y[0]) / (x[1] - x[0]);
          return [d, d];
        }

        const h = new Array(n - 1);
        const delta = new Array(n - 1);
        for (let i = 0; i < n - 1; i++) {
          h[i] = x[i + 1] - x[i];
          delta[i] = (y[i + 1] - y[i]) / h[i];
        }

        const m = new Array(n).fill(0);

        // Endpoints (Fritsch-Carlson)
        {
          const h0 = h[0], h1 = h[1];
          const d0 = delta[0], d1 = delta[1];
          let m0 = ((2 * h0 + h1) * d0 - h0 * d1) / (h0 + h1);
          if (Math.sign(m0) !== Math.sign(d0)) m0 = 0;
          else if (Math.sign(d0) !== Math.sign(d1) && Math.abs(m0) > 3 * Math.abs(d0)) m0 = 3 * d0;
          m[0] = m0;
        }
        {
          const hn1 = h[n - 2], hn2 = h[n - 3];
          const dn1 = delta[n - 2], dn2 = delta[n - 3];
          let mn = ((2 * hn1 + hn2) * dn1 - hn1 * dn2) / (hn1 + hn2);
          if (Math.sign(mn) !== Math.sign(dn1)) mn = 0;
          else if (Math.sign(dn1) !== Math.sign(dn2) && Math.abs(mn) > 3 * Math.abs(dn1)) mn = 3 * dn1;
          m[n - 1] = mn;
        }

        // Interior
        for (let k = 1; k < n - 1; k++) {
          const dk1 = delta[k - 1];
          const dk = delta[k];
          if (dk1 === 0 || dk === 0 || Math.sign(dk1) !== Math.sign(dk)) {
            m[k] = 0;
          } else {
            const w1 = 2 * h[k] + h[k - 1];
            const w2 = h[k] + 2 * h[k - 1];
            m[k] = (w1 + w2) / (w1 / dk1 + w2 / dk);
          }
        }

        return m;
      }

      function computeMakimaDerivatives(x, y) {
        const n = x.length;
        if (n < 2) return null;
        if (n === 2) {
          const d = (y[1] - y[0]) / (x[1] - x[0]);
          return [d, d];
        }

        const delta = new Array(n - 1);
        for (let i = 0; i < n - 1; i++) {
          const h = x[i + 1] - x[i];
          delta[i] = (y[i + 1] - y[i]) / h;
        }

        const m = new Array(n).fill(0);
        // Simple edge handling (close to common makima behavior)
        m[0] = delta[0];
        m[1] = (delta[0] + delta[1]) / 2;
        m[n - 2] = (delta[n - 3] + delta[n - 2]) / 2;
        m[n - 1] = delta[n - 2];

        for (let i = 2; i <= n - 3; i++) {
          const d_im2 = delta[i - 2];
          const d_im1 = delta[i - 1];
          const d_i = delta[i];
          const d_ip1 = delta[i + 1];

          // Modified Akima weights (MAKIMA)
          const w1 = Math.abs(d_ip1 - d_i) + 0.5 * Math.abs(d_ip1 + d_i);
          const w2 = Math.abs(d_im1 - d_im2) + 0.5 * Math.abs(d_im1 + d_im2);
          const denom = w1 + w2;
          if (denom === 0) {
            m[i] = (d_im1 + d_i) / 2;
          } else {
            m[i] = (w1 * d_im1 + w2 * d_i) / denom;
          }
        }

        return m;
      }

      function findActionIndexAtOrBeforeMs(actions, ms, idxHint) {
        let idx = Number.isInteger(idxHint) ? idxHint : -1;
        if (idx >= actions.length) idx = actions.length - 1;
        if (idx < -1) idx = -1;

        if (idx + 1 < actions.length && actions[idx + 1].at <= ms) {
          while (idx + 1 < actions.length && actions[idx + 1].at <= ms) idx++;
        } else if (idx >= 0 && actions[idx].at > ms) {
          while (idx >= 0 && actions[idx].at > ms) idx--;
        } else if (idx === -1 && actions[0].at <= ms) {
          while (idx + 1 < actions.length && actions[idx + 1].at <= ms) idx++;
        }

        return idx;
      }

      function interpolatePos(actions, ms, idxHint, mode, derivatives) {
        // Returns { pos, idx } where idx is the action index at-or-before ms.
        const idx = findActionIndexAtOrBeforeMs(actions, ms, idxHint);

        const p1 = idx >= 0 ? actions[idx] : null;
        const p2 = idx + 1 < actions.length ? actions[idx + 1] : null;
        if (!p1 && p2) return { pos: Number(p2.pos) || 0, idx };
        if (!p2 && p1) return { pos: Number(p1.pos) || 0, idx };
        if (!p1 || !p2) return { pos: 0, idx };

        const t1 = Number(p1.at) || 0;
        const t2 = Number(p2.at) || (t1 + 1);
        const span = Math.max(1, t2 - t1);
        const u = clamp((ms - t1) / span, 0, 1);

        const y1 = Number(p1.pos) || 0;
        const y2 = Number(p2.pos) || 0;

        const interpMode = String(mode || 'spline').toLowerCase();
        if (interpMode === 'step') {
          return { pos: y1, idx };
        }

        if (interpMode === 'linear') {
          const y = y1 + (y2 - y1) * u;
          return { pos: Number.isFinite(y) ? y : y1, idx };
        }

        // Cubic Hermite with various slope sources
        let d1 = 0;
        let d2 = 0;

        if (interpMode === 'pchip' && derivatives?.pchip && derivatives.pchip.length === actions.length) {
          d1 = Number(derivatives.pchip[idx]) || 0;
          d2 = Number(derivatives.pchip[idx + 1]) || 0;
        } else if (interpMode === 'makima' && derivatives?.makima && derivatives.makima.length === actions.length) {
          d1 = Number(derivatives.makima[idx]) || 0;
          d2 = Number(derivatives.makima[idx + 1]) || 0;
        } else {
          // Default spline: estimate slopes from neighbors (time-aware)
          const p0 = idx - 1 >= 0 ? actions[idx - 1] : p1;
          const p3 = idx + 2 < actions.length ? actions[idx + 2] : p2;
          const t0 = Number(p0.at) || t1;
          const t3 = Number(p3.at) || t2;
          const y0 = Number(p0.pos) || 0;
          const y3 = Number(p3.pos) || 0;
          d1 = (t2 - t0) !== 0 ? (y2 - y0) / (t2 - t0) : 0;
          d2 = (t3 - t1) !== 0 ? (y3 - y1) / (t3 - t1) : 0;
        }

        const m1 = d1 * span;
        const m2 = d2 * span;

        const u2 = u * u;
        const u3 = u2 * u;
        const h00 = 2 * u3 - 3 * u2 + 1;
        const h10 = u3 - 2 * u2 + u;
        const h01 = -2 * u3 + 3 * u2;
        const h11 = u3 - u2;

        let y = h00 * y1 + h10 * m1 + h01 * y2 + h11 * m2;

        // Prevent overshoot between adjacent points (safer for motion control).
        const lo = Math.min(y1, y2);
        const hi = Math.max(y1, y2);
        y = clamp(y, lo, hi);

        if (!Number.isFinite(y)) y = y1;
        return { pos: y, idx };
      }

      function getExampleActions() {
        // Fixed example to highlight differences between interpolators.
        return [
          { at: 0, pos: 10 },
          { at: 500, pos: 95 },
          { at: 1000, pos: 15 },
          { at: 1500, pos: 85 },
          { at: 2000, pos: 30 },
        ];
      }

      function drawInterpolationExample() {
        const canvas = $('interpGraph');
        const legend = $('interpLegend');
        if (!(canvas instanceof HTMLCanvasElement) || !legend) return;

        const actions = getExampleActions();
        const deriv = computeFunscriptDerivatives(actions);

        const dpr = Math.max(1, Math.round(window.devicePixelRatio || 1));
        const cssW = canvas.clientWidth || 640;
        const cssH = canvas.clientHeight || 220;
        canvas.width = Math.round(cssW * dpr);
        canvas.height = Math.round(cssH * dpr);
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        const padL = 40, padR = 12, padT = 10, padB = 26;
        const w = cssW, h = cssH;
        const plotW = w - padL - padR;
        const plotH = h - padT - padB;

        const xMin = actions[0].at;
        const xMax = actions[actions.length - 1].at;
        const yMin = 0;
        const yMax = 100;

        const xToPx = (x) => padL + ((x - xMin) / (xMax - xMin)) * plotW;
        const yToPx = (y) => padT + (1 - (y - yMin) / (yMax - yMin)) * plotH;

        // Background
        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = '#0f1117';
        ctx.fillRect(0, 0, w, h);

        // Grid
        ctx.strokeStyle = '#24272f';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 6]);
        for (let i = 0; i <= 4; i++) {
          const yy = padT + (plotH * i) / 4;
          ctx.beginPath();
          ctx.moveTo(padL, yy);
          ctx.lineTo(w - padR, yy);
          ctx.stroke();
        }
        ctx.setLineDash([]);

        // Axes
        ctx.strokeStyle = '#3a3f4c';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padL, padT);
        ctx.lineTo(padL, h - padB);
        ctx.lineTo(w - padR, h - padB);
        ctx.stroke();

        // Labels
        ctx.fillStyle = '#b7bcc7';
        ctx.font = '11px system-ui, Segoe UI, Arial';
        ctx.fillText('100', 6, yToPx(100) + 4);
        ctx.fillText('0', 16, yToPx(0) + 4);
        ctx.fillText(`${xMin}ms`, padL, h - 8);
        ctx.fillText(`${xMax}ms`, w - padR - 50, h - 8);

        const methods = [
          { key: 'spline', label: 'Spline', color: '#5b8cff', dash: [] },
          { key: 'pchip', label: 'PCHIP', color: '#2cd3a7', dash: [6, 6] },
          { key: 'makima', label: 'MAKIMA', color: '#fbbf24', dash: [2, 6] },
          { key: 'linear', label: 'Linear', color: '#a78bfa', dash: [10, 4] },
          { key: 'step', label: 'Step', color: '#f87171', dash: [] },
        ];

        legend.innerHTML = methods.map(m => {
          return `<span style="display:flex; align-items:center; gap:6px;"><span style="width:18px; height:2px; background:${m.color}; display:inline-block;"></span>${m.label}</span>`;
        }).join('');

        const sampleCount = 240;
        for (const method of methods) {
          ctx.strokeStyle = method.color;
          ctx.lineWidth = method.key === String(state.interpolationMode || '').toLowerCase() ? 2.5 : 1.5;
          ctx.setLineDash(method.dash);

          let pointer = -1;
          ctx.beginPath();
          for (let i = 0; i <= sampleCount; i++) {
            const x = xMin + ((xMax - xMin) * i) / sampleCount;
            const r = interpolatePos(actions, x, pointer, method.key, deriv);
            pointer = r.idx;
            const px = xToPx(x);
            const py = yToPx(clamp(r.pos, 0, 100));
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // Control points
        ctx.fillStyle = '#e6e6e6';
        for (const a of actions) {
          ctx.beginPath();
          ctx.arc(xToPx(a.at), yToPx(a.pos), 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      function clearFunscriptGraph() {
        const canvas = $('funscriptGraph');
        if (!(canvas instanceof HTMLCanvasElement)) return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        const dpr = window.devicePixelRatio || 1;
        const cssW = canvas.clientWidth || 640;
        const cssH = canvas.clientHeight || 140;
        canvas.width = Math.round(cssW * dpr);
        canvas.height = Math.round(cssH * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, cssW, cssH);
      }

      function clearFunscriptOverviewGraph() {
        const canvas = $('funscriptOverviewGraph');
        if (!(canvas instanceof HTMLCanvasElement)) return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        const dpr = window.devicePixelRatio || 1;
        const cssW = canvas.clientWidth || 640;
        const cssH = canvas.clientHeight || 90;
        canvas.width = Math.round(cssW * dpr);
        canvas.height = Math.round(cssH * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, cssW, cssH);
      }

      function getCurrentDurationMsForOverview() {
        // Prefer actual video duration when available; otherwise fall back to probed duration.
        const v = $('video');
        if (!state.noVideo && v instanceof HTMLVideoElement) {
          const d = Number(v.duration);
          if (Number.isFinite(d) && d > 0) return Math.round(d * 1000);
        }
        const ms = Number(state.durationMs);
        return Number.isFinite(ms) && ms > 0 ? Math.round(ms) : null;
      }

      function drawFunscriptOverviewGraph(actions, ms, derivatives) {
        const canvas = $('funscriptOverviewGraph');
        if (!(canvas instanceof HTMLCanvasElement)) return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        // Light throttle; playhead moves, but we don't need 60fps.
        const now = Date.now();
        if (!state._lastFsOverviewDrawAt) state._lastFsOverviewDrawAt = 0;
        if (now - state._lastFsOverviewDrawAt < 120) return;
        state._lastFsOverviewDrawAt = now;

        const dpr = window.devicePixelRatio || 1;
        const cssW = canvas.clientWidth || 640;
        const cssH = canvas.clientHeight || 90;
        canvas.width = Math.round(cssW * dpr);
        canvas.height = Math.round(cssH * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        const padL = 10, padR = 10, padT = 8, padB = 10;
        const w = cssW - padL - padR;
        const h = cssH - padT - padB;

        const maxAt = Math.max(0, Math.round(Number(actions[actions.length - 1]?.at) || 0));
        const dur = getCurrentDurationMsForOverview();
        const xMax = Math.max(1, dur != null ? dur : 0, maxAt);
        const xMin = 0;

        const xToPx = (t) => padL + ((t - xMin) / (xMax - xMin)) * w;
        const yToPx = (p) => padT + (1 - p / 100) * h;

        // Cache the expensive curve rendering to an offscreen canvas.
        const cacheKey = [
          Math.round(cssW),
          Math.round(cssH),
          Math.round(dpr * 100),
          xMax,
          actions.length,
          maxAt,
          String(state.interpolationMode || 'spline'),
          state.halfScript ? 'half' : 'full',
        ].join('|');

        if (!state._fsOverviewCache || state._fsOverviewCache.key !== cacheKey) {
          const off = document.createElement('canvas');
          off.width = Math.round(cssW * dpr);
          off.height = Math.round(cssH * dpr);
          const octx = off.getContext('2d');
          if (!octx) return;
          octx.setTransform(dpr, 0, 0, dpr, 0, 0);

          // Background
          octx.clearRect(0, 0, cssW, cssH);
          octx.fillStyle = '#0f1117';
          octx.fillRect(0, 0, cssW, cssH);

          // Grid
          octx.strokeStyle = 'rgba(255,255,255,0.05)';
          octx.lineWidth = 1;
          octx.setLineDash([3, 6]);
          for (let i = 1; i < 4; i++) {
            const yy = padT + (h * i) / 4;
            octx.beginPath();
            octx.moveTo(padL, yy);
            octx.lineTo(padL + w, yy);
            octx.stroke();
          }
          octx.setLineDash([]);

          // Curve stroke uses the same palette as the UI meter.
          const grad = octx.createLinearGradient(padL, 0, padL + w, 0);
          grad.addColorStop(0, '#5b8cff');
          grad.addColorStop(1, '#2cd3a7');

          const sampleCount = Math.max(240, Math.min(1400, Math.round(cssW * 2)));
          let pointer = -1;

          // Area fill (subtle)
          octx.beginPath();
          for (let i = 0; i <= sampleCount; i++) {
            const t = xMin + ((xMax - xMin) * i) / sampleCount;
            const r = interpolatePos(actions, t, pointer, state.interpolationMode, derivatives);
            pointer = r.idx;
            const pos = clamp(Number(r.pos) || 0, 0, 100);
            const px = xToPx(t);
            const py = yToPx(pos);
            if (i === 0) octx.moveTo(px, py);
            else octx.lineTo(px, py);
          }
          octx.lineTo(padL + w, padT + h);
          octx.lineTo(padL, padT + h);
          octx.closePath();
          const fillGrad = octx.createLinearGradient(0, padT, 0, padT + h);
          fillGrad.addColorStop(0, 'rgba(91,140,255,0.16)');
          fillGrad.addColorStop(1, 'rgba(44,211,167,0.06)');
          octx.fillStyle = fillGrad;
          octx.fill();

          // Stroke
          pointer = -1;
          octx.beginPath();
          for (let i = 0; i <= sampleCount; i++) {
            const t = xMin + ((xMax - xMin) * i) / sampleCount;
            const r = interpolatePos(actions, t, pointer, state.interpolationMode, derivatives);
            pointer = r.idx;
            const pos = clamp(Number(r.pos) || 0, 0, 100);
            const px = xToPx(t);
            const py = yToPx(pos);
            if (i === 0) octx.moveTo(px, py);
            else octx.lineTo(px, py);
          }
          octx.strokeStyle = grad;
          octx.lineWidth = 1.75;
          octx.stroke();

          state._fsOverviewCache = { key: cacheKey, canvas: off };
        }

        // Blit cached base
        ctx.clearRect(0, 0, cssW, cssH);
        if (state._fsOverviewCache?.canvas) {
          ctx.drawImage(state._fsOverviewCache.canvas, 0, 0, cssW, cssH);
        }

        // Playhead
        const clampedMs = Math.max(0, Math.min(xMax, Number(ms) || 0));
        const cx = xToPx(clampedMs);
        ctx.strokeStyle = 'rgba(255,255,255,0.55)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cx, padT);
        ctx.lineTo(cx, padT + h);
        ctx.stroke();

        // Position dot
        const r = interpolatePos(actions, clampedMs, state.funscriptPointer, state.interpolationMode, derivatives);
        const pos = clamp(Number(r.pos) || 0, 0, 100);
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.arc(cx, yToPx(pos), 2.8, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawFunscriptGraph(actions, ms, derivatives) {
        const canvas = $('funscriptGraph');
        if (!(canvas instanceof HTMLCanvasElement)) return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        // Throttle redraw
        const now = Date.now();
        if (!state._lastFsGraphDrawAt) state._lastFsGraphDrawAt = 0;
        if (now - state._lastFsGraphDrawAt < 80) return;
        state._lastFsGraphDrawAt = now;

        const dpr = window.devicePixelRatio || 1;
        const cssW = canvas.clientWidth || 640;
        const cssH = canvas.clientHeight || 140;
        canvas.width = Math.round(cssW * dpr);
        canvas.height = Math.round(cssH * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        ctx.clearRect(0, 0, cssW, cssH);

        // Background
        ctx.fillStyle = '#0f1117';
        ctx.fillRect(0, 0, cssW, cssH);

        // Grid
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 1;
        for (let i = 1; i < 5; i++) {
          const y = (cssH * i) / 5;
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(cssW, y);
          ctx.stroke();
        }

        const windowMs = 10_000;
        const half = windowMs / 2;
        const maxAt = Number(actions[actions.length - 1]?.at) || 0;
        const xMin = Math.max(0, ms - half);
        const xMax = Math.max(xMin + 1, Math.min(maxAt, ms + half));

        const pad = 8;
        const w = cssW - pad * 2;
        const h = cssH - pad * 2;
        const xToPx = (t) => pad + ((t - xMin) / (xMax - xMin)) * w;
        const yToPx = (p) => pad + (1 - p / 100) * h;

        // Sample curve
        const sampleCount = 160;
        let pointer = 0;
        let prev = null;

        for (let i = 0; i <= sampleCount; i++) {
          const t = xMin + ((xMax - xMin) * i) / sampleCount;
          const r = interpolatePos(actions, t, pointer, state.interpolationMode, derivatives);
          pointer = r.idx;
          const pos = clamp(Number(r.pos) || 0, 0, 100);
          const pt = { t, pos, x: xToPx(t), y: yToPx(pos) };
          if (prev) {
            const dt = Math.max(1, pt.t - prev.t);
            const v = Math.abs(pt.pos - prev.pos) / dt; // pos per ms
            const vNorm = Math.min(1, v * 300); // heuristic
            const hue = Math.round(200 - 200 * vNorm); // slow=blue-ish, fast=red
            ctx.strokeStyle = `hsl(${hue}, 90%, 60%)`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(prev.x, prev.y);
            ctx.lineTo(pt.x, pt.y);
            ctx.stroke();
          }
          prev = pt;
        }

        // Current time marker
        const cx = xToPx(Math.max(xMin, Math.min(xMax, ms)));
        ctx.strokeStyle = 'rgba(255,255,255,0.45)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cx, pad);
        ctx.lineTo(cx, pad + h);
        ctx.stroke();

        // Current position marker
        const itp = interpolatePos(actions, ms, state.funscriptPointer, state.interpolationMode, derivatives);
        const curPos = clamp(Number(itp.pos) || 0, 0, 100);
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.arc(cx, yToPx(curPos), 3.5, 0, Math.PI * 2);
        ctx.fill();
      }

      function updateFunscriptUi(timeMs) {
        if (!funscriptStatusEl || !funscriptMeterEl || !funscriptLabelEl) return;

        // (Graph drawing is handled by clearFunscriptGraph/drawFunscriptGraph)

        const actions = getActiveFunscriptActions();
        const deriv = getActiveFunscriptDerivatives();
        if (!actions || !Array.isArray(actions) || actions.length === 0) {
          funscriptStatusEl.textContent = 'Funscript: not loaded';
          funscriptMeterEl.style.transform = 'scaleX(0)';
          const axis = String(state.axis || 'L0').toUpperCase();
          funscriptLabelEl.textContent = `${axis}: 0% (000)`;
          state.funscriptPointer = -1;
          state.lastFunscriptValue = 0;
          clearFunscriptGraph();
          clearFunscriptOverviewGraph();
          return;
        }

        const driveStatus = state.drive ? 'Drive: ON' : 'Drive: OFF';
        const stats = getActiveFunscriptStats();
        const spTxt = (stats && Number.isFinite(stats.avgSpeed) && stats.avgSpeed >= 0)
          ? ` · ${stats.avgSpeed.toFixed(stats.avgSpeed >= 10 ? 0 : 1)}%/s`
          : '';
        funscriptStatusEl.textContent = `Funscript: loaded (${actions.length} actions${spTxt}) - ${driveStatus}`;

        const ms = Number.isFinite(timeMs) ? Math.max(0, timeMs) : 0;
        const scriptMs = funscriptTimeMsForPlaybackTimeMs(ms);
        const itp = interpolatePos(actions, scriptMs, state.funscriptPointer, state.interpolationMode, deriv);
        state.funscriptPointer = itp.idx;
        let pos = itp.pos;
        if (!Number.isFinite(pos)) pos = 0;

        state.lastFunscriptValue = pos;
        const pct = Math.max(0, Math.min(100, pos));
        funscriptMeterEl.style.transform = `scaleX(${pct / 100})`;
        const tcodeVal = String(Math.round((pct / 100) * 999)).padStart(3, '0');
        const axis = String(state.axis || 'L0').toUpperCase();
        funscriptLabelEl.textContent = `${axis}: ${Math.round(pct)}% (${tcodeVal})`;

        drawFunscriptGraph(actions, scriptMs, deriv);
        drawFunscriptOverviewGraph(actions, scriptMs, deriv);
      }

      function formatTime(ms) {
        if (!Number.isFinite(ms) || ms < 0) return '--:--';
        const totalSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        const mm = String(minutes).padStart(2, '0');
        const ss = String(seconds).padStart(2, '0');
        if (hours > 0) {
          return `${hours}:${mm}:${ss}`;
        }
        return `${minutes}:${ss}`;
      }

      async function tick() {
        const v = $('video');
        const fps = state.noVideo ? (state.remoteFps || 30) : 30;

        let timeMs = 0;
        let paused = true;

        if (!state.noVideo && v instanceof HTMLVideoElement) {
          timeMs = Math.round((v.currentTime || 0) * 1000);
          paused = Boolean(v.paused);
        } else if (state.noVideo) {
          const r = state.followRemote ? getNoVideoTimeMsAndPaused() : getLocalNoVideoTimeMsAndPaused();
          timeMs = r.timeMs;
          paused = r.paused;
        }

        const frame = currentFrame(timeMs / 1000, fps);

        // Update Play/Pause button label based on current state.
        const btnPlayPause = $('btnPlayPause');
        if (btnPlayPause) {
          btnPlayPause.textContent = paused ? 'Play' : 'Pause';
        }

        // Update progress bar and time display.
        const progress = $('progress');
        let durationMs = state.durationMs;
        if (!state.noVideo && v instanceof HTMLVideoElement) {
          const d = Number(v.duration);
          if (Number.isFinite(d) && d > 0) durationMs = Math.round(d * 1000);
        }

        if (progress instanceof HTMLInputElement) {
          if (durationMs && durationMs > 0) {
            progress.max = String(durationMs);
            progress.value = String(Math.max(0, Math.min(durationMs, timeMs)));
            progress.disabled = false;
          } else {
            // Unknown duration yet; keep a stable bar until ffprobe/video metadata arrives.
            progress.max = '1';
            progress.value = '0';
            progress.disabled = true;
          }
        }

        if (progressTimeEl) {
          progressTimeEl.textContent = `${formatTime(timeMs)} / ${formatTime(durationMs)}`;
        }

        updateFunscriptUi(timeMs);

        const currentId = state.current && state.current.id ? String(state.current.id) : '';
        const canReport = Boolean(currentId) && (!state.noVideo ? (v instanceof HTMLVideoElement && Number.isFinite(v.currentTime)) : true);

        if (canReport) {
          $('playback').textContent = `t=${timeMs}ms frame=${frame} fps=${fps}`;
          // Persist playback state only when playing the stream locally.
          if (!state.noVideo) {
            if (Date.now() - state.lastPlaybackPutAt > 1000) {
              state.lastPlaybackPutAt = Date.now();
              try {
                await apiJson('/api/playback', {
                  method: 'PUT',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    clientId: state.clientId,
                    mediaId: currentId,
                    timeMs,
                    fps,
                    frame
                  })
                });
              } catch {}
            }
          }

          // state.current can be cleared (e.g., server restart / follow-source disconnect)
          // while we're awaiting the playback PUT above.
          if (!state.current || String(state.current.id || '') !== currentId) {
            window.requestAnimationFrame(tick);
            return;
          }

          // Publish sync state only when we're the "driver".
          // If followRemote is ON, we shouldn't send updates.
          // Throttle automatic updates to prevent feedback loops.
          if (!state.followRemote) {
            if (Date.now() >= state.applyingRemoteUntil) {
              sendSyncUpdate({ mediaId: currentId, timeMs, paused, fps, frame }, false, getControlTargetClientId());
            }
          }
        }

        window.requestAnimationFrame(tick);
      }

      async function listPorts() {
        try {
          if (!window.mv || typeof window.mv.listSerialPorts !== 'function') {
            logToConsole('error', 'Serial API not available - preload script may not have loaded correctly');
            const sel = $('port');
            sel.innerHTML = '<option value="">Serial API not available</option>';
            return;
          }
          logToConsole('log', 'Listing serial ports...');
          const ports = await window.mv.listSerialPorts();
          logToConsole('log', `Found ${ports.length} serial port(s):`, ports.map(p => p.path).join(', ') || 'none');
          const sel = $('port');
          if (ports.length === 0) {
            sel.innerHTML = '<option value="">No serial ports found</option>';
          } else {
            sel.innerHTML = ports.map((p) => `<option value='${esc(p.path)}'>${esc(p.path)}</option>`).join('');
          }
        } catch (err) {
          const errMsg = err instanceof Error ? err.message : String(err);
          logToConsole('error', 'Failed to list serial ports:', errMsg);
          const sel = $('port');
          sel.innerHTML = '<option value="">Error loading ports</option>';
        }
      }

      $('serverUrl').addEventListener('change', (e) => {
        state.serverUrl = e.target.value;
        void allowSelfSignedForServer(state.serverUrl);
      });
      $('applyServer').addEventListener('click', async () => {
        state.serverUrl = $('serverUrl').value.trim() || state.serverUrl;
        await allowSelfSignedForServer(state.serverUrl);
        savePrefs();
        requestWsConnect();
        state.page = 1;
        await refresh();
      });

      $('funscriptFilter').addEventListener('change', (e) => {
        const v = String(e.target.value || 'any');
        state.funscriptFilter = (v === '1' || v === '0' || v === 'any') ? v : 'any';
        savePrefs();
        state.page = 1;
        refresh();
      });

      $('vrFilter').addEventListener('change', (e) => {
        const v = String(e.target.value || 'any');
        state.vrFilter = (v === '1' || v === '0' || v === 'any') ? v : 'any';
        savePrefs();
        state.page = 1;
        refresh();
      });

      $('q').addEventListener('input', (e) => {
        state.q = e.target.value;
        state.page = 1;
        window.clearTimeout(window.__qt);
        window.__qt = window.setTimeout(() => refresh(), 200);
      });

      $('refresh').addEventListener('click', () => refresh());
      $('prev').addEventListener('click', async () => { state.page = Math.max(1, state.page - 1); await refresh(); });
      $('next').addEventListener('click', async () => {
        const maxPage = Math.max(1, Math.ceil(state.total / state.pageSize));
        state.page = Math.min(maxPage, state.page + 1);
        await refresh();
      });

      $('ports').addEventListener('click', () => listPorts());
      $('connect').addEventListener('click', async () => {
        await serialConnectFromUi();
      });
      $('disconnect').addEventListener('click', async () => {
        await serialDisconnectFromUi();
      });

      $('autoConnectSerial').addEventListener('change', () => {
        state.autoConnectSerial = $('autoConnectSerial').checked;
        savePrefs();
      });

      function setAxis(val) {
        ensureAxisStateDefaults();
        const raw = normalizeAxisCode(val || 'L0');
        state.axis = LEGACY_AXIS_MAP[raw] || raw;

        // If the selected axis is a known catalog axis, enforce enabled selection.
        coerceSelectedAxisToEnabled();

        savePrefs();
        renderAxisSelectOptions();
        updateAxisQuickUi();
      }

      function computeAxisPositionFromQuickPct(axis, pct) {
        const clampedPct = clamp(Number(pct) || 0, 0, 100);
        const limits = state.axisLimits[axis] || { min: 0, max: 100 };
        const range = (limits.max - limits.min);
        let pos = limits.min + (clampedPct / 100) * range;
        pos = clamp(pos, 0, 100);
        return { clampedPct, pos };
      }

      function updateAxisQuickUi() {
        const axis = String(state.axis || 'L0').toUpperCase();
        const pct = clamp(Number(state.axisQuickPct) || 0, 0, 100);
        const r = computeAxisPositionFromQuickPct(axis, pct);
        const tcodeVal = String(Math.round((r.pos / 100) * 999)).padStart(3, '0');

        try {
          $('axisPosLabel').textContent = `${Math.round(r.clampedPct)}% (${tcodeVal})`;
          $('axisPosSlider').value = String(Math.round(pct));
        } catch {}

        const enabled = Boolean(state.serialConnected);
        try { $('axisPosSlider').disabled = !enabled; } catch {}
        try { $('btnAxis0').disabled = !enabled; } catch {}
        try { $('btnAxis50').disabled = !enabled; } catch {}
        try { $('btnAxis100').disabled = !enabled; } catch {}
      }

      function scheduleAxisQuickSend(pct) {
        state.axisQuickPct = clamp(Number(pct) || 0, 0, 100);
        savePrefs();
        updateAxisQuickUi();

        if (state.axisQuickSendTimer) {
          clearTimeout(state.axisQuickSendTimer);
          state.axisQuickSendTimer = null;
        }

        state.axisQuickSendTimer = setTimeout(() => {
          state.axisQuickSendTimer = null;
          sendAxisQuickPosition(state.axisQuickPct);
        }, 60);
      }

      async function sendAxisQuickPosition(pct) {
        cancelAutoHome();

        if (!state.serialConnected) {
          logToConsole('warn', 'Serial not connected');
          return;
        }
        if (!window.mv) {
          logToConsole('error', 'Serial API not available');
          return;
        }

        ensureAxisStateDefaults();
        const axis = normalizeAxisCode(state.axis || 'L0');
        if (isCatalogAxis(axis) && !state.axisEnabled[axis]) {
          logToConsole('warn', `Axis ${axis} is disabled`);
          return;
        }
        const clampedPct = clamp(Number(pct) || 0, 0, 100);

        const { pos } = computeAxisPositionFromQuickPct(axis, clampedPct);

        const scaled = Math.round((pos / 100) * 999);
        const vvv = String(scaled).padStart(3, '0');
        const line = `${axis}${vvv}`;

        try {
          await window.mv.tcodeSend(line);
          state.lastTcodeSentAt = Date.now();
          state.lastTcodeSentPos = pos;
          logToConsole('log', `Axis quick set: ${line}`);
        } catch (err) {
          logToConsole('error', 'Axis quick set failed:', err);
        }
      }

      $('axisSelect').addEventListener('change', () => {
        const sel = $('axisSelect').value;
        if (sel === 'CUSTOM') {
          $('axisCustom').style.display = '';
          $('axisCustom').focus();
          setAxis($('axisCustom').value);
        } else {
          $('axisCustom').style.display = 'none';
          $('axisCustom').value = sel;
          setAxis(sel);
        }
      });

      $('axisCustom').addEventListener('input', () => setAxis($('axisCustom').value));

      $('btnAxis0').addEventListener('click', () => { scheduleAxisQuickSend(0); });
      $('btnAxis50').addEventListener('click', () => { scheduleAxisQuickSend(50); });
      $('btnAxis100').addEventListener('click', () => { scheduleAxisQuickSend(100); });

      $('axisPosSlider').addEventListener('input', (e) => {
        scheduleAxisQuickSend(e.target.value);
      });

      $('axisPosSlider').addEventListener('change', (e) => {
        if (state.axisQuickSendTimer) {
          clearTimeout(state.axisQuickSendTimer);
          state.axisQuickSendTimer = null;
        }
        const pct = clamp(Number(e.target.value) || 0, 0, 100);
        state.axisQuickPct = pct;
        savePrefs();
        updateAxisQuickUi();
        sendAxisQuickPosition(pct);
      });

      $('toggleDrive').addEventListener('click', () => {
        toggleDriveFromUi();
      });

      $('autoHomeEnabled').addEventListener('change', () => {
        state.autoHomeEnabled = $('autoHomeEnabled').checked;
        savePrefs();
        if (!state.autoHomeEnabled) cancelAutoHome();
      });

      $('btnToggleAutoHomeSettings').addEventListener('click', () => {
        const el = $('autoHomeSettings');
        const isHidden = el.style.display === 'none';
        el.style.display = isHidden ? '' : 'none';
        $('btnToggleAutoHomeSettings').textContent = isHidden ? 'Hide' : 'Show';
      });

      $('autoHomePosition').addEventListener('input', () => {
        state.autoHomePosition = Number($('autoHomePosition').value) || 0;
        savePrefs();

        // If paused and auto-home is enabled, apply the new home position immediately.
        let paused = true;
        const v = $('video');
        if (!state.noVideo && v instanceof HTMLVideoElement) paused = Boolean(v.paused);
        else if (state.noVideo && state.followRemote) paused = Boolean(state.remotePaused);

        if (paused && state.autoHomeEnabled) {
          runAutoHomeNow();
        }
      });

      $('autoHomeDelay').addEventListener('input', () => {
        state.autoHomeDelay = Number($('autoHomeDelay').value) || 0;
        savePrefs();
      });

      $('autoHomeTransition').addEventListener('input', () => {
        state.autoHomeTransition = Number($('autoHomeTransition').value) || 1000;
        savePrefs();
      });

      $('serialResumeDelay').addEventListener('input', () => {
        state.serialResumeDelayMs = Number($('serialResumeDelay').value) || 0;
        savePrefs();
      });

      // Settings modal
      $('btnSettings').addEventListener('click', () => {
        // Update UI from state
        $('invertScriptCheck').checked = state.invertScript;
        $('halfScriptCheck').checked = state.halfScript;
        $('smoothResumeCheck').checked = state.smoothResumeFunscript;
        const schedInput = $('scheduledPlaySpecInput');
        if (schedInput) schedInput.value = String(state.scheduledPlaySpec ?? '');
        $('scriptDelayInput').value = state.scriptDelay;
        const interpSel = $('interpModeSelect');
        if (interpSel) interpSel.value = state.interpolationMode || 'spline';

        renderAxisSettingsUi();
        
        $('settingsModal').style.display = '';
        drawInterpolationExample();
      });

      $('btnCloseSettings').addEventListener('click', () => {
        $('settingsModal').style.display = 'none';
      });

      $('btnResetSettings').addEventListener('click', () => {
        state.invertScript = false;
        state.halfScript = false;
        state.smoothResumeFunscript = false;
        state.scheduledPlaySpec = '0.4';
        state.scriptDelay = 0;
        state.interpolationMode = 'spline';

        state.axisEnabled = Object.fromEntries(allAxisCodes().map(c => [c, true]));
        state.axisLimits = Object.fromEntries(allAxisCodes().map(c => [c, { min: 0, max: 100 }]));
        ensureAxisStateDefaults();
        coerceSelectedAxisToEnabled();
        savePrefs();

        recomputeHalfScriptTransform();
        state.funIndex = -1;
        state.funscriptPointer = -1;
        state._fsOverviewCache = null;
        
        // Update UI
        $('invertScriptCheck').checked = false;
        $('halfScriptCheck').checked = false;
        $('smoothResumeCheck').checked = false;
        const schedInput = $('scheduledPlaySpecInput');
        if (schedInput) schedInput.value = String(state.scheduledPlaySpec ?? '');
        $('scriptDelayInput').value = 0;
        const interpSel = $('interpModeSelect');
        if (interpSel) interpSel.value = 'spline';

        renderAxisSettingsUi();
        renderAxisSelectOptions();
        updateAxisQuickUi();

        drawInterpolationExample();
      });

      $('invertScriptCheck').addEventListener('change', () => {
        state.invertScript = $('invertScriptCheck').checked;
        savePrefs();
      });

      $('halfScriptCheck').addEventListener('change', () => {
        state.halfScript = $('halfScriptCheck').checked;
        recomputeHalfScriptTransform();
        state.funIndex = -1;
        state.funscriptPointer = -1;
        state._fsOverviewCache = null;
        setFsPill();
        savePrefs();
      });

      $('smoothResumeCheck').addEventListener('change', () => {
        state.smoothResumeFunscript = $('smoothResumeCheck').checked;
        savePrefs();
      });

      const scheduledPlaySpecInput = $('scheduledPlaySpecInput');
      if (scheduledPlaySpecInput) {
        scheduledPlaySpecInput.addEventListener('input', () => {
          state.scheduledPlaySpec = String(scheduledPlaySpecInput.value || '').trim();
          savePrefs();
        });
      }

      $('scriptDelayInput').addEventListener('input', () => {
        state.scriptDelay = Number($('scriptDelayInput').value) || 0;
        savePrefs();
      });

      const interpModeSelect = $('interpModeSelect');
      if (interpModeSelect) {
        interpModeSelect.addEventListener('change', () => {
          state.interpolationMode = String(interpModeSelect.value || 'spline');
          savePrefs();
          drawInterpolationExample();
        });
      }

      // Axis enabled/limits UI is rendered dynamically when the settings modal opens.

      $('btnPlayPause').addEventListener('click', async () => {
        const v = $('video');
        if (!(v instanceof HTMLVideoElement)) return;

        if (state.noVideo) {
          if (!state.current) return;

          const now = Date.now();
          const r = getLocalNoVideoTimeMsAndPaused();
          const timeMs = Math.max(0, Math.round(r.timeMs || 0));
          const fps = 30;
          const frame = currentFrame(timeMs / 1000, fps);

          if (state.noVideoPaused) {
            const clockOffset = typeof state.serverClockOffsetMs === 'number' && Number.isFinite(state.serverClockOffsetMs)
              ? state.serverClockOffsetMs
              : 0;
            const sched = parseScheduledPlaySpec(state.scheduledPlaySpec, clockOffset);

            if (sched) {
              sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: false, fps, frame, playAt: sched.playAt, playAtLocalMs: sched.playAtLocalMs }, true, getControlTargetClientId());
              state.noVideoBaseTimeMs = timeMs;
              state.noVideoPaused = true;
              state.noVideoAnchorAtMs = now;
              state.noVideoScheduledPlayAtLocalMs = sched.playAtLocalMs;
              cancelAutoHome();
              return;
            }

            sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: false, fps, frame }, true, getControlTargetClientId());
            state.noVideoBaseTimeMs = timeMs;
            state.noVideoAnchorAtMs = now;
            state.noVideoPaused = false;
            state.noVideoScheduledPlayAtLocalMs = 0;
            cancelAutoHome();
            return;
          }

          // Pausing
          state.noVideoBaseTimeMs = timeMs;
          state.noVideoPaused = true;
          state.noVideoScheduledPlayAtLocalMs = 0;
          triggerAutoHome();
          sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: true, fps, frame, playAt: null }, true, getControlTargetClientId());
          return;
        }

        if (v.paused) {
          const clockOffset = typeof state.serverClockOffsetMs === 'number' && Number.isFinite(state.serverClockOffsetMs)
            ? state.serverClockOffsetMs
            : 0;
          const sched = parseScheduledPlaySpec(state.scheduledPlaySpec, clockOffset);

          if (state.current) {
            const fps = 30;
            const timeMs = Math.round((v.currentTime || 0) * 1000);
            const frame = currentFrame(v.currentTime || 0, fps);
            if (sched) {
              sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: false, fps, frame, playAt: sched.playAt, playAtLocalMs: sched.playAtLocalMs }, true, getControlTargetClientId());
            } else {
              sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: false, fps, frame }, true, getControlTargetClientId());
            }
          }

          cancelAutoHome();
          if (sched) {
            try { v.pause(); } catch {}
            scheduleLocalPlayAt(v, sched.playAtLocalMs);
            return;
          }

          try { await v.play(); } catch {}
          return;
        } else {
          try { v.pause(); } catch {}
          triggerAutoHome(); // Trigger auto-home when pausing
        }
        // Sync the play/pause state to web UI
        if (state.current) {
          const fps = 30;
          const timeMs = Math.round((v.currentTime || 0) * 1000);
          const frame = currentFrame(v.currentTime || 0, fps);
          sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: v.paused, fps, frame, playAt: v.paused ? null : undefined }, true, getControlTargetClientId());
        }
      });

      $('mediaMode').addEventListener('change', () => {
        const sel = $('mediaMode');
        if (!(sel instanceof HTMLSelectElement)) return;

        const prevNoVideo = Boolean(state.noVideo);
        const prevAudioOnly = Boolean(state.audioOnly);
        const prevMode = prevNoVideo ? 'none' : (prevAudioOnly ? 'audio' : 'video');

        const nextMode = String(sel.value || 'video');
        state.noVideo = nextMode === 'none';
        state.audioOnly = nextMode === 'audio';
        savePrefs();
        setVideoModeUi();
        applyDefaultMuteForSync();

        // Preserve playback state as much as possible when enabling/disabling the stream.
        const v = $('video');
        if (!(v instanceof HTMLVideoElement)) return;

        if (prevMode === 'none' && nextMode !== 'none') {
          // Turning media playback ON (from no-media)
          if (state.current?.id) {
            const wasPaused = state.followRemote ? (state.remotePaused ?? true) : Boolean(state.noVideoPaused);
            const seekToMs = state.followRemote
              ? (Number(state.remoteTimeMs) || 0)
              : (Number(getLocalNoVideoTimeMsAndPaused().timeMs) || 0);

            v.src = new URL(`/api/media/${state.current.id}/stream`, state.serverUrl).toString();
            applyDefaultMuteForSync();
            try { v.currentTime = seekToMs > 0 ? (seekToMs / 1000) : 0; } catch {}
            if (!wasPaused) {
              v.play().catch(() => {});
            }
          }
          return;
        }

        if (prevMode !== 'none' && nextMode === 'none') {
          // Turning media playback OFF (to no-media)
          const timeMs = Math.round((v.currentTime || 0) * 1000);
          const d = Number(v.duration);
          if (Number.isFinite(d) && d > 0) {
            state.durationMs = Math.round(d * 1000);
          }
          try {
            v.pause();
            v.removeAttribute('src');
            v.load();
          } catch {}

          // Seed local no-video clock from the last known playback position.
          state.noVideoBaseTimeMs = Math.max(0, timeMs);
          state.noVideoAnchorAtMs = Date.now();
          state.noVideoPaused = true;
          state.noVideoScheduledPlayAtLocalMs = 0;
          return;
        }

        // Switching between video/audio-only only shows/hides the element.
      });

      $('btnFollow').addEventListener('click', () => {
        if (!state.followSource) {
          // Only togglable when Sync Source is not None.
          updateFollowButtonUi();
          return;
        }
        state.followRemote = !state.followRemote;
        updateFollowButtonUi();
        savePrefs();

        if (state.followRemote) {
          applyDefaultMuteForSync();
        }

        updateHereSphereFollowLockUi();

        // If we just became the driver, immediately publish our current state.
        if (!state.followRemote) {
          const v = $('video');
          if (!state.current) return;
          const fps = 30;
          if (state.noVideo) {
            const r = getLocalNoVideoTimeMsAndPaused();
            const timeMs = Math.max(0, Math.round(r.timeMs || 0));
            const frame = currentFrame(timeMs / 1000, fps);
            sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: Boolean(r.paused), fps, frame }, false, getControlTargetClientId());
            return;
          }
          if (v instanceof HTMLVideoElement) {
            const timeMs = Math.round((v.currentTime || 0) * 1000);
            const frame = currentFrame(v.currentTime || 0, fps);
            sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: v.paused, fps, frame }, false, getControlTargetClientId());
          }
        }
      });

      $('followSource').addEventListener('change', () => {
        const val = String($('followSource').value || '');
        state.followSource = val;

        // Requirement: follow can only be enabled when a source is selected.
        // Default behavior: selecting a source turns follow ON; selecting None forces follow OFF.
        state.followRemote = Boolean(val);
        updateFollowButtonUi();
        savePrefs();

        if (state.followRemote) {
          applyDefaultMuteForSync();
        }

        updateHereSphereFollowLockUi();

        // Auto-connect DeoVR remote control when its source is selected.
        updateDeoVrRemoteControlConnection();

        // If changed to None, stop following and unload local playback.
        if (!val) {
          unloadCurrentMedia('Sync source set to None - unloading');
          return;
        }

        // If changed to a specific source, and that source is currently on homepage/grid,
        // unload immediately to mirror the WebUI's state.
        const meta = state.clientsMetadata.get(val);
        const uiView = meta && typeof meta.uiView === 'string' ? meta.uiView : '';
        const isPlayerView = uiView === 'player' || uiView === 'vr';
        if (uiView && !isPlayerView) {
          unloadCurrentMedia(`Sync source changed to ${val} - source is in ${uiView} view - unloading`);
          return;
        }

        // If changed to a specific source, check if we have cached state.
        const cached = state.sourceStates.get(val);
        if (cached) {
           logToConsole('log', `Sync source changed to ${val} - applying cached state`);
          applyRemoteSyncState(cached);
        } else {
             logToConsole('log', `Sync source changed to ${val} - waiting for next update`);
        }
      });

      // DeoVR remote control event wiring (status pushes back into shared sync)
      try {
        if (window.mv && typeof window.mv.deoVrOnStatus === 'function') {
          window.mv.deoVrOnStatus((s) => {
            const sourceId = String(state._deoVrSourceId || '').trim();
            if (!sourceId) return;

            // If desktop is driving DeoVR, ignore echoed status for a moment.
            if (Date.now() < (Number(state._deoVrSuppressIncomingUntil) || 0)) return;

            const mediaId = tryParseMediaIdFromDeoVrPath(s && s.path);
            if (!mediaId) return;
            const currentTime = typeof s.currentTime === 'number' && Number.isFinite(s.currentTime) ? s.currentTime : 0;
            const paused = Number(s.playerState) === 1;
            const fps = 30;
            const timeMs = Math.max(0, Math.round(currentTime * 1000));
            const frame = currentFrame(currentTime, fps);
            // Force so DeoVR remains authoritative even while desktop is applying remote.
            sendSyncUpdateAs(sourceId, { mediaId, timeMs, paused, fps, frame }, true);
          });
        }

        if (window.mv && typeof window.mv.deoVrOnConnection === 'function') {
          window.mv.deoVrOnConnection((e) => {
            const type = e && e.type ? String(e.type) : '';
            if (type === 'connected') {
              logToConsole('log', `DeoVR remote: connected (${e.host || ''})`);
              state._deoVrReconnectAt = 0;
              state._deoVrReconnectDelayMs = 1000;
              return;
            }

            if (type === 'error') {
              logToConsole('error', `DeoVR remote: error (${e.error || 'unknown'})`);
            }

            if (type === 'disconnected' || type === 'error') {
              // Auto-reconnect while a DeoVR source is still selected.
              const desiredSourceId = String(state.followSource || '').trim();
              const desiredHost = parseDeoVrHostFromSourceId(desiredSourceId);
              if (!desiredHost) return;
              const now = Date.now();
              if (now < (Number(state._deoVrReconnectAt) || 0)) return;
              const delay = Math.min(15_000, Math.max(1000, Number(state._deoVrReconnectDelayMs) || 1000));
              state._deoVrReconnectAt = now + delay;
              state._deoVrReconnectDelayMs = Math.min(15_000, delay * 1.5);
              window.setTimeout(() => {
                // If selection changed meanwhile, do nothing.
                if (String(state.followSource || '').trim() !== desiredSourceId) return;
                updateDeoVrRemoteControlConnection();
              }, delay);
            }
          });
        }
      } catch {}

      loadPrefs();
      $('serverUrl').value = state.serverUrl;
      await allowSelfSignedForServer(state.serverUrl);

      try { $('funscriptFilter').value = state.funscriptFilter || 'any'; } catch {}
      try { $('vrFilter').value = state.vrFilter || 'any'; } catch {}

      // Apply initial control lock state (e.g., if prefs selected HereSphere + Sync ON).
      updateHereSphereFollowLockUi();

      // If prefs already selected DeoVR as sync source, connect now.
      updateDeoVrRemoteControlConnection();

      try {
        if (window.mv && typeof window.mv.setKeepAwake === 'function') {
          window.mv.setKeepAwake(state.drive);
        }
      } catch {}

      // Init axis dropdown
      ensureAxisStateDefaults();
      coerceSelectedAxisToEnabled();
      renderAxisSelectOptions();

      // Init axis quick controls
      updateAxisQuickUi();

      $('toggleDrive').textContent = state.drive ? 'Drive: ON' : 'Drive: OFF';
      // Enforce follow/sync invariants on startup.
      state.followRemote = Boolean(state.followSource);
      updateFollowButtonUi();

      // Auto-home UI initialization
      $('autoHomeEnabled').checked = state.autoHomeEnabled;
      $('autoHomePosition').value = state.autoHomePosition;
      $('autoHomeDelay').value = state.autoHomeDelay;
      $('autoHomeTransition').value = state.autoHomeTransition;
      $('serialResumeDelay').value = state.serialResumeDelayMs;
      $('autoHomeSettings').style.display = 'none'; // always start hidden unless manually toggled
      $('btnToggleAutoHomeSettings').textContent = 'Show';

      // Auto-connect serial UI initialization
      $('autoConnectSerial').checked = state.autoConnectSerial;
      if (state.lastSerialBaud) $('baud').value = state.lastSerialBaud;

      setVideoModeUi();
      applyDefaultMuteForSync();
      updateFollowSourceOptions();

      setWsPill(false);
      setSerialPill(false);
      setDrivePill();
      setFsPill();

      setStatusReady();
      connectWs();
      // Defer to keep first-paint interactive.
      setTimeout(() => { void listPorts(); }, 0);
      
      // Auto-connect to serial if enabled
      if (state.autoConnectSerial && state.lastSerialPort) {
        // Wait a bit for port list to be ready
        setTimeout(async () => {
          try {
            // Check if the last used port is still available
            const select = $('port');
            const options = Array.from(select.options).map(opt => opt.value);
            if (options.includes(state.lastSerialPort)) {
              select.value = state.lastSerialPort;
              logToConsole('log', `Auto-connecting to ${state.lastSerialPort}...`);
              await window.mv.serialConnect({ path: state.lastSerialPort, baudRate: state.lastSerialBaud });
              state.serialConnected = true;
              setSerialPill(true);
              updateAxisQuickUi();
              setStatus('Serial auto-connected');
              logToConsole('log', 'Serial auto-connect successful');
            } else {
              logToConsole('warn', `Auto-connect failed: ${state.lastSerialPort} not found`);
            }
          } catch (err) {
            logToConsole('error', 'Auto-connect failed:', err);
          }
        }, 500);
      }
      
      // Defer heavy list render until after initial paint.
      setTimeout(() => { void refresh(); }, 0);

      const v = $('video');
      if (v instanceof HTMLVideoElement) {
        const fps = 30;
        const push = (e) => {
          if (isLocalVideoEventSuppressed()) return;
          if (isHereSphereFollowLockActive()) return;
          // Don't send sync updates if we're currently applying remote state (prevent feedback loop)
          if (state.isApplyingRemoteState) return;
          if (!state.current) return;
          const timeMs = Math.round((v.currentTime || 0) * 1000);
          const frame = currentFrame(v.currentTime || 0, fps);

          // Coordinated seek: if we're the driver and we seek while playing, pause and resync
          // so both ends buffer the new segment before starting together.
          if (e && e.type === 'seeked' && !v.paused && !state.followRemote && getControlTargetClientId()) {
            startSeekSyncAsLeader(v, timeMs).catch(() => {});
            return;
          }
          // Auto-home should also respond to manual pauses triggered via native video controls.
          if (v.paused) triggerAutoHome();
          else cancelAutoHome();
          // Manual user interactions sync (force=true) when we're the driver.
          // Note: We intentionally do NOT run scheduled/"coordinated" start logic here because
          // programmatic play (e.g. from scheduleLocalPlayAt) also triggers these events.
          // Doing so would create a play->pause->play loop and spam the console.
          const playAt = (e && e.type === 'play') ? null : (v.paused ? null : undefined);
          sendSyncUpdate({ mediaId: state.current.id, timeMs, paused: v.paused, fps, frame, playAt }, true, getControlTargetClientId());
        };
        v.addEventListener('play', push);
        v.addEventListener('pause', push);
        v.addEventListener('seeked', push);

        v.addEventListener('error', () => {
          try {
            if (state.noVideo) return;
            if (!state.current || !state.current.id) return;

            // Only attempt once per media ID to avoid loops.
            const mediaId = String(state.current.id);
            if (state._av1FallbackTriedFor === mediaId) return;

            const err = v.error;
            const code = err && typeof err.code === 'number' ? err.code : 0;
            // 3 = MEDIA_ERR_DECODE, 4 = MEDIA_ERR_SRC_NOT_SUPPORTED
            if (code !== 3 && code !== 4) return;

            state._av1FallbackTriedFor = mediaId;
            const u = new URL(`/api/media/${encodeURIComponent(mediaId)}/stream`, state.serverUrl);
            u.searchParams.set('sessionId', String(state.sessionId || 'default'));
            u.searchParams.set('mvFrom', 'desktop');
            u.searchParams.set('transcode', 'h264');

            logToConsole('warn', 'Video failed to decode; retrying with server transcode (H.264) ...');
            v.src = u.toString();
            try { v.load(); } catch {}
            applyDefaultMuteForSync();
          } catch {}
        });
      }

      // Progress bar seeking
      const progressBar = $('progress');
      function applySeekMs(seekMs) {
        const ms = Number(seekMs);
        if (!Number.isFinite(ms)) return;
        try {
          if (!state.current) return;

          const clampedMs = Math.max(0, Math.round(ms));

          if (state.noVideo) {
            // Don't fight the remote driver.
            if (state.followRemote) return;

            state.noVideoBaseTimeMs = clampedMs;
            state.noVideoAnchorAtMs = Date.now();
            state.noVideoScheduledPlayAtLocalMs = 0;

            const fps = 30;
            const frame = currentFrame(clampedMs / 1000, fps);
            sendSyncUpdate({ mediaId: state.current.id, timeMs: clampedMs, paused: Boolean(state.noVideoPaused), fps, frame }, true, getControlTargetClientId());
            return;
          }

          const v = $('video');
          if (!(v instanceof HTMLVideoElement)) return;
          // Don't fight the remote driver.
          if (state.followRemote) return;

          v.currentTime = clampedMs / 1000;
          // If we're currently playing, the seeked event will trigger a coordinated seek-sync
          // so both ends buffer before resuming. Don't spam sync updates here.
          if (!v.paused && getControlTargetClientId()) return;

          // If paused, immediately sync the seek.
          const fps = 30;
          const frame = currentFrame(clampedMs / 1000, fps);
          sendSyncUpdate({ mediaId: state.current.id, timeMs: clampedMs, paused: v.paused, fps, frame }, true, getControlTargetClientId());
        } catch {}
      }

      if (progressBar instanceof HTMLInputElement) {
        progressBar.addEventListener('input', () => {
          const seekMs = Number(progressBar.value);
          applySeekMs(seekMs);
        });
      }

      // Seek by clicking/dragging the overview funscript graph
      const overviewCanvas = $('funscriptOverviewGraph');
      if (overviewCanvas instanceof HTMLCanvasElement) {
        let dragging = false;
        let pendingSeekMs = null;
        let lastMoveAt = 0;

        function getOverviewSeekMsFromClientX(clientX) {
          const actions = getActiveFunscriptActions();
          if (!actions || !Array.isArray(actions) || actions.length === 0) return null;

          const rect = overviewCanvas.getBoundingClientRect();
          const cssW = rect.width || overviewCanvas.clientWidth || 640;
          const padL = 10;
          const padR = 10;
          const w = Math.max(1, cssW - padL - padR);

          const maxAt = Math.max(0, Math.round(Number(actions[actions.length - 1]?.at) || 0));
          const dur = getCurrentDurationMsForOverview();
          const xMax = Math.max(1, dur != null ? dur : 0, maxAt);

          const x = clientX - rect.left;
          const clamped = clamp(x, padL, padL + w);
          const tScriptMs = ((clamped - padL) / w) * xMax;

          const delay = Math.round(Number(state.scriptDelay) || 0);
          let playbackMs = Math.round(tScriptMs + delay);
          if (dur != null && Number.isFinite(dur) && dur > 0) playbackMs = clamp(playbackMs, 0, dur);
          return playbackMs;
        }

        function isPlayingNow() {
          if (state.noVideo) return !Boolean(state.noVideoPaused);
          const v = $('video');
          return v instanceof HTMLVideoElement ? !Boolean(v.paused) : false;
        }

        function applyOverviewSeek(playbackMs, isFinal) {
          if (!Number.isFinite(playbackMs)) return;

          // If we are the driver and currently playing with a peer target, avoid triggering
          // many coordinated seek-sync handshakes while scrubbing; commit on pointer up.
          if (!isFinal && isPlayingNow() && getControlTargetClientId()) {
            pendingSeekMs = playbackMs;
            if (progressBar instanceof HTMLInputElement) progressBar.value = String(Math.round(playbackMs));
            return;
          }

          pendingSeekMs = null;
          if (progressBar instanceof HTMLInputElement) progressBar.value = String(Math.round(playbackMs));
          applySeekMs(playbackMs);
        }

        overviewCanvas.addEventListener('pointerdown', (e) => {
          try {
            // Don't fight the remote driver.
            if (state.followRemote) return;
            dragging = true;
            overviewCanvas.setPointerCapture(e.pointerId);
            const ms = getOverviewSeekMsFromClientX(e.clientX);
            if (ms == null) return;
            applyOverviewSeek(ms, false);
          } catch {}
        });

        overviewCanvas.addEventListener('pointermove', (e) => {
          try {
            if (!dragging) return;
            const now = Date.now();
            if (now - lastMoveAt < 45) return;
            lastMoveAt = now;
            const ms = getOverviewSeekMsFromClientX(e.clientX);
            if (ms == null) return;
            applyOverviewSeek(ms, false);
          } catch {}
        });

        function endDrag(e) {
          try {
            if (!dragging) return;
            dragging = false;
            const ms = pendingSeekMs != null ? pendingSeekMs : getOverviewSeekMsFromClientX(e.clientX);
            if (ms == null) return;
            applyOverviewSeek(ms, true);
          } catch {}
        }

        overviewCanvas.addEventListener('pointerup', endDrag);
        overviewCanvas.addEventListener('pointercancel', endDrag);
      }

      // Console view
      $('btnClearConsole').addEventListener('click', () => {
        state.consoleLogs = [];
        updateConsoleView();
        logToConsole('log', 'Console cleared');
      });

      logToConsole('log', 'Desktop client initialized');
      
      // Check if preload API is available
      if (window.mv) {
        logToConsole('log', 'Preload API available:', Object.keys(window.mv).join(', '));
      } else {
        logToConsole('error', 'Preload API (window.mv) not available! Check that preload.js is loaded correctly.');
      }

      startSerialDriveLoop();

      tick();
    </script>
  </body>
</html>
